head	1.6;
access;
symbols
	response:1.5;
locks; strict;
comment	@// @;


1.6
date	2012.10.09.03.57.20;	author sgliske;	state dead;
branches;
next	1.5;

1.5
date	2011.12.13.21.32.27;	author sgliske;	state Exp;
branches;
next	1.4;

1.4
date	2011.12.07.22.33.11;	author sgliske;	state Exp;
branches;
next	1.3;

1.3
date	2011.12.07.05.41.52;	author sgliske;	state Exp;
branches;
next	1.2;

1.2
date	2011.12.07.05.39.06;	author sgliske;	state Exp;
branches;
next	1.1;

1.1
date	2011.12.06.22.36.35;	author sgliske;	state Exp;
branches;
next	;


desc
@@


1.6
log
@removed unused makers
@
text
@/*!
 * \class StEEmcStripClusterFinderKMPP_t
 * \author Stephen Gliske <sgliske@@anl.gov>
 *
 * See header for description.
 *
*/

#include "StRoot/St_base/StMessMgr.h"
#include "StRoot/St_base/Stypes.h"

#include "StEEmcStripClusterFinderKMPP.h"
#include "KMPP/KMeans.h"

#define DEBUG

StEEmcStripClusterFinderKMPP_t::StEEmcStripClusterFinderKMPP_t( Int_t numDataPts ) :
   mNumDataPoints( numDataPts ), mMinNumClusters(1), mMaxNumClusters(5), mMinStripsPerCluster(5), mAttemptsPerNumClusters(20) {
   // ensure minimum number of data points
   if( numDataPts < 10*kMaxNumClusters )
      numDataPts = 10*kMaxNumClusters;

   mData = new Double_t[ numDataPts ];
   mAssignmentsA =  new Int_t[ numDataPts ];
   mAssignmentsB =  new Int_t[ numDataPts ];

   rand.SetSeed();
};

StEEmcStripClusterFinderKMPP_t::~StEEmcStripClusterFinderKMPP_t(){
   delete mData;
   delete mAssignmentsA;
   delete mAssignmentsB;
};

/// find some clusters
Int_t StEEmcStripClusterFinderKMPP_t::find( const StEEmcStripVec_t& hitStrips, StSimpleClusterVec_t& clusters ){
   clusters.clear();

   if( mMaxNumClusters > kMaxNumClusters ){
      LOG_WARN << "Max clusters above hardcoded limit of " << kMaxNumClusters << endm;
      mMaxNumClusters = kMaxNumClusters;
   };

   // skip if not enough strips hit
   if( hitStrips.size() < static_cast< UInt_t >( mMinStripsPerCluster ) )
      return kStOK;

   // clear strip energy array
   for( Double_t *p = mStripEnergyArray; p != &mStripEnergyArray[kEEmcNumStrips+1]; ++p )
      (*p) = 0;

   // first set CDF to equal the strip energies
   for( StEEmcStripVec_t::const_iterator iter = hitStrips.begin(); iter != hitStrips.end(); ++iter ){
      if( !iter->fail()  ){
         mStripEnergyArray[ iter->index() ] = iter->energy();
         cout << "ccc " << iter->index() << ' ' << iter->energy() << endl;
      };
   };

   // compute CDF
   mCDF[0] = 0;
   for( Double_t *pCDF = &mCDF[1], *pE = mStripEnergyArray; pCDF != &mCDF[kEEmcNumStrips+1]; ++pCDF, ++pE )
      (*pCDF) = *(pCDF-1) + (*pE);

   Double_t totE = mCDF[kEEmcNumStrips];

   // fill the mData vector
   for( Double_t *dataPtr = mData; dataPtr != &mData[mNumDataPoints]; ++dataPtr )
      (*dataPtr) = findPosition( rand.Rndm() * totE );

   Int_t *tempAssignments = mAssignmentsA;
   Int_t *assignments = mAssignmentsB;

   Double_t *tempCenters = mCentersA;
   Double_t *centers = mCentersB;

   Double_t lowestCost = -1;

   for( Int_t numClusters = mMaxNumClusters; numClusters >= mMinNumClusters; --numClusters ){
#ifdef DEBUG
      LOG_INFO << "Calling MKPP to find " << numClusters << endm;
#endif

      Double_t cost = RunKMeansPlusPlus( mNumDataPoints, numClusters, 1, mData, mAttemptsPerNumClusters, tempCenters, tempAssignments );

      cost += 2*numClusters*hitStrips.size();

#ifdef DEBUG
      LOG_INFO << "\tResult: cost = " << cost << endm;
#endif 

      if( lowestCost < 0 || cost < lowestCost ){
         // switch around the temp and actual, so that the values are saved
         Int_t *iptr = tempAssignments;
         tempAssignments = assignments;
         assignments = iptr;

         Double_t* ptr = tempCenters;
         tempCenters = centers;
         centers = ptr;

         lowestCost = cost;

#ifdef DEBUG
      LOG_INFO << "\tLowest cost so far." << endm;
#endif 

      };
   };

   Double_t (*ppStart)[kEEmcNumStrips] = mCounts;
   Double_t (*ppEnd)[kEEmcNumStrips] = &mCounts[kMaxNumClusters];

   // clear the mCounts vector
   for( Double_t (*pp)[kEEmcNumStrips] = ppStart; pp != ppEnd; ++pp )
      for( Double_t *p = &pp[0][0]; p != &pp[0][kEEmcNumStrips]; ++p )
         (*p) = 0;

   // fill up the mCounts vector
   Double_t *dataPtr = mData;
   for( Int_t *iptr = assignments; iptr != &assignments[mNumDataPoints]; ++iptr, ++dataPtr ){
      ++mCounts[ *iptr ][ static_cast< Int_t >( (*dataPtr)+0.5 ) ];

// #ifdef DEBUG
//       cout << "bbb mCounts[" << *iptr << "][" << static_cast< Int_t >( (*dataPtr)+0.5 ) << "]" << endl;
// #endif
   };

   // normalize mCounts
   for( Int_t i=0; i<kEEmcNumStrips; ++i ){

      // compute sum
      Double_t totCounts = 0;
      for( Int_t j=0; j<kMaxNumClusters; ++j  )
         totCounts += mCounts[j][i];

      // divide by sum
      if( totCounts )
         for( Int_t j=0; j<kMaxNumClusters; ++j  )
            mCounts[j][i] /= totCounts;

#ifdef DEBUG
      if( i < 120 && i > 90 ){
         cout << "aaa " << i;
         for( Int_t j=0; j<kMaxNumClusters; ++j  )
            cout << ' ' << mCounts[j][i];
         cout << endl;
      };
#endif
   };

   // save results (convert into clusters)
   for( Int_t i=0; i<mMaxNumClusters; ++i ){
      if( centers[i] < kEEmcNumStrips && centers[i] >= 0 ){
         // count how many strips contribute to this cluster
         Int_t n = 0;
         for( Double_t *p = mCounts[i]; p != &mCounts[i][kEEmcNumStrips]; ++p )
            if( *p )
               ++n;

         if( n >= mMinStripsPerCluster ){
            clusters.push_back( StSimpleCluster_t( ++mLastClusterID ) );
            StSimpleCluster_t& clus = clusters.back();
            clus.setMeanX( centers[i] );

            TArrayS& memArr = clus.getMemberArray();
            TArrayF& wArr = clus.getWeightArray();

            memArr.Set( n );
            wArr.Set( n );

            Int_t idx = 0, i = 0, seedIdx = 0;
            Double_t maxStripE = 0;
            Double_t energy = 0;
            for( Double_t *p = mCounts[i], *ePtr = mStripEnergyArray; p != &mCounts[i][kEEmcNumStrips] && idx < n; ++p, ++i, ++ePtr ){
               if( *p ){
                  memArr[idx] = i;
                  wArr[idx++] = (*p);

                  Double_t thisE = (*p) * (*ePtr);
                  energy += thisE;
                  if( thisE > maxStripE ){
                     maxStripE = thisE;
                     seedIdx = idx;
                  };
               };
            };

            clus.setEnergy( energy );
            clus.setSeedIdx( seedIdx );

#ifdef DEBUG
            LOG_INFO << getEventNum() << " Sector " << mSector << " layer " << mLayer << ' ' << clus << endm;
#endif
         };
      };
   };

   return kStOk;
};

// to find fractional positions through the CDF
Double_t StEEmcStripClusterFinderKMPP_t::findPosition( Double_t energy ){
   Double_t *iter1 = mCDF;
   Double_t *iter2 = mCDF;
   for( iter2 = mCDF; iter2 != &mCDF[kEEmcNumStrips-1] && (*iter2) < energy; ++iter2 )
      if( (*iter2) < energy )
         iter1 = iter2;

   // note: iter1 points to the last one before being over, and iter2 points to the first one after
   return (Int_t)(iter1 - mCDF) + (energy-(*iter1))/((*iter2)-(*iter1))*((Int_t)( iter2 - iter1 ));
};

ClassImp( StEEmcStripClusterFinderKMPP_t );

/*
 * $Id: StEEmcStripClusterFinderKMPP.cxx,v 1.5 2011/12/13 21:32:27 sgliske Exp $
 * $Log: StEEmcStripClusterFinderKMPP.cxx,v $
 * Revision 1.5  2011/12/13 21:32:27  sgliske
 * Bug fix: now ensure clusters have unique IDs across sectors and layers.
 * Otherwise, StMcHitMakerStrips has errors.
 * Few other small updates also included in this checkin.
 *
 * Revision 1.4  2011/12/07 22:33:11  sgliske
 * update
 *
 * Revision 1.3  2011/12/07 05:41:52  sgliske
 * added KMPP
 *
 * Revision 1.2  2011/12/07 05:39:06  sgliske
 * update
 *
 * Revision 1.1  2011/12/06 22:36:35  sgliske
 * update
 *
 *
 */
@


1.5
log
@Bug fix: now ensure clusters have unique IDs across sectors and layers.
Otherwise, StMcHitMakerStrips has errors.
Few other small updates also included in this checkin.
@
text
@d218 1
a218 1
 * $Id: StEEmcStripClusterFinderKMPP.cxx,v 1.4 2011/12/07 22:33:11 sgliske Exp $
d220 5
@


1.4
log
@update
@
text
@d163 1
a163 1
            clusters.push_back( i );
d218 1
a218 1
 * $Id: StEEmcStripClusterFinderKMPP.cxx,v 1.3 2011/12/07 05:41:52 sgliske Exp $
d220 3
@


1.3
log
@added KMPP
@
text
@d54 2
a55 2
   for( StEEmcStripVec_t::const_iterator iter = hitStrips.begin(); iter != hitStrips.end(); ++iter )
      if( !iter->fail()  )
d57 3
d80 1
a80 1
   for( Int_t numClusters = mMaxNumClusters; numClusters >= mMinNumClusters; ++numClusters ){
d87 2
d102 7
d122 1
a122 1
   for( Int_t *iptr = assignments; iptr != &assignments[mNumDataPoints]; ++iptr, ++dataPtr )
d125 5
d142 9
d185 1
a185 1
                     seedIdx = 0;
d218 1
a218 1
 * $Id: StEEmcStripClusterFinderKMPP.cxx,v 1.2 2011/12/07 05:39:06 sgliske Exp $
d220 3
@


1.2
log
@update
@
text
@d13 1
a13 1
#include "MKPP/Kmeans.h"
d192 1
a192 1
 * $Id: StEEmcStripClusterFinderKMPP.cxx,v 1.1 2011/12/06 22:36:35 sgliske Exp $
d194 3
@


1.1
log
@update
@
text
@d9 3
d15 4
a18 1
StEEmcStripClusterFinderKMPP_t::StEEmcStripClusterFinderKMPP_t( Int_t numDataPts ) : mNumDataPoints( numDataPts ), mMinNumClusters(1), mMaxNumClusters(5) {
d24 2
a25 2
   mAssignmentsA =  new Double_t[ numDataPts ];
   mAssignmentsB =  new Double_t[ numDataPts ];
d27 1
a27 1
   rand.seed();
d41 1
a41 1
      LOG_WARN << "Max clusters above hardcoded limit of " << kMaxNumClusters << endl;
d49 2
a50 2
   // clear CDF
   for( Double_t *p = mCDF; p != &mCDF[kEEmcNumStrips+1]; ++p )
d54 3
a56 3
   for( StEEmcStripVec_t::iterator iter = hitStrips.begin(); iter != hitStrips.end(); ++hitStrips )
      if( !hitStripIter->fail()  )
         mCDF[ iter->index() ] = iter->energy();
d59 3
a61 2
   for( Double_t *p = &mCDF[1]; p != &mCDF[kEEmcNumStrips+1]; ++p )
      (*p) += *(p-1);
d69 2
a70 1
   Double_t lowestCost = 0;
d72 2
a73 2
   Double_t tempAssigments = mAssignmentsA;
   Double_t assigments = mAssignmentsB;
d75 1
a75 2
   Double_t tempCenters = mCentersA;
   Double_t centers = mCentersB;
a76 1
   Double_t bestCost = -1;
d78 3
a80 1
      LOG_INFO << "Calling MKPP to find " << numClusters << endl;
d84 3
a86 1
      LOG_INFO << "\tResult: cost = " << cost << endl;
d88 1
a88 1
      if( bestCost < 0 || cost < bestCost ){
d90 3
a92 3
         Double_t *ptr = tempAssignments;
         tempAssignments = assigments;
         assigments = ptr;
d94 1
a94 1
         ptr = tempCenters;
d100 2
d103 23
a125 3
   // going to use tempCenters for holding the number of 
   Double_t *counts = tempCenters;
Double_t *maxStrip 
d127 1
a127 1
   // save results
d130 42
a171 17
         clusters.push_back( i );
         StSimpleCluster_t& clus = clusters.back();
         clus.setMeanX( centers[i] );

         // count first how many and find max
         Float_t maxVal;

      TArrayS& memArr = clus.getMemberArray();
      TArrayF& wArr = clus.getWeightArray();


   void setEnergy( const Float_t E ) { mE =  E; };
   void setMemberArray( const TArrayS array ){ mMember = array; };
   void setWeightArray( const TArrayF array ){ mWeight = array; };
   void setSeedIdx( Int_t seedIdx ) { mSeedIdx = seedIdx; };


d174 1
a174 1

d192 5
a196 2
 * $Id:  $
 * $Log: $
@

