head	1.6;
access;
symbols
	response:1.5;
locks; strict;
comment	@// @;


1.6
date	2012.10.09.03.57.19;	author sgliske;	state dead;
branches;
next	1.5;

1.5
date	2011.11.18.01.47.54;	author sgliske;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.18.01.47.03;	author sgliske;	state dead;
branches;
next	1.3;

1.3
date	2011.11.11.04.15.36;	author sgliske;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.10.23.43.26;	author sgliske;	state Exp;
branches;
next	1.1;

1.1
date	2011.11.10.23.33.33;	author sgliske;	state Exp;
branches;
next	;


desc
@@


1.6
log
@removed unused makers
@
text
@/*!
 *
 * \class StEEmcAnlSplitHitEigen_t
 * \author Stephen Gliske <sgliske@@anl.gov>
 *
 * Description: see header
 *
 */

#include "Stypes.h"
#include "StEEmcAnlSplitHitEigen.h"

#include "StRoot/St_base/Stypes.h"
#include "StRoot/St_base/StMessMgr.h"
#include "StRoot/StEEmcPool/StEEmcPointMap/StEEmcPointMap.h"
#include "StRoot/StEEmcPool/StEEmcGeoId/StEEmcGeoId.h"
#include "StEEmcAnlHit.h"
#include "AnlEMLineParams.h"

StEEmcAnlSplitHitEigen_t::StEEmcAnlSplitHitEigen_t() : mMaxEigenvalue(0.6) { /* */ };

StEEmcAnlSplitHitEigen_t::~StEEmcAnlSplitHitEigen_t() { /* */ };

Int_t StEEmcAnlSplitHitEigen_t::Init(){
   if( mMaxEigenvalue <= 0 )
      mMaxEigenvalue = 0.6;

   return kStOk;
};

Int_t StEEmcAnlSplitHitEigen_t::splitHit( const StEEmcAnlHit_t& hit, Bool_t& doSplit, Bool_t& doInvalidate, AnlEMPoint_t& point1, AnlEMPoint_t& point2 ){
   Int_t ierr = kStOk;
   doSplit = 0;
   doInvalidate = 0;

   // some iterators
   AnlEMPointVec_t pointVec;
   AnlEMPointVec_t::iterator pointVecIter;

   AnlEMPoint_t sum( 0, 0, 0 );

   // find all points where strips in this hit intersect
   getIntersectingPointSet( hit, pointVec, sum );

   // make a copy for the mean
   AnlEMPoint_t mean( sum );

   if( sum.W() ){
      mean.X() /= mean.W();
      mean.Y() /= mean.W();
   };

   Float_t varX = 0, varY = 0, varXY = 0, sumW2 = 0;

#ifdef DEBUG
   LOG_INFO << "III. mean position of intersections = (" << mean.X() << ' ' << mean.Y() << ")" << endm;
#endif

   // compute covariance
   for( pointVecIter = pointVec.begin(); pointVecIter != pointVec.end(); ++pointVecIter ){
      Float_t tempX = ( pointVecIter->X() - mean.X() );
      Float_t tempY = ( pointVecIter->Y() - mean.Y() );
      Float_t w = pointVecIter->W(); // faster?

      //std::cout << "zzz " << w << ' ' << pointVecIter->X() << ' ' << pointVecIter->Y() << ", " << tempX << ' ' << tempY << std::endl;

      varX += w*tempX*tempX;
      varY += w*tempY*tempY;
      varXY += w*tempX*tempY;
      sumW2 += w*w;
   };

   Float_t lambda = 0;
   Float_t tanAngle = 0;

   if( sumW2 ){
      //LOG_INFO << "Covariance before normalization: " << varX << ' ' << varY << ' ' << varXY << " | " << sum.W() << ' ' << sumW2 << endm;
      Float_t normFactor = sum.W() / ( sum.W()*sum.W() + sumW2 );

      LOG_INFO << "normFactor = " << normFactor*sum.W() << endm;

      varX *= normFactor;
      varY *= normFactor;
      varXY *= normFactor;

      // solve for eigen value and rotation angle

      // default value if no covariance
      lambda = ( varX > varY ? varX : varY );

      if( varXY ){
         Float_t half_trace = varX + varY;
         half_trace /= 2;
         Float_t det = varX*varY - varXY*varXY;
         Float_t temp = half_trace*half_trace - det; 

         // give a litte rounding error tolerance
         if( temp < 0 && temp > -1e-3 )
            temp = 0;

         //LOG_INFO << "half_trace = " << half_trace << ", det = " << det << ", lambda = " << half_trace << " + sqrt(" << temp << ")" << endm;

         if( temp >= 0 )
            lambda = half_trace + sqrt( temp );

         tanAngle = ( lambda - varX ) / varXY;

#ifdef DEBUG
         LOG_INFO << "st. dev = " << sqrt(varX) << ' ' << sqrt(varY) << ", cov. " << varXY
                  << ", cor. " << varXY/sqrt(varX*varY) << ", lambda = " << lambda << ", tanAngle = " << tanAngle << endm;
#endif
      };
   };

   if( lambda > mMaxEigenvalue ){
#ifdef DEBUG
      LOG_INFO << GetEventNumber() << ": Splitting hit at (" << hit.getX() << ", " << hit.getY() << "), eigenvalue is " << lambda << endm;
#endif

      doSplit = 1;

      // reset the (x,y) position
      Float_t xOffset = 0, yOffset = 0;

      if( varXY ){
         xOffset = sqrt( lambda / (1 + tanAngle*tanAngle) );
         yOffset = xOffset*tanAngle;
      } else {
         xOffset = ( varX > varY ? sqrt(varX) : 0 );
         yOffset = ( varY > varX ? sqrt(varY) : 0 );
      };

      point1.W() = 1;
      point1.X() = hit.getX()+xOffset;
      point1.Y() = hit.getY()+yOffset;

      point1.W() = 1;
      point1.X() = hit.getX()-xOffset;
      point1.Y() = hit.getY()-yOffset;
   };

   return ierr;
};


// Get all points where strips in a hit "could" intersect, so that one
// can compute the covariance in the divide strips member function.
// Weight should be set to membership weight, not the energy
void StEEmcAnlSplitHitEigen_t::getIntersectingPointSet( const StEEmcAnlHit_t& hit, AnlEMPointVec_t& pointVec, AnlEMPoint_t& sum ){
   sum.X() = 0;
   sum.Y() = 0;
   sum.W() = 0;

   TVector3 temp3vec;

   const StEEmcAnlElementSet_t stripSet = hit.getStripSet();

   AnlEMLineParamsVec_t lineParamsVec;
   AnlEMLineParamsVec_t::iterator lineParamsIter;

   Float_t thres = 0;

   if( hit.getStripSet().size() ){
      // set to 1/10ths the average strip height
      thres = 0.1 * hit.getEsmd()/hit.getStripSet().size();
   }

   StEEmcAnlElementSet_t::const_iterator stripSetIter1;
   for( stripSetIter1 = stripSet.begin(); stripSetIter1 != stripSet.end(); ++stripSetIter1 ){

      Bool_t layerIsV;
      Short_t sector1, strip;
      Float_t a1, b1;
      StEEmcPointMap_t::instance().getStripLineParam( stripSetIter1->getGeoId(), a1, b1 );
      StEEmcGeoId_t::decodeSmd( stripSetIter1->getGeoId(), sector1, layerIsV, strip );

      //cout << "lll " << mIterNum << " hit " << hit.getKey() << ' ' << sector1 << ' ' << layerIsV << ' ' << strip << ' ' << stripSetIter1->getEnergy() << endl;

      //Float_t hitE = stripSetIter1->getEnergy();
      //Float_t stripE = getStripDepositedEnergy( stripSetIter1->getGeoId() );
      //Float_t w1 = ( stripE ? hitE / stripE : 0 );
      //Float_t w1 = hitE;
      //Float_t w1 = (stripSetIter1->getEnergy() > mStripMinWeight ? log( stripSetIter1->getEnergy()/mStripMinWeight ) : 0 );
      Float_t w1 = (stripSetIter1->getEnergy() > thres ? log( stripSetIter1->getEnergy()/thres ) : 0 );

      //cout << "line for strip " << stripSetIter1->getGeoId() << ' '  << a1 << ' ' << b1 << ", layer = " << layerIsV << endl;

      // don't push back these values until after the loop, to avoid looking for the intersection of a strip with itself

      // use the previously computed values
      for( lineParamsIter = lineParamsVec.begin(); lineParamsIter != lineParamsVec.end(); ++lineParamsIter ){
         const Int_t &sector2 = lineParamsIter->sector();
         const Float_t &a2 = lineParamsIter->a();
         const Float_t &b2 = lineParamsIter->b();

         // make sure in same or adjacent sectors, but not parallel
         if( a1 != a2 && TMath::Abs(sector2-sector1) < 2 ){
            Float_t x = ( b1 - b2 ) / ( a2 - a1 );
            Float_t y = a1*x + b1;

            Float_t w = w1 + lineParamsIter->weight();

            Float_t rSq = x*x + y*y;
            if( rSq > mInnerRsq && rSq < mOuterRsq ){

               //cout << "qqq " << mIterNum << " hit " << hit.getKey() << " intersection: " << x << " " << y << " " << w << endl;

               // do not check if strips really cross
               //             if( x > std::min( x1start, x1stop ) && 
               //                 x > std::min( x2start, x2stop ) && 
               //                 x < std::max( x1start, x1stop ) && 
               //                 x < std::max( x2start, x2stop ) ){

               pointVec.push_back( AnlEMPoint_t( w, x, y ) );

               sum.X() += x*w;
               sum.Y() += y*w;
               sum.W() += w;
            };
         };
      };

      lineParamsVec.push_back( AnlEMLineParams_t( sector1, w1, a1, b1 ) );
   };

   return;
};

ClassImp( StEEmcAnlSplitHitEigen_t );

/*
 * $Id: StEEmcAnlSplitHitEigen.cxx,v 1.5 2011/11/18 01:47:54 sgliske Exp $
 *
 * $Log: StEEmcAnlSplitHitEigen.cxx,v $
 * Revision 1.5  2011/11/18 01:47:54  sgliske
 * today
 *
 * Revision 1.3  2011/11/11 04:15:36  sgliske
 * update: it compiles!
 *
 * Revision 1.2  2011/11/10 23:43:26  sgliske
 * update
 *
 * Revision 1.1  2011/11/10 23:33:33  sgliske
 * Re-arranged hit splitting & added new base class and algos
 *
 * 
 */
@


1.5
log
@today
@
text
@d232 1
a232 1
 * $Id: StEEmcAnlSplitHitEigen.cxx,v 1.3 2011/11/11 04:15:36 sgliske Exp $
d235 3
@


1.4
log
@today
@
text
@d16 1
a17 1
#include "StRoot/StEEmcPool/StEEmcGeoId/StEEmcGeoId.h"
@


1.3
log
@update: it compiles!
@
text
@d232 1
a232 1
 * $Id: StEEmcAnlSplitHitEigen.cxx,v 1.2 2011/11/10 23:43:26 sgliske Exp $
d235 3
@


1.2
log
@update
@
text
@d31 1
a31 1
Int_t StEEmcAnlSplitHitEigen_t::splitHit( const StEEmcAnlHit_t& hit, Bool_t& doSplit, AnlEMPoint_t& point1, AnlEMPoint_t& point2 ){
d33 2
d232 1
a232 1
 * $Id: StEEmcAnlSplitHitEigen.cxx,v 1.1 2011/11/10 23:33:33 sgliske Exp $
d235 3
@


1.1
log
@Re-arranged hit splitting & added new base class and algos
@
text
@d3 1
a3 1
 * \class StEEmcAnlSplitHitMorhac_t
d11 1
a11 1
#include "StEEmcAnlSplitHitMorhac.h"
d18 1
d20 3
a22 12
StEEmcAnlSplitHitMorhac_t::StEEmcAnlSplitHitMorhac_t() : 
   peakFinderPtr(0),
   mMaxNumPoints(4),
   mResolution(1),
   mStartWidth(1.5),
   mStopWidth(5),
   mWidthStepSize(0.1) { /* */ };

StEEmcAnlSplitHitMorhac_t::~StEEmcAnlSplitHitMorhac_t(){ 
   if( peakFinderPtr )
      delete peakFinderPtr;
};
d24 3
a26 2
Int_t StEEmcAnlSplitHitMorhac_t::Init(){
   peakFinderPtr = new TSpectrum( mMaxNumPtrs, mResolution );
d31 1
a31 1
Int_t StEEmcAnlSplitHitMorhac_t::splitHit( const StEEmcAnlHit_t& hit, Bool_t& doSplit, AnlEMPoint_t& point1, AnlEMPoint_t& point2 ){
d84 1
a84 1
      // solve for morhac value and rotation angle
d113 1
a113 1
   if( lambda > mMaxMorhacvalue ){
d115 1
a115 1
      LOG_INFO << GetEventNumber() << ": Splitting hit at (" << hit.getX() << ", " << hit.getY() << "), morhacvalue is " << lambda << endm;
d147 1
a147 1
void StEEmcAnlSplitHitMorhac_t::getIntersectingPointSet( const StEEmcAnlHit_t& hit, AnlEMPointVec_t& pointVec, AnlEMPoint_t& sum ){
d227 1
a227 1
ClassImp( StEEmcAnlSplitHitMorhac_t );
d230 5
a234 1
 * $Id:  $
a235 1
 * $Log: $
@

