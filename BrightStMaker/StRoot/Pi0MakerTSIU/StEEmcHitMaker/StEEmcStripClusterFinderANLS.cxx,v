head	1.5;
access;
symbols
	response:1.4;
locks; strict;
comment	@// @;


1.5
date	2012.10.09.03.57.20;	author sgliske;	state dead;
branches;
next	1.4;

1.4
date	2011.12.15.22.21.18;	author sgliske;	state Exp;
branches;
next	1.3;

1.3
date	2011.12.13.21.32.27;	author sgliske;	state Exp;
branches;
next	1.2;

1.2
date	2011.12.09.18.01.16;	author sgliske;	state Exp;
branches;
next	1.1;

1.1
date	2011.12.09.03.33.43;	author sgliske;	state Exp;
branches;
next	;


desc
@@


1.5
log
@removed unused makers
@
text
@/*!
 * \class StEEmcStripClusterFinderANLS_t
 * \author Stephen Gliske <sgliske@@anl.gov>
 *
 * See header for description.
 *
*/

#include <list>
#include <TMath.h>
#include <assert.h>

#include "StRoot/St_base/StMessMgr.h"
#include "StRoot/St_base/Stypes.h"

#include "StEEmcStripClusterFinderANLS.h"
#include "IdxValPair.h"

//#define DEBUG
//#define DEBUG2
//#define DEBUG3
//#define DEBUG_INPUT
//#define DEBUG_MC


StEEmcStripClusterFinderANLS_t::StEEmcStripClusterFinderANLS_t() :
   mMinStripsPerCluster( 5 ),
   mSideWidth( 3 ),
   mMinSeedDist( 3 ),
   mMaxWidth( 10 ),
   mDensityEstWidth( 1 ),
   mSeedEnergyThres( 0.003 ),
   mSeedRelThres( 0.05 ),
   mMinClusterEnergy( 0.01 ),
   mMergeThres( 1.0 )
{
   // initialize a few parent variables
   mLayer = U_LAYER;
   mSector = 0;
   mIsReady = 1;
};

StEEmcStripClusterFinderANLS_t::~StEEmcStripClusterFinderANLS_t(){
   // nothing to do
};


/// find some clusters
Int_t StEEmcStripClusterFinderANLS_t::find( const StEEmcStripVec_t& hitStrips, StSimpleClusterVec_t& clustersOut ){
   clustersOut.clear();
   Int_t ierr = kStOk;

   if( mMinSeedDist < 3 ){
      LOG_WARN << "Min. seed distance reset to 3" << endm;
      mMinSeedDist = 3;
   };

   StSimpleClusterList_t clusters;

   // skip if not enough strips hit
   if( hitStrips.size() < static_cast< UInt_t >( mMinStripsPerCluster ) )
      return ierr;

   // clear array
   for( Float_t *p1 = mSmearedEnergyArray, *p2 = mStripEnergyArray; p1 != &mSmearedEnergyArray[kEEmcNumStrips]; ++p1, ++p2 )
      (*p1) = (*p2) = 0;

   // copy
   Int_t smallestIdx = kEEmcNumStrips, largestIdx = -1;
   for( StEEmcStripVec_t::const_iterator iter = hitStrips.begin(); iter != hitStrips.end(); ++iter ){
      if( !iter->fail()  ){
         Int_t idx = iter->index();
         mStripEnergyArray[ idx ] =  iter->energy();

         if( idx > largestIdx )
            largestIdx = idx;
         if( idx < smallestIdx )
            smallestIdx = idx;

#ifdef DEBUG_INPUT
         cout << "ccc " << mSector << ' ' << (mLayer ? 'v' : 'u' ) << ' ' << iter->index() << ' ' << iter->energy() << endl;
#endif
      };
   };

   // vector of seeds
   IdxValPairVec_t seedVec; // sorted by Idx
   ValIdxPairList_t seedList;   // sorted by Energy

   // "smear" to reduce noise
   Int_t startIdx = smallestIdx - mSideWidth;
   Int_t endIdx = largestIdx + mSideWidth;
   if( startIdx < 0 )
      startIdx = 0;
   if( endIdx >= kEEmcNumStrips )
      endIdx = kEEmcNumStrips;

   Float_t *pMid = &mSmearedEnergyArray[startIdx];
   Float_t *pLow = &mStripEnergyArray[startIdx-mSideWidth-1];
   Float_t *pHigh = &mStripEnergyArray[startIdx+mSideWidth];

   // make sums
   Float_t factor = 1./( 1. + 2.*mSideWidth );
   for( Int_t idx = startIdx; pMid != &mSmearedEnergyArray[endIdx]; ++pMid, ++pLow, ++pHigh, ++idx ){
      (*pMid) = (pMid == mSmearedEnergyArray ? 0 : *(pMid-1) );

      if( pLow >= &mStripEnergyArray[0] )
         (*pMid) -= (*pLow)*factor;
      if( pHigh < &mStripEnergyArray[kEEmcNumStrips] )
         (*pMid) += (*pHigh)*factor;

      if( (*pMid) > mSeedEnergyThres )
         seedVec.push_back( IdxValPair_t( idx, (*pMid) ) );

      if( (*pMid) < 0 )
         (*pMid) = 0;

#ifdef DEBUG_INPUT2
      cout << "ddd " << idx << ' ' << (*pMid)
//            << " = " << (pMid == mSmearedEnergyArray ? 0 : *(pMid-1) ) << " - " << (*pLow)*factor << " + " << (*pHigh)*factor << ' '
//            << std::distance( mStripEnergyArray, pLow ) << ' '
//            << std::distance( mSmearedEnergyArray, pMid ) << ' '
//            << std::distance( mStripEnergyArray, pHigh )
           << endl;
#endif
   };

   // note: seedVec sorted by idx (ascending)

   if( !seedVec.empty() ){
      // now fill list and sort by energy
      seedList.assign( seedVec.begin(), seedVec.end() );
      seedList.sort();

#ifdef DEBUG5
      LOG_INFO << "Seeds above fixed thres " << endm;

      ValIdxPairList_t::iterator iter;
      for( iter = seedList.begin(); iter != seedList.end(); ++iter ){
         LOG_INFO << iter->idx << ' ' << iter->val << endm;
      };
#endif

      // remove those below the relative threshold
      Float_t relThres = mSeedRelThres * seedVec.front().val;
      if( relThres > mSeedEnergyThres )
         seedList.erase( seedList.begin(), std::upper_bound( seedList.begin(), seedList.end(), relThres ) );

      if( !seedList.empty() ){
         // set order to be descending
         seedList.reverse();

         // remove any that are too close (keeping higher energy one)
         ValIdxPairList_t::iterator listIter1, listIter2;
         for( listIter1 = seedList.begin(); listIter1 != seedList.end(); ++listIter1 )
            for( (listIter2 = listIter1)++; listIter2 != seedList.end(); ++listIter2 )
               if( listIter1 != listIter2 && abs( listIter1->idx - listIter2->idx) < mMinSeedDist )
                  listIter2 = --seedList.erase( listIter2 );
      };
   };

   if( !seedList.empty() ){

#ifdef DEBUG
      LOG_INFO << "Sector " << mSector << " layer " << (mLayer?'v':'u') << " found " << seedList.size() << " seeds" << endm;
#endif
#ifdef DEBUG2
      LOG_INFO << "Seeds are at " << endm;

      ValIdxPairList_t::iterator iter;
      for( iter = seedList.begin(); iter != seedList.end(); ++iter ){
         LOG_INFO << iter->idx << ' ' << iter->val << endm;
      };
#endif

      Int_t nSeeds = seedList.size();

      // copy seeds back to the vector
      seedVec.assign( seedList.begin(), seedList.end() );
      std::sort( seedVec.begin(), seedVec.end() );

      std::vector< Float_t > midPoints;
      midPoints.reserve( nSeeds - 1 );

      std::vector< Int_t > stripsPerClus;
      stripsPerClus.reserve( kEEmcNumStrips );

      for( Int_t iseed = 0; iseed < nSeeds; ++iseed ){
         stripsPerClus.clear();
         Int_t seedIdx = seedVec[iseed].idx;

         // add cluster
         clusters.push_back( StSimpleCluster_t( ++mLastClusterID ) );
         StSimpleCluster_t& clus = clusters.back();

         Float_t pos1 = -1, pos2 = -1;
         if( iseed == 0 ){
            pos1 = (seedIdx < mMaxWidth ? 0 : (seedIdx - mMaxWidth) );
         } else {
            Int_t prevSeedIdx = seedVec[iseed-1].idx;
            pos1 = 0.5*( seedIdx + prevSeedIdx );
         };

         if( iseed+1 == nSeeds ){
            pos2 = (seedIdx+mMaxWidth < kEEmcNumStrips ? (seedIdx + mMaxWidth) : kEEmcNumStrips );
         } else {
            Int_t nextSeedIdx = seedVec[iseed+1].idx;
            pos2 = 0.5*( seedIdx + nextSeedIdx );
         };

         Float_t energy = 0;
         Float_t weightedMean = 0;
         for( Int_t idx = pos1; idx < pos2; ++idx ){
            if( mStripEnergyArray[idx] )
               stripsPerClus.push_back( idx );
            if( mSmearedEnergyArray[idx] ){
               energy += mSmearedEnergyArray[idx];
               weightedMean += mSmearedEnergyArray[ idx ] * idx;
            };
         };
         assert( energy ); // this must be true or something really weird happened
         weightedMean /= energy;

         Int_t n = stripsPerClus.size();

         TArrayS& memArr = clus.getMemberArray();
         TArrayF& wArr = clus.getWeightArray();

         memArr.Set( n );
         wArr.Set( n );

         Int_t internalSeedIdx = 0;
         for( Int_t i = 0; i < n; ++i ){
            Int_t idx = stripsPerClus.back();
            stripsPerClus.pop_back();

#ifdef DEBUG_MC
            cout << "eee " << mSector << ' ' << (mLayer ? 'v' : 'u' ) << ' ' << clus.getID() << ' ' << idx << ' ' << mStripEnergyArray[idx] << endl;
#endif

            memArr[i] = idx;
            wArr[i] = 1;

            if( idx == seedIdx )
               internalSeedIdx = i;
         };

         clus.setMeanX( weightedMean );
         clus.setEnergy( energy );
         clus.setSeedIdx( internalSeedIdx );

#ifdef DEBUG
         LOG_INFO << "Semi-final results: event " << getEventNum() << " sector/layer " << mSector << '/'
                  << (mLayer ? 'v' : 'u') << ' ' << clus << endm;
#endif
      };
   };

   if( mDensityEstWidth < 0 ){
      LOG_WARN << "Negative mDensityEstWidth value given.  Setting to zero." << endm;
      mDensityEstWidth = 0;
   };
   
   // Now double check if any clusters should be merged. Note:
   // clusters ordered by seed position, and internal members ordered
   // by strip idx.
   if( clusters.size() > 1 ){
      // iterate through, and merge as needed
      StSimpleClusterList_t::iterator clusIter, clusIter2;
      Float_t localDensityL = 0, energyL = 1e100, lastRatio = -1;
      Int_t seedIdxL = -1000, seedIdxLL = -10000, stripsPerClusterL = 1000;

      for( clusIter = clusters.begin(); clusIter != clusters.end(); ++clusIter ){
         Int_t seedIdxR = clusIter->getSeedMember();
         Float_t energyR = clusIter->getEnergy();
         assert( seedIdxR > -1 && seedIdxR < kEEmcNumStrips );
         Int_t stripsPerClusterR = clusIter->getMemberArray().GetSize();

         Int_t n = 0;
         Float_t localDensityR = 0;
         for( Int_t i = std::max( 0, seedIdxR - mDensityEstWidth ); i <= std::min( kEEmcNumStrips, seedIdxR + mDensityEstWidth ); ++i, ++n )
            localDensityR += mSmearedEnergyArray[i];
         assert(n); // must be true or someone broke the code
         localDensityR /= n;

#ifdef DEBUG2 
         LOG_INFO << seedIdx << " local density is " << localDensityR << endm;
#endif
         Float_t ratio = -1;
         clusIter->setMeanY( 10000 );  // a big number
         if( clusIter != clusters.begin() ){
            // compute density between clusters
            Float_t betweenDensity = 0.5*( mSmearedEnergyArray[seedIdxL] + mSmearedEnergyArray[seedIdxR] );
            n = 1;
            for( Int_t i = seedIdxL + 1; i < seedIdxR; ++i, ++n )
               betweenDensity += mSmearedEnergyArray[i];
            betweenDensity /= n;

            Float_t ratio = betweenDensity / std::min( localDensityL, localDensityR );
#ifdef DEBUG 
            LOG_INFO << "Ratio is " << ratio << ", energyL is " << energyL << " stripsL is " << stripsPerClusterL << " width is " << seedIdxR << " - " << seedIdxL << endm;
#endif
            // meanY is an unused field for strip clusters, so use it to store the ratio
            clusIter->setMeanY( ratio );

            if( ratio > mMergeThres && seedIdxR - seedIdxL < mMaxWidth ){
#ifdef DEBUG
               LOG_INFO << "Merging clusters w/ seed " << seedIdxL << ' ' << seedIdxR << " due to ratio " << ratio << endm;
#endif

               // merge the two 
               clusIter2 = clusIter;
               --clusIter;
               *clusIter += *clusIter2;
               clusters.erase( clusIter2 );

               // do not change local density R or seedIdxR, so that
               // the rest will proceed identically as if this merge
               // did not take place.

               // do change stripsPerCluster and energy
               stripsPerClusterR = clusIter->getMemberArray().GetSize();
               energyR = clusIter->getEnergy();

               // check for other reasons to merge
            } else if ( energyL < mMinClusterEnergy || stripsPerClusterL < mMinStripsPerCluster ){

               Bool_t doMerge = 0;
               Bool_t mergeBack = 0;

               // merge left with cluster before it, rather than this
               // one (the one after it)
               if( lastRatio > ratio && seedIdxL - seedIdxLL < mMaxWidth ){
                  --clusIter;  // merge previous two
                  mergeBack = 1;
                  doMerge = 1;
               } else if ( seedIdxR - seedIdxL < mMaxWidth ){
                  doMerge = 1;
               };

               if( doMerge ){
                  // prepare to merge
                  clusIter2 = clusIter;
                  --clusIter;
#ifdef DEBUG 
                  LOG_INFO << "Merging clusters w/ seed " << clusIter->getSeedMember() << ' ' << clusIter2->getSeedMember() << " due to E " << energyL << " or strip# " << stripsPerClusterL << endm;
#endif
                  *clusIter += *clusIter2;
                  clusters.erase( clusIter2 );

                  // get back to the correct position
                  if( mergeBack ){
                     ++clusIter;  // merge previous two
                  };

               } else {
#ifdef DEBUG 
                  LOG_INFO << "Deleting clusters w/ seed " << clusIter->getSeedMember() << ' ' << clusIter2->getSeedMember() << " due to E " << energyL << " or strip# " << stripsPerClusterL << endm;
#endif

                  clusIter2 = clusIter;
                  --clusIter2;
                  clusters.erase( clusIter2 );
               };

               // do change stripsPerCluster and energy
               stripsPerClusterR = clusIter->getMemberArray().GetSize();
               energyR = clusIter->getEnergy();
               clusIter2 = clusIter;
               --clusIter2;
               seedIdxL = clusIter2->getMemberArray().GetSize();
            };
         };
         localDensityL = localDensityR;
         seedIdxL = seedIdxR;
         seedIdxLL = seedIdxL;
         energyL = energyR;
         lastRatio = ratio;
         stripsPerClusterL = stripsPerClusterR;
      };
   };

   // copy over
   clustersOut.assign( clusters.begin(), clusters.end() );

   // double check a possibly missed case
   if( clustersOut.size() == 1 && clustersOut.front().getEnergy() < mMinClusterEnergy )
      clustersOut.pop_back();

#ifdef DEBUG
   for( UInt_t i=0; i<clustersOut.size(); ++i ){
      LOG_INFO << "Final results: event " << getEventNum() << " sector/layer " << mSector << '/'
               << (mLayer ? 'v' : 'u') << ' ' << clustersOut[i] << endm;
   };
#endif

   return ierr;
};

ClassImp( StEEmcStripClusterFinderANLS_t );

/*
 * $Id: StEEmcStripClusterFinderANLS.cxx,v 1.4 2011/12/15 22:21:18 sgliske Exp $
 * $Log: StEEmcStripClusterFinderANLS.cxx,v $
 * Revision 1.4  2011/12/15 22:21:18  sgliske
 * update
 *
 * Revision 1.3  2011/12/13 21:32:27  sgliske
 * Bug fix: now ensure clusters have unique IDs across sectors and layers.
 * Otherwise, StMcHitMakerStrips has errors.
 * Few other small updates also included in this checkin.
 *
 * Revision 1.2  2011/12/09 18:01:16  sgliske
 * finished creation
 *
 * Revision 1.1  2011/12/09 03:33:43  sgliske
 * creation
 *
 *
 */
@


1.4
log
@update
@
text
@d403 1
a403 1
 * $Id: StEEmcStripClusterFinderANLS.cxx,v 1.3 2011/12/13 21:32:27 sgliske Exp $
d405 3
@


1.3
log
@Bug fix: now ensure clusters have unique IDs across sectors and layers.
Otherwise, StMcHitMakerStrips has errors.
Few other small updates also included in this checkin.
@
text
@d17 1
a17 1
#include "GmmEm1D/GmmEm1D.h"
a24 37
// helper classes

struct IdxValPair_t;
struct ValIdxPair_t;

// default sort by idx
struct IdxValPair_t {
   Int_t idx;
   Float_t val;

   IdxValPair_t( Int_t i=0, Float_t v=0 ) : idx(i), val(v) { /* */ };
   IdxValPair_t( const ValIdxPair_t& other );
   IdxValPair_t( const IdxValPair_t& other );
   Bool_t operator< ( const IdxValPair_t& rhs ) const { return idx < rhs.idx; };
};

// default sort by val
struct ValIdxPair_t : public IdxValPair_t {
   ValIdxPair_t( Int_t i=0, Float_t v=0 ) : IdxValPair_t(i,v) { /* */ };
   ValIdxPair_t( const ValIdxPair_t& other );
   ValIdxPair_t( const IdxValPair_t& other );
   Bool_t operator< ( const ValIdxPair_t& rhs ) const { return val < rhs.val; };
};

IdxValPair_t::IdxValPair_t( const ValIdxPair_t& other ) : idx(other.idx), val(other.val) { /* */ };
IdxValPair_t::IdxValPair_t( const IdxValPair_t& other ) : idx(other.idx), val(other.val) { /* */ };
ValIdxPair_t::ValIdxPair_t( const ValIdxPair_t& other ) : IdxValPair_t(other) { /* */ };
ValIdxPair_t::ValIdxPair_t( const IdxValPair_t& other ) : IdxValPair_t(other) { /* */ };
Bool_t operator< ( const Int_t& lhs, const IdxValPair_t& rhs ){ return lhs < rhs.idx; };
Bool_t operator< ( const Float_t& lhs, const ValIdxPair_t& rhs ){ return lhs < rhs.val; };

typedef std::vector< IdxValPair_t > IdxValPairVec_t;
typedef std::list< ValIdxPair_t > ValIdxPairList_t;



// the strip cluster finder classes itself
d290 1
d303 2
d403 1
a403 1
 * $Id: StEEmcStripClusterFinderANLS.cxx,v 1.2 2011/12/09 18:01:16 sgliske Exp $
d405 5
@


1.2
log
@finished creation
@
text
@d19 2
a20 2
#define DEBUG
#define DEBUG2
d22 2
a23 1

a42 3
   Int_t idx;
   Float_t val;

a45 1

d51 2
a52 2
ValIdxPair_t::ValIdxPair_t( const ValIdxPair_t& other ) : idx(other.idx), val(other.val) { /* */ };
ValIdxPair_t::ValIdxPair_t( const IdxValPair_t& other ) : idx(other.idx), val(other.val) { /* */ };
d64 1
a64 1
   mMinStripsToCluster( 5 ),
d72 1
a72 1
   mMergeThres( 0.8 )
d98 1
a98 1
   if( hitStrips.size() < static_cast< UInt_t >( mMinStripsToCluster ) )
d118 1
a118 1
         cout << "ccc " << iter->index() << ' ' << iter->energy() << endl;
d130 4
d136 2
a137 2
   Float_t *pLow = &mSmearedEnergyArray[startIdx-mSideWidth];
   Float_t *pHigh = &mSmearedEnergyArray[startIdx+mSideWidth];
d140 1
d142 6
a147 4
      if( pHigh < &mSmearedEnergyArray[kEEmcNumStrips] )
         (*pMid) += (*pHigh);
      if( pLow < &mSmearedEnergyArray[0] )
         (*pMid) -= (*pLow);
d151 12
d167 33
a199 18
   // now fill list and sort by energy
   seedList.assign( seedVec.begin(), seedVec.end() );
   seedList.sort();

   // remove those below the relative threshold
   Float_t relThres = mSeedRelThres * seedVec.front().val;
   if( relThres > mSeedEnergyThres )
      seedList.erase( seedList.begin(), std::upper_bound( seedList.begin(), seedList.end(), relThres ) );

   // set order to be descending
   seedList.reverse();

   // remove any that are too close (keeping higher energy one)
   ValIdxPairList_t::iterator listIter1, listIter2;
   for( listIter1 = seedList.begin(); listIter1 != seedList.end(); ++listIter1 )
      for( (listIter2 = listIter1)++; listIter2 != seedList.end(); ++listIter2 )
         if( listIter1 != listIter2 && abs( listIter1->idx - listIter2->idx) < mMinSeedDist )
            listIter2 = seedList.erase( listIter2 );
d202 1
a202 1
   LOG_INFO << "Sector " << mSector << " layer " << (mLayer?'v':'u') << " found " << seedList.size() << " seeds" << endl;
a204 1
   if( !seedList.empty() ){
a210 1
   };
a212 1
   if( !seedList.empty() ){
d230 1
a230 1
         clusters.push_back( StSimpleCluster_t( iseed ) );
d233 1
a233 1
         Float_t pos1, pos2;
d241 1
a241 1
         if( iseed == kEEmcNumStrips ){
d249 1
a249 1
         Int_t weightedMean = 0;
d251 1
a251 1
            if( mStripEnergyArray[idx] ){
d253 3
a255 2
               energy += mStripEnergyArray[idx];
               weightedMean = mStripEnergyArray[ idx ] * idx;
d274 4
d295 5
d305 4
a308 2
      std::list< Float_t > clusLocalDensity;
      std::list< Float_t > betweenDensity;
a309 5
      if( mDensityEstWidth < 1 )
         mDensityEstWidth = 1;

      // precompute values
      StSimpleClusterList_t::iterator clusIter, clusIter2;
d311 4
a314 2
         Int_t seedIdx = clusIter->getSeedMember();
         assert( seedIdx > -1 && seedIdx < kEEmcNumStrips );
d317 3
a319 4
         Float_t e = 0;
         for( Int_t i = std::max( 0, seedIdx - mDensityEstWidth ); i < std::min( kEEmcNumStrips, seedIdx + mDensityEstWidth ); ++i, ++n )
            e += mSmearedEnergyArray[i];

d321 1
a321 2
         e /= n;
         clusLocalDensity.push_back( e );
d323 4
d328 11
a338 2
            // go to the cluster right before
            --clusIter;
d340 4
a343 3
            // get second seed position (for cluster right before this one)
            Int_t seedIdx2 = clusIter2->getSeedMember();
            assert( seedIdx2 > -1 && seedIdx < kEEmcNumStrips );
d345 39
a383 2
            // move back to the correct cluster
            ++clusIter;
d385 9
a393 9
            // compute density between clusters
            e = 0.5*( mSmearedEnergyArray[seedIdx] + mSmearedEnergyArray[seedIdx2] );
            n = 1;
            for( Int_t i =  + 1; i < seedIdx; ++i, ++n )
               e += mSmearedEnergyArray[i];

            betweenDensity.push_back( e );
         };
      };
d395 11
a405 29
      Bool_t doContinue = 1;
      std::list< Float_t >::iterator clusLocalIter, betweenIter, clusLocalIterToDelete, betweenIterToDelete;
      StSimpleClusterList_t::iterator leftClusToMerge, rightClusToMerge, clusIterToDelete;

      while( doContinue && clusters.size() > 1 && !ierr ){
         // find smallest ratio of densities
         Float_t smallestRatio = 1e100;

         clusLocalIter = clusLocalDensity.begin();
         betweenIter = betweenDensity.begin();
         clusIter = clusters.begin();
         leftClusToMerge = clusters.end();

         Float_t lastClusDensity = *clusLocalIter;
         ++clusLocalIter;

         for( ; clusLocalIter != clusLocalDensity.end(); ++clusLocalIter, ++betweenIter, ++clusIter ){
            Float_t ratio = (*betweenIter) / std::min( *clusLocalIter, lastClusDensity );
            if( ratio < smallestRatio ){
               smallestRatio = ratio;

               leftClusToMerge = clusIter;
               ++(rightClusToMerge = clusIter);

               betweenIterToDelete = betweenIter;
               clusLocalIterToDelete = clusLocalIter;
               --clusLocalIterToDelete;
               if( rightClusToMerge->getEnergy() < leftClusToMerge->getEnergy() )
                  ++clusLocalIterToDelete;
d408 6
a413 14
         doContinue = 0;
         if( smallestRatio < mMergeThres ){
            doContinue = 1;

            // merge clusters
            *leftClusToMerge += *rightClusToMerge;

            // do not update lists, other than deleting this member
            // i.e. "between" properties are considered fixed.

            clusters.erase( clusIterToDelete );
            betweenDensity.erase( betweenIterToDelete );
            clusLocalDensity.erase( clusLocalIterToDelete );
         };
d415 1
d417 2
a418 2
      clustersOut.assign( clusters.begin(), clusters.end() );
   };
a419 1
   
d424 7
d437 1
a437 1
 * $Id: StEEmcStripClusterFinderANLS.cxx,v 1.1 2011/12/09 03:33:43 sgliske Exp $
d439 3
@


1.1
log
@creation
@
text
@d11 1
d23 7
d34 4
a37 2
   operator< ( const IdxValPair_t& rhs ){ return val < rhs.val; };
   static::IdxLessThan( const IdxValPair_t& rhs ){ return idx < rhs.idx; };
d40 19
d60 2
a61 1
typedef std::list< IdxValPair_t > IdxValPairList_t;
d63 4
a66 1
StEEmcStripClusterFinderANLS_t::StEEmcStripClusterFinderANLS_t :
d69 3
d74 2
a75 2
   mMinSeedDist( 3 ),
   mMinClusterEnergy( 0.01 )
d89 2
a90 2
Int_t StEEmcStripClusterFinderANLS_t::find( const StEEmcStripVec_t& hitStrips, StSimpleClusterVec_t& clusters ){
   clusters.clear();
d98 1
d105 1
a105 1
   for( Float_t *p1 = mSmearEnergyArray, *p2 = mStripEnergyArray; p1 != &mSmearEnergyArray[kEEmcNumStrips]; ++p1, ++p2 )
a107 2
   std::set

d109 1
a109 1
      Int_t smallestIdx = kEEmcNumStrips, largestIdx = -1;
d128 1
a128 1
   IdxValPairVec_t seedList;   // sorted by Energy
d136 1
a136 1
   Float_t *pHi = &mSmearedEnergyArray[startIdx+mSideWidth];
d152 1
a152 1
   seedList.assign( seedVecIdx.begin(), seedVecIdx.end() );
d156 1
a156 1
   Float_t relThres = mSeedRelThres * seedVecE.front();
d164 1
a164 1
   IdxValList_t::iterator listIter1, listIter2;
d177 1
a177 1
      IdxValList_t::iterator iter;
d180 1
a180 1
      }:
d188 2
a189 2
      seedVec.assign( seedVec.begin(), seedVec.end() );
      std::sort( seedVec.begin(), seedVec.end(), IdxVal_t::IdxLessThan );
a193 1
      clusters.reserve( nSeeds );
d199 1
a199 1
         Int_t seedIdx = seedVec[i];
d202 1
a202 1
         clusters.push_back( StSimpleCluster_t( i ) );
d205 14
a218 5
         Float_t pos1 = 0, pos2 = kEEmcNumStrips;
         if( iseed != 0 )
            pos1 = 0.5*(seedVec[iseed-1] + seedVec[iseed]) + 0.5;
         if( iseed != nSeeds-1 )
            pos2 = 0.5*(seedVec[iseed+1] + seedVec[iseed]) + 0.5;
d221 2
a222 1
         for( Int_t idx = pos1; idx < pos2; ++i ){
d234 2
a235 6
#ifdef DEBUG3
         LOG_INFO << "Energy " << energy << " vs " << mMinClusterEnergy << endm;
#endif
         if( energy > mMinClusterEnergy ){
            TArrayS& memArr = clus.getMemberArray();
            TArrayF& wArr = clus.getWeightArray();
d237 2
a238 2
            memArr.Set( n );
            wArr.Set( n );
d240 4
a243 2
            Int_t internalSeedIdx = 0;
            Int_t weightedMean = 0;
d245 2
a246 3
            for( Int_t i = 0; i < n; ++i ){
               Int_t idx = stripsPerClus.back();
               stripsPerClus.pop_back();
d248 3
a250 6
               memArr[i] = idx;
               wArr[i] = 1;

               if( idx == seedIdx )
                  internalSeedIdx = i;
            };
d252 3
a254 3
            clus.setMeanX( weightedMean );
            clus.setEnergy( energy );
            clus.setSeedIdx( internalSeedIdx );
d257 2
a258 2
            LOG_INFO << "Semi-final results: event " << getEventNum() << " sector/layer " << mSector << '/'
                     << (mLayer ? 'v' : 'u') << ' ' << clus << endm;
a259 3
         } else {
            clusters.pop_back();
         };
d266 97
a362 2
   if( clusters.size() > 1 && !ierr && mergeAlgoPtr )
      ierr = (*mergeAlgoPtr)( clusters );
d370 5
a374 2
 * $Id: $
 * $Log: $
@

