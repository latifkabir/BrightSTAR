head	1.14;
access;
symbols
	response:1.11;
locks; strict;
comment	@// @;


1.14
date	2012.11.26.19.40.33;	author sgliske;	state dead;
branches;
next	1.13;

1.13
date	2012.05.17.22.47.02;	author sgliske;	state Exp;
branches;
next	1.12;

1.12
date	2012.05.17.18.04.25;	author sgliske;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.07.22.08.04;	author sgliske;	state Exp;
branches;
next	1.10;

1.10
date	2011.08.09.20.36.09;	author sgliske;	state Exp;
branches;
next	1.9;

1.9
date	2011.07.28.22.04.59;	author sgliske;	state Exp;
branches;
next	1.8;

1.8
date	2011.07.22.16.33.06;	author sgliske;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.20.21.35.26;	author sgliske;	state Exp;
branches;
next	1.6;

1.6
date	2011.07.13.20.24.45;	author sgliske;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.12.21.48.44;	author sgliske;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.12.14.13.16;	author sgliske;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.11.15.14.31;	author sgliske;	state Exp;
branches;
next	1.2;

1.2
date	2011.07.07.20.53.04;	author sgliske;	state Exp;
branches;
next	1.1;

1.1
date	2011.07.05.21.48.19;	author sgliske;	state Exp;
branches;
next	;


desc
@@


1.14
log
@moved to official StEEmcPool
@
text
@/*!
 * \class StEEmcHitMaker_t
 * \author Stephen Gliske <sgliske@@anl.gov>
 *
 * See description in StEEmcHitMaker.h
 *
*/

/// Include the header
#include "StEEmcHitMaker.h"

/// Include StRoot classes
#include "StRoot/St_base/StMessMgr.h"
#include "StRoot/St_base/Stypes.h"
#include "StRoot/StEEmcPool/StEEmcTreeMaker/StEEmcTreeMaker.h"
#include "StRoot/StEEmcPool/StEEmcTreeMaker/StEEmcEnergyMaker.h"

const Int_t StEEmcHitMaker_t::kEEmcNumPhiBins = kEEmcNumSectors*kEEmcNumSubSectors;

/// Construtor
StEEmcHitMaker_t::StEEmcHitMaker_t( const Char_t *myName, const Char_t *inputMkrName )
   : StMaker( myName ),
     mInputMakerName( inputMkrName ),
     mDoClusterSMDStrips(0),
     mConstructedOK(1)  // default is OK -- child class should reset
{
   // default to doing nothing
   for( Int_t i = 0; i < NUM_TOW_LAYERS; ++i )
      mDoClusterTower[i] = 0;
};

/// deconstructor
StEEmcHitMaker_t::~StEEmcHitMaker_t(){
   // nothing to do
};

/// Initialize
Int_t StEEmcHitMaker_t::Init(){
   Int_t ierr = kStOK;

   // check if constructed OK
   if( !mConstructedOK ){
      LOG_FATAL << "StEEmcHitMaker had an error during construction phase.  Init() returning kStFatal." << endm;
      ierr = kStFatal;
   };

   TObject *inputMaker = GetMaker( mInputMakerName.data() );
   if( !inputMaker ){
      LOG_FATAL << "::Init() could not get pointer to a maker with name '" << mInputMakerName << "'" << endm;
      ierr = kStFatal;
   };

   if( !ierr && !inputMaker->InheritsFrom( "StEEmcTreeMaker_t" ) && !inputMaker->InheritsFrom( "StEEmcEnergyMaker_t" ) ){
      LOG_FATAL << "Input maker '" << mInputMakerName << "' does not inherit from "
                << "StEEmcTreeMaker_t nor StEEmcEnergyMaker_t" << endm;
      ierr = kStFatal;
   };

   return ierr;
};

/// need so that data is all loaded properly
Int_t StEEmcHitMaker_t::Make(){
   Int_t ierr = kStOk;

   TObject *inputMaker = GetMaker( mInputMakerName.data() );
   if( !inputMaker ){
      LOG_FATAL << "::Init() could not get pointer to a maker with name '" << mInputMakerName << "'" << endm;
      ierr = kStFatal;
   };

   mEEmcEnergy = 0;
   if( !ierr ){
      if( inputMaker->InheritsFrom( "StEEmcTreeMaker_t" ) ){
         StEEmcTreeMaker_t *treeMkr = static_cast< StEEmcTreeMaker_t* >( inputMaker );
         mEEmcEnergy = treeMkr->getEEmcEnergy();
      } else if ( inputMaker->InheritsFrom( "StEEmcEnergyMaker_t" ) ){
         StEEmcEnergyMaker_t *energyMkr = static_cast< StEEmcEnergyMaker_t* >( inputMaker );
         mEEmcEnergy = energyMkr->getEEmcEnergyPtr();
      } else {
         LOG_FATAL << "Input maker '" << mInputMakerName << "' does not inherit from "
                   << "StEEmcTreeMaker_t nor StEEmcEnergyMaker_t" << endm;
         ierr = kStFatal;
      };        

      if( !mEEmcEnergy ){
         LOG_ERROR << "Error getting EEmcEnergy_t pointer from '" << mInputMakerName << "'" << endm;
         ierr = kStErr;
      };
   };

   return ierr;
};

/// Clear for next event
void StEEmcHitMaker_t::Clear(Option_t *){
   clearData();
};

Bool_t StEEmcHitMaker_t::getIfClusteredTower( TowerLayer_t layer ) const{
   Bool_t didIt = 0;

   if( layer < NUM_TOW_LAYERS )
      didIt = mDoClusterTower[ layer ];

   return didIt;
};

Int_t StEEmcHitMaker_t::getNumSMDClusters(){
   Int_t n = 0;

   for( UInt_t i = 0; i<mESMDClusterVec.size(); ++i ){
      n += mESMDClusterVec[i].getClusterVecU().size();
      n += mESMDClusterVec[i].getClusterVecV().size();
   };

   return n;
};

ClassImp( StEEmcHitMaker_t );

/*
 * $Id: StEEmcHitMaker.cxx,v 1.13 2012/05/17 22:47:02 sgliske Exp $
 *
 * $Log: StEEmcHitMaker.cxx,v $
 * Revision 1.13  2012/05/17 22:47:02  sgliske
 * working on switching to EEmcTree containers
 *
 * Revision 1.12  2012/05/17 18:04:25  sgliske
 * Moving from EEmcResponse to EEmcTree
 *
 * Revision 1.11  2011/11/07 22:08:04  sgliske
 * daily update
 *
 * Revision 1.10  2011/08/09 20:36:09  sgliske
 * working on adding MC support to AnalysisTreeMaker
 *
 * Revision 1.9  2011/07/28 22:04:59  sgliske
 * update
 *
 * Revision 1.8  2011/07/22 16:33:06  sgliske
 * update
 *
 * Revision 1.7  2011/07/20 21:35:26  sgliske
 * update
 *
 * Revision 1.6  2011/07/13 20:24:45  sgliske
 * update
 *
 * Revision 1.5  2011/07/12 21:48:44  sgliske
 * working on implementing StEEmcResponse in other makers/classes
 *
 * Revision 1.4  2011/07/12 14:13:16  sgliske
 * update
 *
 * Revision 1.3  2011/07/11 15:14:31  sgliske
 * before making StHitData class
 *
 * Revision 1.2  2011/07/07 20:53:04  sgliske
 * update
 *
 * Revision 1.1  2011/07/05 21:48:19  sgliske
 * split from StEEmcAnalysisTreeMaker
 *
 * Revision 1.3  2011/07/01 21:44:24  sgliske
 * update
 *
 * Revision 1.2  2011/06/29 16:37:59  sgliske
 * update
 *
 * Revision 1.1  2011/06/23 21:55:05  sgliske
 * daily update
 *
 */
@


1.13
log
@working on switching to EEmcTree containers
@
text
@d123 1
a123 1
 * $Id: StEEmcHitMaker.cxx,v 1.12 2012/05/17 18:04:25 sgliske Exp $
d126 3
@


1.12
log
@Moving from EEmcResponse to EEmcTree
@
text
@d79 1
a79 1
         mEEmcEnergy = energyMkr->getEEmcEnergy();
d123 1
a123 1
 * $Id: StEEmcHitMaker.cxx,v 1.11 2011/11/07 22:08:04 sgliske Exp $
d126 3
@


1.11
log
@daily update
@
text
@d15 2
a16 7
#include "StRoot/StEEmcPool/StEEmcA2EMaker/StEEmcA2EMaker.h"
#include "StRoot/StEEmcPool/StEEmcA2EMaker/StEEmcTower.h"
#include "StRoot/StEEmcPool/StEEmcA2EMaker/StEEmcStrip.h"
#include "StRoot/StEEmcPool/StEEmcResponseTreeMaker/StTowerResponse.h"
#include "StRoot/StEEmcPool/StEEmcResponseTreeMaker/StStripResponse.h"
#include "StRoot/StEEmcPool/StEEmcResponseTreeMaker/StEEmcResponseMaker.h"
#include "StRoot/StEEmcPool/StEEmcResponseTreeMaker/StEEmcResponseTreeReader.h"
d21 1
a21 2
StEEmcHitMaker_t::StEEmcHitMaker_t( const Char_t *myName,             // name of this maker in the StMaker hash table
                                    const Char_t *responseMakerName )  // name of the maker in charge of setting the resonse
d23 1
a23 2
     mInputMakerName( responseMakerName ),
     mResponsePtr(0),
d25 1
a25 2
     mConstructedOK(0),
     mOwnHitElementPtrs(0)
a26 1
   // set pointers to zero and 
d28 1
a28 1
   for( Int_t i = 0; i < NUM_TOW_LAYERS; ++i ){
a29 12
      mHitTowerPtr[i] = 0;
   };

   for( Int_t i = 0; i < kEEmcNumSectors; ++i ){
      mHitUStripPtr[i] = 0;
      mHitVStripPtr[i] = 0;
   };

   // will set mConstructedOK here to flag constructed ok--though
   // child class will have to rethink if the child class is
   // constructed OK.
   mConstructedOK = 1;
d34 1
a34 14
   // delete vecs if needed
   DeleteHitElementVecs();
};

void StEEmcHitMaker_t::DeleteHitElementVecs(){
   if( mOwnHitElementPtrs ){
      for( Int_t i = 0; i<StEEmcResponse_t::NUM_TOW_LAYERS; ++i )
         delete mHitTowerPtr[i];

      for( Int_t i = 0; i<kEEmcNumSectors; ++i ){
         delete mHitUStripPtr[i];
         delete mHitVStripPtr[i];
      };
   };
d53 5
a57 63
   if( !ierr ){
      if( inputMaker->InheritsFrom( "StEEmcResponseTreeReader_t" ) ){

         // input is from a tree reader
         StEEmcResponseTreeReader_t *treeReaderPtr = static_cast< StEEmcResponseTreeReader_t* >( inputMaker );

         mResponsePtr = treeReaderPtr->getResponsePtr();
         if( !mResponsePtr ){
            LOG_FATAL << "::Init() could not get pointer to StEEmcResponse_t from maker '" << mInputMakerName << "'" << endm;
            ierr = kStFatal;
         };

         // need to allocate own vectors

         if( !ierr ){
            // delete just in case init called multiple times
            DeleteHitElementVecs();

            mOwnHitElementPtrs = 1;
            for( Int_t i = 0; i<StEEmcResponse_t::NUM_TOW_LAYERS; ++i )
               mHitTowerPtr[i] = new StEEmcTowerVec_t;

            for( Int_t i = 0; i<kEEmcNumSectors; ++i ){
               mHitUStripPtr[i] = new StEEmcStripVec_t;
               mHitVStripPtr[i] = new StEEmcStripVec_t;
            };
         };
      } else if( inputMaker->InheritsFrom( "StEEmcA2EMaker" ) ) {
         // input is from StEEmcA2EMaker
         StEEmcA2EMaker *a2EMakerPtr = static_cast< StEEmcA2EMaker* >( inputMaker );

         // delete just in case init called multiple times
         DeleteHitElementVecs();

         // flag that ptrs are not owned
         mOwnHitElementPtrs = 0;

         // get pointers to the vectors of towers
         if( mDoClusterTower[ TOWER ] )
            mHitTowerPtr[ TOWER ] = &( a2EMakerPtr->towers( TOWER ) );

         if( mDoClusterTower[ PRESHOWER1 ] )
            mHitTowerPtr[ PRESHOWER1 ] = &( a2EMakerPtr->towers( PRESHOWER1 ) );

         if( mDoClusterTower[ PRESHOWER2 ] )
            mHitTowerPtr[ PRESHOWER2 ] = &( a2EMakerPtr->towers( PRESHOWER2 ) );

         if( mDoClusterTower[ POSTSHOWER ] )
            mHitTowerPtr[ POSTSHOWER ] = &( a2EMakerPtr->towers( POSTSHOWER ) );

         // now for the SMD strips
         if( mDoClusterSMDStrips ){
            for( Int_t sector = 0; sector < kEEmcNumSectors; ++sector ){
               mHitUStripPtr[ sector ] = &( a2EMakerPtr->strips( sector, 0 ) );
               mHitVStripPtr[ sector ] = &( a2EMakerPtr->strips( sector, 1 ) );
            };
         };
      } else {
         LOG_FATAL << "Error maker with name '" << mInputMakerName << "' is a of type '" << inputMaker->ClassName()
                   << "', but does not inherit from 'StA2EMaker' nor 'StEEmcResponseTreeReader_t'" << endm;
         ierr = kStFatal;
      };
   }; // no err yet
d64 1
a64 2
   return convertResponseToVec();
};
d66 5
a70 5
/// Convert data from EEmcResponse into vectors of StEEmcStrips and
/// StEEmcTowers, so that the input looks like it came from the
/// StEEmcA2EMaker.
Int_t StEEmcHitMaker_t::convertResponseToVec(){
   Int_t ierr = kStOK;
d72 13
a84 23
   // Only need to do this if input is from a response, not an
   // A2EMaker class--can tell by checking the response pointer
   if( mResponsePtr ){
      StEEmcResponse_t::TowerLayer_t allLayers[4] = { StEEmcResponse_t::TOWER,
                                                      StEEmcResponse_t::PRESHOWER1,
                                                      StEEmcResponse_t::PRESHOWER2,
                                                      StEEmcResponse_t::POSTSHOWER };

      StEEmcTowerVec_t::iterator towIter;

      static EEmcGeomSimple geomSimple;

      for( Int_t i = 0; i < 4 && !ierr; ++i ){
         StEEmcResponse_t::TowerLayer_t &layer = allLayers[i];

         if( mDoClusterTower[ layer ] ){
            // references
            StEEmcTowerVec_t &towerVec = *mHitTowerPtr[ layer ];
            TClonesArray *towerArrPtr = mResponsePtr->getTowerArrayPtr( layer );

            ierr = towerArrPtr ? ConvertResponseArrayToTowerVec( *towerArrPtr, towerVec ) : kStErr;
         };
      };
d86 3
a88 35
      // now for the SMD strips
      Int_t nSMD = 0;
      Int_t nUperSector[ kEEmcNumSectors ], nVperSector[ kEEmcNumSectors ];
      if( mDoClusterSMDStrips && !ierr ){
         TClonesArray &smdArr = (*mResponsePtr->getSMDArrayPtr());
         nSMD = smdArr.GetEntriesFast();

         // clear size array
         for( Int_t *p1 = nUperSector, *p2 = nVperSector; p1 != &nUperSector[kEEmcNumSectors]; ++p1, ++p2 ){
            (*p1) = 0;
            (*p2) = 0;
         };

         // predetermine size
         for( Int_t i = 0; i<nSMD; ++i ){
            StStripResponse_t* stripRespPtr = static_cast< StStripResponse_t* >( smdArr[i] );
            ++( stripRespPtr->getPlane() ? nVperSector[ stripRespPtr->getSector() ] : nUperSector[ stripRespPtr->getSector()] );
         };

         // set sizes
         for( Int_t sector = 0; sector < kEEmcNumSectors; ++sector ){
            mHitUStripPtr[sector]->reserve( nUperSector[ sector ] );
            mHitVStripPtr[sector]->reserve( nVperSector[ sector ] );
            //LOG_INFO << "Number of strips in sector " << sector << ": " << nUperSector[ sector ] << ", " << nVperSector[ sector ] << endm;
         };

         // now make the copies
         for( Int_t i = 0; i<nSMD; ++i ){
            // get pointers/references
            StStripResponse_t* stripRespPtr = static_cast< StStripResponse_t* >( smdArr[i] );
            StEEmcStripVec_t &stripVec = *( stripRespPtr->getPlane() ? mHitVStripPtr : mHitUStripPtr )[ stripRespPtr->getSector() ];

            stripVec.push_back( StEEmcStrip() );
            stripRespPtr->copyToEEmcStrip( stripVec.back() );
         };
a89 2

      //LOG_INFO << "-----> Converted " << mHitTowerPtr[ TOWER ]->size() << " towers" << endm;
a96 10
   if( mOwnHitElementPtrs ){
      for( Int_t i = 0; i<StEEmcResponse_t::NUM_TOW_LAYERS; ++i )
         mHitTowerPtr[i]->clear();

      for( Int_t i = 0; i<kEEmcNumSectors; ++i ){
         mHitUStripPtr[i]->clear();
         mHitVStripPtr[i]->clear();
      };
   };

a119 13
const StEEmcTower* StEEmcHitMaker_t::getTowerPtr( TowerLayer_t layer, UInt_t index ) const{

   const StEEmcTower *hitTowPtr = 0;

   const StEEmcTowerVec_t *hitTowVec = mHitTowerPtr[ layer ];
   StEEmcTowerVec_t::const_iterator hitTowIter = hitTowVec->begin();
   for( ; hitTowIter != hitTowVec->end() && !hitTowPtr; ++hitTowIter )
      if( (UInt_t)hitTowIter->index() == index )
         hitTowPtr = &(*hitTowIter);

   return hitTowPtr;
};

d123 1
a123 1
 * $Id: StEEmcHitMaker.cxx,v 1.10 2011/08/09 20:36:09 sgliske Exp $
d126 3
@


1.10
log
@working on adding MC support to AnalysisTreeMaker
@
text
@d154 4
d205 1
a205 1
            ++( stripRespPtr->getPlane() ? nVperSector[ stripRespPtr->getSector() ] : nVperSector[ stripRespPtr->getSector()] );
d212 1
d283 1
a283 1
 * $Id: StEEmcHitMaker.cxx,v 1.9 2011/07/28 22:04:59 sgliske Exp $
d286 3
@


1.9
log
@update
@
text
@d5 1
a5 1
 * See description in StEEmcHitMaker_t.h
d27 1
a27 2
                                    const Char_t *responseMakerName,  // name of the maker in charge of setting the resonse
                                    InputType_t inputType )           // whether the response maker is a "response maker" or from the "tree reader"
a29 1
     mInputType( inputType ),
a53 1
/// placed it here to help with linking issues
d81 6
d88 2
a89 2
      // get pointer to the input data
      if( mInputType == RESPONSE_TREE_READER ){
d91 1
a91 1
         StEEmcResponseTreeReader_t *treeReaderPtr = static_cast< StEEmcResponseTreeReader_t* >( GetMaker( mInputMakerName.data() ) );
d93 3
a95 2
         if( !treeReaderPtr ){
            LOG_FATAL << "::Init() could not get pointer to StEEmcResponseTreeReader_t with name '" << mInputMakerName << "'" << endm;
a96 6
         } else {
            mResponsePtr = treeReaderPtr->getResponsePtr();
            if( !mResponsePtr ){
               LOG_FATAL << "::Init() could not get pointer to StEEmcResponse_t from maker '" << mInputMakerName << "'" << endm;
               ierr = kStFatal;
            };
d101 3
a103 2
         // delete just in case init called multiple times
         DeleteHitElementVecs();
d105 8
a112 7
         mOwnHitElementPtrs = 1;
         for( Int_t i = 0; i<StEEmcResponse_t::NUM_TOW_LAYERS; ++i )
            mHitTowerPtr[i] = new StEEmcTowerVec_t;

         for( Int_t i = 0; i<kEEmcNumSectors; ++i ){
            mHitUStripPtr[i] = new StEEmcStripVec_t;
            mHitVStripPtr[i] = new StEEmcStripVec_t;
d114 1
a114 2

      } else {
d116 1
a116 1
         StEEmcA2EMaker *a2EMakerPtr = static_cast< StEEmcA2EMaker* >( GetMaker( mInputMakerName.data() ) );
d118 2
a119 4
         if( !a2EMakerPtr ){
            LOG_FATAL << "::Init() could not get pointer to StEEmcA2EMaker with name '" << mInputMakerName << "'" << endm;
            ierr = kStFatal;
         } else {
d121 2
a122 5
            // delete just in case init called multiple times
            DeleteHitElementVecs();

            // flag that ptrs are not owned
            mOwnHitElementPtrs = 0;
d124 18
a141 19
            // get pointers to the vectors of towers
            if( mDoClusterTower[ TOWER ] )
               mHitTowerPtr[ TOWER ] = &( a2EMakerPtr->towers( TOWER ) );

            if( mDoClusterTower[ PRESHOWER1 ] )
               mHitTowerPtr[ PRESHOWER1 ] = &( a2EMakerPtr->towers( PRESHOWER1 ) );

            if( mDoClusterTower[ PRESHOWER2 ] )
               mHitTowerPtr[ PRESHOWER2 ] = &( a2EMakerPtr->towers( PRESHOWER2 ) );

            if( mDoClusterTower[ POSTSHOWER ] )
               mHitTowerPtr[ POSTSHOWER ] = &( a2EMakerPtr->towers( POSTSHOWER ) );

            // now for the SMD strips
            if( mDoClusterSMDStrips ){
               for( Int_t sector = 0; sector < kEEmcNumSectors; ++sector ){
                  mHitUStripPtr[ sector ] = &( a2EMakerPtr->strips( sector, 0 ) );
                  mHitVStripPtr[ sector ] = &( a2EMakerPtr->strips( sector, 1 ) );
               };
d144 5
a148 2

      }; // type of input
a158 10

   StEEmcResponse_t::TowerLayer_t allLayers[4] = { StEEmcResponse_t::TOWER,
                                                   StEEmcResponse_t::PRESHOWER1,
                                                   StEEmcResponse_t::PRESHOWER2,
                                                   StEEmcResponse_t::POSTSHOWER };

   StEEmcTowerVec_t::iterator towIter;

   static EEmcGeomSimple geomSimple;

d161 19
a179 2
   for( Int_t i = 0; i < 4 && !ierr; ++i ){
      StEEmcResponse_t::TowerLayer_t &layer = allLayers[i];
d181 2
a182 6
      if( mDoClusterTower[ layer ] ){
         // references
         StEEmcTowerVec_t &towerVec = *mHitTowerPtr[ layer ];
         TClonesArray *towerArrPtr = mResponsePtr->getTowerArrayPtr( layer );

         ierr = towerArrPtr ? ConvertResponseArrayToTowerVec( *towerArrPtr, towerVec ) : kStErr;
a183 1
   };
d185 12
a196 12
   // now for the SMD strips
   Int_t nSMD = 0;
   Int_t nUperSector[ kEEmcNumSectors ], nVperSector[ kEEmcNumSectors ];
   if( mDoClusterSMDStrips && !ierr ){
      TClonesArray &smdArr = (*mResponsePtr->getSMDArrayPtr());
      nSMD = smdArr.GetEntriesFast();

      // clear size array
      for( Int_t *p1 = nUperSector, *p2 = nVperSector; p1 != &nUperSector[kEEmcNumSectors]; ++p1, ++p2 ){
         (*p1) = 0;
         (*p2) = 0;
      };
d198 5
a202 5
      // predetermine size
      for( Int_t i = 0; i<nSMD; ++i ){
         StStripResponse_t* stripRespPtr = static_cast< StStripResponse_t* >( smdArr[i] );
         ++( stripRespPtr->getPlane() ? nVperSector[ stripRespPtr->getSector() ] : nVperSector[ stripRespPtr->getSector()] );
      };
d204 5
a208 5
      // set sizes
      for( Int_t sector = 0; sector < kEEmcNumSectors; ++sector ){
         mHitUStripPtr[sector]->reserve( nUperSector[ sector ] );
         mHitVStripPtr[sector]->reserve( nVperSector[ sector ] );
      };
d210 5
a214 5
      // now make the copies
      for( Int_t i = 0; i<nSMD; ++i ){
         // get pointers/references
         StStripResponse_t* stripRespPtr = static_cast< StStripResponse_t* >( smdArr[i] );
         StEEmcStripVec_t &stripVec = *( stripRespPtr->getPlane() ? mHitVStripPtr : mHitUStripPtr )[ stripRespPtr->getSector() ];
d216 3
a218 2
         stripVec.push_back( StEEmcStrip() );
         stripRespPtr->copyToEEmcStrip( stripVec.back() );
d220 2
a223 2
   //LOG_INFO << "-----> Converted " << mHitTowerPtr[ TOWER ]->size() << " towers" << endm;

d278 1
a278 1
 * $Id: StEEmcHitMaker.cxx,v 1.8 2011/07/22 16:33:06 sgliske Exp $
d281 3
@


1.8
log
@update
@
text
@a168 2
   std::map< Int_t, StEEmcTower* > towMap;
   std::map< Int_t, StEEmcTower* >::iterator towMapIter;
d171 2
d183 3
a185 64
         Int_t nTow = towerArrPtr->GetEntriesFast();

         towerVec.clear();
         towerVec.reserve( nTow );

         // loop over events.
         for( Int_t j=0; j<nTow; ++j ){
            towerVec.push_back( StEEmcTower() );
            static_cast< StTowerResponse_t* >( towerArrPtr->At(j) )->copyToEEmcTower( towerVec.back() );
         };

         // now fix neighbors

         // make a map
         towMap.clear();
         for( towIter = towerVec.begin(); towIter != towerVec.end(); ++towIter )
            towMap[ (*towIter).index() ] = &(*towIter);

         // iterate over towers
         for( towIter = towerVec.begin(); towIter != towerVec.end() && !ierr; ++towIter ){
            StEEmcTower &tower = (*towIter);

            // sanity check
            if( tower.numberOfNeighbors() ){
               LOG_FATAL << "tower did not clear list of neighbors" << endm;
               ierr = kStFatal;
            };

            if( !ierr ){
               // determine neighboring phi bins
               Int_t phiBinLow = tower.phibin() - 1;
               Int_t phiBinHigh = tower.phibin() + 1;

               if( phiBinLow < 0 )
                  phiBinLow += kEEmcNumPhiBins;
               if( phiBinHigh > kEEmcNumPhiBins )
                  phiBinHigh -= kEEmcNumPhiBins;

               Int_t phiBins[3] = { phiBinLow, tower.phibin(), phiBinHigh };
               Int_t etaBins[3];
               Int_t nNeighborEtaBins = 1;
               etaBins[0] = tower.etabin();

               if( tower.etabin() )
                  etaBins[nNeighborEtaBins++] = tower.etabin() - 1;

               if( tower.etabin() + 1 < kEEmcNumEtas )
                  etaBins[nNeighborEtaBins++] = tower.etabin() + 1;

               // add neighbors just lower in eta
               for( Int_t j = 0; j<nNeighborEtaBins; ++j ){
                  for( Int_t k = 0; k<3; ++k ){
                     Int_t neighborIdx = phiBins[k]*kEEmcNumEtas + etaBins[j];

                     towMapIter = towMap.find( neighborIdx );
                     if( towMapIter != towMap.end() )
                        tower.neighbor( towMapIter->second );
                  }; 
               };

            }; // no err yet
         }; // iterating over towers to fix neighbors
      }; // clustering this layer
   }; // iterating over layers
d279 1
a279 1
 * $Id: StEEmcHitMaker.cxx,v 1.7 2011/07/20 21:35:26 sgliske Exp $
d282 3
@


1.7
log
@update
@
text
@d284 1
a284 1
   LOG_INFO << "-----> Converted " << mHitTowerPtr[ TOWER ]->size() << " towers" << endm;
d300 2
d340 1
a340 1
 * $Id: StEEmcHitMaker.cxx,v 1.6 2011/07/13 20:24:45 sgliske Exp $
d343 3
@


1.6
log
@update
@
text
@d322 13
d338 1
a338 1
 * $Id: StEEmcHitMaker.cxx,v 1.5 2011/07/12 21:48:44 sgliske Exp $
d341 3
@


1.5
log
@working on implementing StEEmcResponse in other makers/classes
@
text
@d17 7
d30 1
a30 1
     mResponseMakerName( responseMakerName ),
d32 1
d35 1
a35 1
     mResponsePtr(0)
d39 1
a39 1
   for( Int_t i = 0; i < NUM_TOW_LAYERS; ++i )
d41 7
d58 14
a71 1
   // nothing needs to be done here
d78 1
a78 1
   // nothing to init here, except need to check if constructed OK
d88 1
a88 1
         StEEmcResponseTreeReader_t *treeReaderPtr = static_cast< StEEmcResponseTreeReader_t* >( GetMaker( mResponseMakerName.data() ) );
d91 1
a91 1
            LOG_FATAL << "::Init() could not get pointer to StEEmcResponseTreeReader_t with name '" << mResponseMakerName << "'" << endm;
d96 1
a96 1
               LOG_FATAL << "::Init() could not get pointer to StEEmcResponse_t from maker '" << mResponseMakerName << "'" << endm;
d100 15
d116 2
a117 2
         // input is from a response maker
         StEEmcResponseMaker_t *treeMakerPtr = static_cast< StEEmcResponseMaker_t* >( GetMaker( mResponseMakerName.data() ) );
d119 2
a120 2
         if( !treeMakerPtr ){
            LOG_FATAL << "::Init() could not get pointer to StEEmcResponseMaker_t with name '" << mResponseMakerName << "'" << endm;
d123 26
a148 4
            mResponsePtr = treeMakerPtr->getEEmcResponsePtr();
            if( !mResponsePtr ){
               LOG_FATAL << "::Init() could not get pointer to StEEmcResponse_t from maker '" << mResponseMakerName << "'" << endm;
               ierr = kStFatal;
d151 3
a153 2
      };
   };
d168 8
a175 1
   for( Int_t i = 0; i < 4; ++i ){
d180 1
a180 1
         StEEmcTowerVec_t &towerVec = mHitTowerPtr[ layer ];
d183 1
a183 1
         Int_t nTow = towerArrPtr->GetSizeFast();
d188 71
a258 3
         // loop over events.  Use implicit conversion
         for( Int j=0; j<nTow; ++j )
            towerVec.push_back( towerArrayPtr->At(j) );
a259 1
   };
a260 3
   // now for the SMD strips
   Int_t nU = 0, nV = 0;
   if( mDoClusterSMDStrips ){
d262 4
a265 1
      /* ************ TODO: START WRITING FROM HERE ******** */
d267 1
d269 3
a271 2
         mHitUStripPtr[ sector ] = &( mA2EMakerPtr->strips( sector, 0 ) );
         nU += mHitUStripPtr[ sector ]->size();
d273 5
a277 2
         mHitVStripPtr[ sector ] = &( mA2EMakerPtr->strips( sector, 1 ) );
         nV += mHitVStripPtr[ sector ]->size();
d279 2
d284 3
a286 1
   return 1000000*nU + 1000*nV + mHitTowerPtr[ TOWER ]->size();
d291 8
a298 6
   for( Int_t i=0; i<NUM_TOW_LAYERS; ++i )
      mHitTowerPtr[i].clear();

   for( Int_t i=0; i<kEEmcNumSectors; ++i ){
      mHitUStripPtr[i].clear();
      mHitVStripPtr[i].clear();
d325 1
a325 1
 * $Id: StEEmcHitMaker.cxx,v 1.4 2011/07/12 14:13:16 sgliske Exp $
d328 3
@


1.4
log
@update
@
text
@d19 10
a28 10
StEEmcHitMaker_t::StEEmcHitMaker_t( const Char_t *name, StEEmcA2EMaker* mA2EMakerPtr_in ) : StMaker( name ),
                                                                                            mA2EMakerPtr(mA2EMakerPtr_in),
                                                                                            mDoClusterSMDStrips(0),
                                                                                            mConstructedOK(0) {
   if( !mA2EMakerPtr ){
      LOG_FATAL << "StEEmcHitMaker_t passed null pointer for A2EMaker" << endm;
      // let the child process take care of passing on the fatal problem
      // for now, continue to zero the pointers
   };

d31 1
a31 1
   for( Int_t i = 0; i < NUM_TOW_LAYERS; ++i ){
a32 7
      mHitTowerPtr[i] = 0;
   };

   for( Int_t i = 0; i < kEEmcNumSectors; ++i ){
      mHitUStripPtr[i] = 0;
      mHitVStripPtr[i] = 0;
   };
d41 1
a41 1
/// place it here to help with linking issues
d46 3
d50 38
a87 12
/// Load data from A2E Maker for a given layer of the EEmc. When using
/// A2E, really just set the pointers.  Member function may be
/// overwritten in a child class to load data from a file
Int_t StEEmcHitMaker_t::load(){
   if( !mA2EMakerPtr ){
      LOG_FATAL << "::Load() died--mA2EMakerPtr is zero" << endm;
      return kStFatal;
   };

   // get pointers to the vectors of towers
   if( mDoClusterTower[ TOWER ] )
      mHitTowerPtr[ TOWER ] = &( mA2EMakerPtr->towers( TOWER ) );
d89 2
a90 2
   if( mDoClusterTower[ PRESHOWER1 ] )
      mHitTowerPtr[ PRESHOWER1 ] = &( mA2EMakerPtr->towers( PRESHOWER1 ) );
a91 2
   if( mDoClusterTower[ PRESHOWER2 ] )
      mHitTowerPtr[ PRESHOWER2 ] = &( mA2EMakerPtr->towers( PRESHOWER2 ) );
d93 27
a119 2
   if( mDoClusterTower[ POSTSHOWER ] )
      mHitTowerPtr[ POSTSHOWER ] = &( mA2EMakerPtr->towers( POSTSHOWER ) );
d124 3
d140 4
d145 3
a147 8
/// Initialize
Int_t StEEmcHitMaker_t::Init(){
   Int_t ierr = kStOK;

   // nothing to init here, except need to check if constructed OK
   if( !mConstructedOK ){
      LOG_FATAL << "StEEmcHitMaker had an error during construction phase.  Init() returning kStFatal." << endm;
      ierr = kStFatal;
a148 15

   return ierr;
};

/// Find all the hits
Int_t StEEmcHitMaker_t::Make(){
   LOG_WARN << "SANITY CHECK FAILURE: StEEmcHitMaker_t::Make() has been called for no reason." << endm;
   LOG_WARN << "\tOne should rather only call the child class implementations of Make()." << endm;
   return kStOK;
};

/// Clear for next event
void StEEmcHitMaker_t::Clear(Option_t *){
   LOG_WARN << "SANITY CHECK FAILURE: StEEmcHitMaker_t::Clear() has been called for no reason." << endm;
   LOG_WARN << "\tOne should rather only call the child class implementations of Clear()." << endm;
d174 1
a174 1
 * $Id: StEEmcHitMaker.cxx,v 1.3 2011/07/11 15:14:31 sgliske Exp $
d177 3
@


1.3
log
@before making StHitData class
@
text
@d10 1
a10 1
#include "StEEmcHitMakerSimple.h"
a17 3
/// Include related classes
#include "StEEmcHitMaker.h"

a91 44
// /// input is sector, plane
// /// output is index
// Int_t StEEmcHitMaker_t::convertSMDSectorPlane2Index( Int_t sector, Int_t plane ) {
//   return kEEmcNumSmdUVs*sector + plane;
// };
//
// /// input is index
// /// output is sector, plane
// void StEEmcHitMaker_t::convertSMDIndex2SectorPlane( const Int_t idx, Int_t &sector, Int_t &plane ) {
//    sector = idx / kEEmcNumSmdUVs;
//    plane = idx % kEEmcNumSmdUVs;
// };

/// get reference to clusers from a given layer
StSimpleClusterVec_t& StEEmcHitMaker_t::getTowerClusterVec( TowerLayer_t layer ) {
   if( layer > NUM_TOW_LAYERS ){
      LOG_FATAL << "StEEmcHitMaker_t::getTowerClusterVec( TowerLayer_t layer ) given invalid layer: " << layer << endm;
      return mTowerClusterVec[ 0 ];
   };
   return mTowerClusterVec[ layer ];
};

// /// get SMD strip clusters from a given sector and UV plane
// /// plane 0 is U, anything else is V
// const StSimpleClusterVec_t& StEEmcHitMaker_t::getStripClusterVec( Int_t sector, Bool_t getVplane ) const {
//    int ierr = kStOK;
//    if( sector > kEEmcNumSectors ){
//       LOG_FATAL << "StEEmcHitMaker_t::getStripClusterVec( Int_t sector, Int_t plane ) given invalid sector: " << sector << endm;
//       ierr = kStFatal;
//    };
//    Int_t idx = ierr ? 0 : convertSMDSectorPlane2Index( sector, !getVplane );
//    return mStripClusterVec[ idx ];
// };
//
// /// get SMD strip clusters from a given sector and UV plane, given the index
// const StSimpleClusterVec_t& StEEmcHitMaker_t::getStripClusterVec( Int_t idx ) const {
//    if( idx >= kNumEEmcStripVecs ){
//       LOG_FATAL << "StEEmcHitMaker_t::getStripClusterVec( Int_t idx ) given invalid index: " << idx << endm;
//       idx = 0;
//    };
//    return mStripClusterVec[ idx ];
// };


d128 2
d131 7
d142 1
a142 1
 * $Id: StEEmcHitMaker.cxx,v 1.2 2011/07/07 20:53:04 sgliske Exp $
d145 3
@


1.2
log
@update
@
text
@d62 1
a62 1
      LOG_FATAL << "StEEmcHitMaker_t::Load() died--mA2EMakerPtr is zero" << endm;
d80 1
d84 2
d87 2
d92 1
a92 1
   return kStOK;
d180 1
a180 1
 * $Id: StEEmcHitMaker.cxx,v 1.1 2011/07/05 21:48:19 sgliske Exp $
d183 3
@


1.1
log
@split from StEEmcAnalysisTreeMaker
@
text
@d39 4
a42 2
   for( Int_t i = 0; i < kNumEEmcStripVecs; ++i )
      mHitStripPtr[i] = 0;
a79 1
   StEEmcStripVec_t **mHitStripPtrPtr = &mHitStripPtr[0];
d81 4
a84 3
      for( Int_t sector = 0; sector < kEEmcNumSectors; ++sector )
         for( Int_t plane = 0; plane < kEEmcNumSmdUVs; ++plane, ++mHitStripPtrPtr )
            (*mHitStripPtrPtr) = &( mA2EMakerPtr->strips( sector, plane ) );
d90 12
a101 12
/// input is sector, plane
/// output is index
Int_t StEEmcHitMaker_t::convertSMDSectorPlane2Index( Int_t sector, Int_t plane ) {
  return kEEmcNumSmdUVs*sector + plane;
};

/// input is index
/// output is sector, plane
void StEEmcHitMaker_t::convertSMDIndex2SectorPlane( const Int_t idx, Int_t &sector, Int_t &plane ) {
   sector = idx / kEEmcNumSmdUVs;
   plane = idx % kEEmcNumSmdUVs;
};
d104 1
a104 1
const StSimpleClusterVec_t& StEEmcHitMaker_t::getTowerClusterVec( TowerLayer_t layer ) const {
d112 20
a131 24
/// get SMD strip clusters from a given sector and UV plane
/// plane 0 is U, anything else is V
const StSimpleClusterVec_t& StEEmcHitMaker_t::getStripClusterVec( Int_t sector, Bool_t getVplane ) const {
   int ierr = kStOK;

   if( sector > kEEmcNumSectors ){
      LOG_FATAL << "StEEmcHitMaker_t::getStripClusterVec( Int_t sector, Int_t plane ) given invalid sector: " << sector << endm;
      ierr = kStFatal;
   };

   Int_t idx = ierr ? 0 : convertSMDSectorPlane2Index( sector, !getVplane );

   return mStripClusterVec[ idx ];
};

/// get SMD strip clusters from a given sector and UV plane, given the index
const StSimpleClusterVec_t& StEEmcHitMaker_t::getStripClusterVec( Int_t idx ) const {
   if( idx >= kNumEEmcStripVecs ){
      LOG_FATAL << "StEEmcHitMaker_t::getStripClusterVec( Int_t idx ) given invalid index: " << idx << endm;
      idx = 0;
   };

   return mStripClusterVec[ idx ];
};
d156 1
a156 1
void  StEEmcHitMaker_t::Clear(Option_t *){
d161 10
d175 1
a175 1
 * $Id: StEEmcHitMaker.cxx,v 1.3 2011/07/01 21:44:24 sgliske Exp $
d178 3
@

