head	1.5;
access;
symbols
	response:1.4;
locks; strict;
comment	@// @;


1.5
date	2012.10.09.03.57.21;	author sgliske;	state dead;
branches;
next	1.4;

1.4
date	2012.01.02.17.14.42;	author sgliske;	state Exp;
branches;
next	1.3;

1.3
date	2011.12.28.15.07.57;	author sgliske;	state Exp;
branches;
next	1.2;

1.2
date	2011.12.28.14.54.22;	author sgliske;	state Exp;
branches;
next	1.1;

1.1
date	2011.12.22.23.00.53;	author sgliske;	state Exp;
branches;
next	;


desc
@@


1.5
log
@removed unused makers
@
text
@/*!
 * \class StEEmcStripClusterFinderTSG_t
 * \author Stephen Gliske <sgliske@@anl.gov>
 *
 * See header for description.
 *
*/

#include <list>
#include <TMath.h>

#include "StRoot/St_base/StMessMgr.h"
#include "StRoot/St_base/Stypes.h"

#include "StEEmcStripClusterFinderTSG.h"
#include "StRoot/StEEmcPool/StEEmcHitMaker/GmmEm1D/GmmEm1D.h"


//#define DEBUG
//#define DEBUG2

StEEmcStripClusterFinderTSG_t::StEEmcStripClusterFinderTSG_t( Int_t numEmIters ) : StEEmcStripClusterFinderTSP_t(),
                                                                                   mForcedInitSigmaSq(-1),
                                                                                   mInitSigmaFactor(0.5),
                                                                                   mMinimumAmpFrac(0.1),
                                                                                   mMergeDist(5),
                                                                                   mMinStripWeight(1e-2),
                                                                                   mMinSigmaSq(0.25),
                                                                                   mMaxSigmaSq(100),
                                                                                   mMaxStripSigmaDist(3)
{
   // ensure the GMM EM class is ready
   mGmmEm.setMaxIters( numEmIters );

   // initialize a few parent variables
   mLayer = U_LAYER;
   mSector = 0;
   mIsReady = 1;
};

StEEmcStripClusterFinderTSG_t::~StEEmcStripClusterFinderTSG_t(){
   // nothing else
};

/// find some clusters
Int_t StEEmcStripClusterFinderTSG_t::find( const StEEmcStripVec_t& hitStrips, StSimpleClusterVec_t& clustersOut ){
   // clear output
   clustersOut.clear();


   if( mMinimumAmpFrac < 0 )
      mMinimumAmpFrac = 0;
   if( mMinSigmaSq < 0 )
      mMinSigmaSq = 0;

   Int_t ierr = kStOk;

   // skip if not enough strips hit
   if( hitStrips.size() < static_cast< UInt_t >( mMinStripsPerCluster ) )
      return ierr;

   // make temporary vector of clusters
   StSimpleClusterVec_t initClusters;
   StSimpleClusterVec_t::iterator clusIter;

   ierr = StEEmcStripClusterFinderTSP_t::find( hitStrips, initClusters );

   // exit now if need be
   if( initClusters.empty() )
      return ierr;

   // copy smoothed data into GmmEm input structure
   GmmEmDataVec_t gmmEmData;

   Int_t iStart = mSmallestIdx - mSearchMargin;  // just a little margin to be safe
   Int_t iEnd = mLargestIdx + mSearchMargin;
   if( iStart < 0 )
      iStart = 0;
   if( iEnd > kEEmcNumStrips-1 )
      iEnd = kEEmcNumStrips-1;

   Int_t idx = iStart;
   for( Double_t *p = &mSmoothedEnergyArrayB[iStart]; p != &mSmoothedEnergyArrayB[iEnd]; ++p, ++idx )
      if( *p )
         gmmEmData.push_back( GmmEmDataElement_t( idx, *p ) );


   // initialize the clusters
   GmmEmGausParamVec_t gmmClusters;
   GmmEmGausParamVec_t::iterator gmmClusIter;
   gmmClusters.reserve( initClusters.size() );
   for( clusIter = initClusters.begin(); clusIter != initClusters.end(); ++clusIter ){
      gmmClusters.push_back( GausParam_t( clusIter->getEnergy(), clusIter->getMeanX(), clusIter->getMeanY() ) );

      if( mForcedInitSigmaSq > 0 )
         gmmClusters.back().sigmaSq = mForcedInitSigmaSq;
   };

#ifdef DEBUG
   LOG_INFO << "GMM Init: " << endm;
   for( gmmClusIter = gmmClusters.begin(); gmmClusIter != gmmClusters.end(); ++gmmClusIter ){
      LOG_INFO << "\t" << gmmClusIter->A << ' ' << gmmClusIter->mean << ' ' << sqrt( gmmClusIter->sigmaSq ) << endm;
   };
#endif

   UInt_t sizeBefore = 0;
   UInt_t sizeAfter = 1;

   // some iterators
   WeightVec_t::const_iterator weightIter;
   GmmEmDataVec_t::const_iterator dataVecIter;

   // to keep track of number of strips per cluster
   std::vector< UInt_t > nStripsPerClus;

   while( sizeAfter != sizeBefore && sizeAfter > 0 && !ierr ){

      // solve the GMM
      Int_t gmmErrCode = mGmmEm.solve( gmmEmData, gmmClusters );
      if( gmmErrCode ){
         LOG_WARN << "GMM EM Algo had an error: '" << mGmmEm.getMessage() << "'" << endm;
         ierr = kStErr;
      };

      if( !ierr ){
         sizeBefore = gmmClusters.size();

#ifdef DEBUG2
         LOG_INFO << "GMM raw results for " << sizeBefore << " clusters: " << endm;
         for( gmmClusIter = gmmClusters.begin(); gmmClusIter != gmmClusters.end(); ++gmmClusIter ){
            LOG_INFO << "\t" << gmmClusIter->A << ' ' << gmmClusIter->mean << ' ' << sqrt( gmmClusIter->sigmaSq ) << endm;
         };
#endif

         // remove clusters that are too close
         GmmEmGausParamVec_t::iterator gmmClusIter2;
         for( gmmClusIter = gmmClusters.begin(); gmmClusIter != gmmClusters.end(); ++gmmClusIter )
            for( gmmClusIter2 = gmmClusters.begin(); gmmClusIter2 != gmmClusIter; ++gmmClusIter2 )
               if( fabs( gmmClusIter2->mean - gmmClusIter->mean ) < mMergeDist )
                  (gmmClusIter->A > gmmClusIter2->A ? gmmClusIter2->sigmaSq : gmmClusIter->sigmaSq ) = 0;

         // compute number of strips per cluster
         nStripsPerClus.assign( sizeBefore, 0 );
         const WeightVec_t& weightVec = mGmmEm.getWeights();
         weightIter = weightVec.begin();
         dataVecIter = gmmEmData.begin();
         for( ; weightIter != weightVec.end(); ++weightIter, ++dataVecIter )
            for( UInt_t i=0; i < sizeBefore; ++i )
               if( (*weightIter)[i] > mMinStripWeight && mStripEnergyArray[ dataVecIter->idx ] > 0 &&
                   fabs( gmmClusters[i].mean - dataVecIter->idx )/sqrt( gmmClusters[i].sigmaSq ) < mMaxStripSigmaDist )
                  ++(nStripsPerClus[i]);

         // max amplitude
         Float_t maxAmp = gmmClusters.front().A;

         // invalidate those not meeting cuts
         sizeAfter = sizeBefore;
         Int_t clusIdx = 0;
         for( gmmClusIter = gmmClusters.begin(); gmmClusIter != gmmClusters.end(); ++gmmClusIter, ++clusIdx ){
            if(  gmmClusIter->A < mMinimumAmpFrac*maxAmp || gmmClusIter->sigmaSq < mMinSigmaSq || gmmClusIter->sigmaSq > mMaxSigmaSq || nStripsPerClus[ clusIdx ] < mMinStripsPerCluster ){
#ifdef DEBUG3
               cout << gmmClusIter->A << '<' << mMinimumAmpFrac*maxAmp << ' '
                    << gmmClusIter->sigmaSq << '<' << mMinSigmaSq << ' '
                    << gmmClusIter->sigmaSq << '>' << mMaxSigmaSq << ' '
                    << nStripsPerClus[ clusIdx ] << "<" << mMinStripsPerCluster << endl;
#endif
               gmmClusIter->sigmaSq = 0;
               --sizeAfter;
            };
         };

         if( sizeAfter != sizeBefore ){
            // copy in which to store good clusters
            GmmEmGausParamVec_t tempVec;
            tempVec.reserve( sizeBefore );

            for( gmmClusIter = gmmClusters.begin(); gmmClusIter != gmmClusters.end(); ++gmmClusIter )
               if( gmmClusIter->sigmaSq > 0 )
                  tempVec.push_back( *gmmClusIter );
            gmmClusters.swap( tempVec );
         };

#ifdef DEBUG
         LOG_INFO << "GMM semi-final results for " << sizeBefore << " clusters: " << endm;
         for( gmmClusIter = gmmClusters.begin(); gmmClusIter != gmmClusters.end(); ++gmmClusIter ){
            LOG_INFO << "\t" << gmmClusIter->A << ' ' << gmmClusIter->mean << ' ' << sqrt( gmmClusIter->sigmaSq ) << endm;
         };
#endif
      };
   };


   if( !ierr && !gmmClusters.empty() ){
      Int_t numClus = gmmClusters.size();

      // convert results to correct output
      clustersOut.reserve( numClus );

      Int_t clusIdx = 0;
      for( gmmClusIter = gmmClusters.begin(); gmmClusIter != gmmClusters.end(); ++gmmClusIter, ++clusIdx ){
         clustersOut.push_back( StSimpleCluster_t( ++mLastClusterID ) );
         StSimpleCluster_t& clus = clustersOut.back();

         TArrayS& memArr = clus.getMemberArray();
         TArrayF& wArr = clus.getWeightArray();

         Int_t n = nStripsPerClus[ clusIdx ];

#ifdef DEBUG2
         LOG_INFO << "Nominal number of strips in cluster " << clusIdx << " is " << n << endm;
#endif
         if( n ){
            memArr.Set( n );
            wArr.Set( n );

            Int_t idx = 0, seedIdx = 0;
            Double_t maxStripE = 0;
            Double_t energy = 0;
            Double_t sigma = sqrt(gmmClusIter->sigmaSq);
            Double_t mean = gmmClusIter->mean;

            // assigned the strip with weights
            const WeightVec_t& weightVec = mGmmEm.getWeights();
            weightIter = weightVec.begin();
            dataVecIter = gmmEmData.begin();
            for( ; weightIter != weightVec.end(); ++weightIter, ++dataVecIter ){
               const Double_t &w = (*weightIter)[clusIdx];
               const Double_t &e = mStripEnergyArray[ dataVecIter->idx ];
               //Double_t dist = fabs( mean - dataVecIter->idx )/sigma;
               //cout << "clus " << clusIdx << " strip " << dataVecIter->idx << " dist " << dist << ' ' << mMaxStripSigmaDist << endl;
               if( w > mMinStripWeight && e > 0 && fabs( mean - dataVecIter->idx )/sigma < mMaxStripSigmaDist ){
                  memArr[idx] = dataVecIter->idx;
                  wArr[idx] = w;

#ifdef DEBUG4
                  cout << "TSG -- clus " << mean << " strip " << dataVecIter->idx << " E " << e << '*' << w << ' ' << energy << endl;
#endif

                  Double_t thisE = w * mSmoothedEnergyArrayB[ dataVecIter->idx ];
                  energy += thisE;
                  if( thisE > maxStripE ){
                     maxStripE = thisE;
                     seedIdx = idx;
                  };

                  // must weight until after setting seedIdx to increment
                  idx++;
               };
            };

            clus.setMeanX( gmmClusIter->mean );
            clus.setMeanY( sigma ); // for 1D, hold sigma in the 'Y' value
            clus.setEnergy( maxStripE );  // note: not the energy, but the max strip energy
            clus.setSeedIdx( seedIdx );

#ifdef DEBUG
            LOG_INFO << "Final result: " << getEventNum() << " Sector " << mSector << " layer " << mLayer << ' ' << clus << " seedE " << maxStripE << endm;
#endif
         };
      };
   };

   return ierr;
};

ClassImp( StEEmcStripClusterFinderTSG_t );

/*
 * $Id: StEEmcStripClusterFinderTSG.cxx,v 1.4 2012/01/02 17:14:42 sgliske Exp $
 * $Log: StEEmcStripClusterFinderTSG.cxx,v $
 * Revision 1.4  2012/01/02 17:14:42  sgliske
 * update
 *
 * Revision 1.3  2011/12/28 15:07:57  sgliske
 * update
 *
 * Revision 1.2  2011/12/28 14:54:22  sgliske
 * update
 *
 * Revision 1.1  2011/12/22 23:00:53  sgliske
 * creation
 *
 *
 */
@


1.4
log
@update
@
text
@d269 1
a269 1
 * $Id: StEEmcStripClusterFinderTSG.cxx,v 1.3 2011/12/28 15:07:57 sgliske Exp $
d271 3
@


1.3
log
@update
@
text
@d239 1
a239 1
                  Double_t thisE = w * mSmoothedEnergyArray[ dataVecIter->idx ];
d269 1
a269 1
 * $Id: StEEmcStripClusterFinderTSG.cxx,v 1.2 2011/12/28 14:54:22 sgliske Exp $
d271 3
@


1.2
log
@update
@
text
@d83 1
a83 1
   for( Double_t *p = &mSmoothedEnergyArray[iStart]; p != &mSmoothedEnergyArray[iEnd]; ++p, ++idx )
d269 1
a269 1
 * $Id: StEEmcStripClusterFinderTSG.cxx,v 1.1 2011/12/22 23:00:53 sgliske Exp $
d271 3
@


1.1
log
@creation
@
text
@d16 2
a17 1
#include "GmmEm1D/GmmEm1D.h"
a20 2
//#define DEBUG3
//#define DEBUG4
d23 1
a23 1
                                                                                   mForcedInitSigma(-1),
d27 5
a31 1
                                                                                   mMinStripWeight(1e-2) {
d33 1
a33 1
   mGmmEm.setMaxIters( maxGmmIters );
d66 5
a70 1
   ierr = StEEmcStripClusterFinderTSG_t::find( hitStrips, initClusters );
d91 3
a93 3
   gmmClusters.reserve( initClusters.size );
   for( clusIter = initClusters.begin(); clusIter != clusIter.end(); ++clusIter ){
      gmmClusters.push_back( GmmEmGausParam_t( clusIter->getEnergy(), clusIter->getMeanX(), clusIter->getMeanY() ) );
d114 1
a114 1
   std::vector< Int_t > nStripsPerClus;
d126 9
a135 1
         sizeBefore = gmmClusters.size();
d139 1
a139 1
               if( std:abs( gmmClusIter2->mean - gmmClusIter->mean ) < mMergeDist )
d143 1
a143 1
         nStripsPerClus.assign( 0, sizeBefore );
d148 4
a151 3
            for( Int_t i=0; i<numClus; ++i )
               if( (*weightIter)[i] > mMinStripWeight && mStripEnergyArray[ dataVecIter->idx ] > 0 )
                  ++nStripsPerClus[i];
d154 1
a154 1
         Float_t maxAmp = gmmClusters.front()->A;
d160 7
a166 1
            if( gmmClusIter->A > mMinimumAmpFrac*maxAmp && gmmClusIter->sigmaSq > mMinSigmaSq && gmmClusIter->sigmaSq < mMaxSigmaSq && nStripsPerClus[ clusIdx ] >= mMinStripsPerClus ){
d179 1
a179 1
                  tempVec.push_back( gmmClusIter );
d184 1
a184 1
         LOG_INFO << "GMM results for " << sizeBefore << " clusters: " << endm;
a202 1
         clus.setMeanX( gmmClusIter->mean );
a207 2
         memArr.Set( n );
         wArr.Set( n );
d209 23
a231 12
         Int_t idx = 0, seedIdx = 0;
         Double_t maxStripE = 0;
         Double_t energy = 0;

         // GOT TO HERE

         dataVecIter = gmmEmData.begin();
         for( savedWeightVecIter = savedWeightVec.begin(); savedWeightVecIter != savedWeightVec.end(); ++savedWeightVecIter, ++dataVecIter ){
            if( savedWeightVecIter->size() > (UInt_t)clusIdx  ){
               Double_t &w = (*savedWeightVecIter)[clusIdx];

               if( w > mMinStripWeight ){
d235 5
a239 1
                  Double_t thisE = w * dataVecIter->val;
a249 1
         };
d251 4
a254 2
         clus.setEnergy( energy );
         clus.setSeedIdx( seedIdx );
d257 1
a257 1
         LOG_INFO << "Final result: " << getEventNum() << " Sector " << mSector << " layer " << mLayer << ' ' << clus << " seedE " << maxStripE << endm;
d259 1
d269 5
a273 2
 * $Id: $
 * $Log: $
@

