head	1.2;
access;
symbols
	response:1.1;
locks; strict;
comment	@# @;


1.2
date	2012.10.09.03.57.20;	author sgliske;	state dead;
branches;
next	1.1;

1.1
date	2011.11.02.20.54.24;	author sgliske;	state Exp;
branches;
next	;


desc
@@


1.2
log
@removed unused makers
@
text
@/*!
 *
 * \class EEmcHitMakerAnlEM_t
 * \author Stephen Gliske <sgliske@@anl.gov>
 *
 * See header file for description.
 *
 */

/// Include Root headers
#include <TF1.h>

/// Include StRoot headers
#include "StRoot/St_base/Stypes.h"
#include "StRoot/St_base/StMessMgr.h"
#include "StRoot/StEEmcPool/StEEmcGeoId/StEEmcGeoId.h"
#include "StRoot/StEEmcUtil/EEmcGeom/EEmcGeomDefs.h"
#include "StRoot/StEEmcUtil/StEEmcSmd/EEmcSmdGeom.h"
#include "StRoot/StEEmcPool/StEEmcPointMap/StEEmcPointMap.h"

/// Include related classes
#include "StEEmcHitMakerAnlEM.h"
#include "StEEmcAnlElement.h"
#include "StEEmcAnlHit.h"
#include "StSimpleCluster.h"
#include "StEEmcHit.h"

/// Construtor
StEEmcHitMakerAnlEM_t::StEEmcHitMakerAnlEM_t( const Char_t *myName,             // name of this maker in the StMaker hash table
                                              const Char_t *responseMakerName,  // name of the keeper in charge of the response
                                              StEEmcTowerClusterFinder_t* towerClusterFinder ) :
   StEEmcHitMaker_t(    myName, responseMakerName ),
   mTowerClusterFinder( towerClusterFinder ),
   mStripInclDist(10),
   mStripMinWeight(1e-3),
   mStripDistFunc(0),
   mMaxEigenvalue(0.6),
   mTowerInclDist(10),
   mTowerMinWeight(1e-3),
   mTowerDistFunc(0),
   mMinHitDist(2.5),
   mMaxIters(10),
   mMaxRenormIters(2),
   mMaxMinuitIters(50),
   mMinuitTolerance(0.1),
   mMinuitStepSize(0.1){ 
   mMinuit = new TMinuit(2);
};

/// Deconstructor
StEEmcHitMakerAnlEM_t::~StEEmcHitMakerAnlEM_t(){
   delete mMinuit;
};

/// Initialize
Int_t StEEmcHitMakerAnlEM_t::Init(){
   // just check pointers and functions, otherwise is ready

   Int_t ierr = kStOK;
   if( !mTowerClusterFinder ){
      LOG_FATAL << ClassName() << "::Init() -- null pointer for tower cluster finder" << endm;
      ierr = kStFatal;
   };
   if( !ierr && !mTowerClusterFinder->isReady() ){
      LOG_FATAL << ClassName() << "::Init() -- tower cluster finder not in ready state" << endm;
      ierr = kStFatal;
   };
   if( !ierr && mStripDistFunc && mStripDistFunc->IsZombie() ){
      LOG_FATAL << ClassName() << "::Init() -- strip distance function is a zombie" << endm;
      ierr = kStFatal;
   };
   if( !ierr && mStripDistFunc && mTowerDistFunc->IsZombie() ){
      LOG_FATAL << ClassName() << "::Init() -- tower distance function is a zombie" << endm;
      ierr = kStFatal;
   };
   if( !ierr && !mPointDistFunc ){
      LOG_FATAL << ClassName() << "::Init() -- no point distance function provided" << endm;
      ierr = kStFatal;
   };
   if( !ierr && mPointDistFunc->IsZombie() ){
      LOG_FATAL << ClassName() << "::Init() -- point distance function is a zombie" << endm;
      ierr = kStFatal;
   };

   return ierr;
};

/// Find all the hits
Int_t StEEmcHitMakerAnlEM_t::Make(){
   Int_t ierr = kStOk;
   Bool_t doContinue = 1;

   ierr = init();

   Int_t iterNum = 0;
   for( iterNum = 0; iterNum<mMaxIters && doContinue && !ierr; ++iterNum ){
      LOG_INFO << GetEventNumber() << " On iteration " << iterNum << " of " << mMaxIters << endm;

      if(!ierr)
         ierr = updateEnergies(0);

      if(!ierr)
         ierr = divideHits();

      if(!ierr)
         ierr = estimatePositions();

      if(!ierr)
         ierr = updateEnergies(1);

      if(!ierr)
         ierr = estimateEnergy();

      if(!ierr)
         ierr = merge();

      if(!ierr )
         doContinue = !stop();
   };

   if( !ierr )
      convertAnlHitToEEmcHit();

   return ierr;
};

/// Clear for next event
void  StEEmcHitMakerAnlEM_t::Clear(Option_t *opts ){
   StEEmcHitMaker_t::Clear( opts );
   mTowerClusterFinder->clear();
   mAnlHitList.clear();
};

// Initialize the list of hits using the tower cluster finder.
// Also set up maps to find hit strips/towers easier
Int_t StEEmcHitMakerAnlEM_t::init(){

   // flag that tower clusters exist
   mDoClusterTower[ TOWER ] = 1;

   // cluster the towers
   StEEmcTowerVec_t &towVec = *(mHitTowerPtr[ TOWER ]);
   Int_t ierr = mTowerClusterFinder->find( towVec, mTowerClusterVec[ TOWER ] );

   if( !ierr ){
      // copy the results
      for( StSimpleClusterVec_t::iterator iter = mTowerClusterVec[ TOWER ].begin(); iter != mTowerClusterVec[ TOWER ].end(); ++iter )
         mAnlHitList.push_back( *iter );
   };


   // copy deposited energy into sets so can do lookups easier
   StEEmcStripVec_t::iterator stripIter;
   StEEmcTowerVec_t::iterator towerIter;
   for( Int_t sector = 0; sector < kEEmcNumSectors && !ierr; ++sector ){
      StEEmcStripVec_t &uVec = *(mHitUStripPtr[sector]);
      StEEmcStripVec_t &vVec = *(mHitVStripPtr[sector]);

      for( stripIter = uVec.begin(); stripIter != uVec.end(); ++stripIter ){
         if( !stripIter->fail() && !stripIter->stat() ){
            Short_t geoId = StEEmcGeoId_t::encodeSmd( sector, 0, stripIter->index() );
            mStripDepositedEnergy.insert( StEEmcAnlElement_t( geoId, stripIter->energy() ) );
         };
      };
      for( stripIter = vVec.begin(); stripIter != vVec.end(); ++stripIter ){
         if( !stripIter->fail() && !stripIter->stat() ){
            Short_t geoId = StEEmcGeoId_t::encodeSmd( sector, 1, stripIter->index() );
            mStripDepositedEnergy.insert( StEEmcAnlElement_t( geoId, stripIter->energy() ) );
         };
      };
   };

   for( towerIter = towVec.begin(); towerIter != towVec.end(); ++towerIter ){
      if( !towerIter->fail() && !towerIter->stat() ){
         Short_t geoId = StEEmcGeoId_t::encodeTow( towerIter->sector(), towerIter->subsector(), towerIter->etabin() );
         mStripDepositedEnergy.insert( StEEmcAnlElement_t( geoId, towerIter->energy() ) );
      };
   };

   return ierr;
};

Int_t StEEmcHitMakerAnlEM_t::updateEnergies( Bool_t doTowers ){
   Int_t ierr = kStOK;

   // container to store all weights for a given geoId (strip or tower)
   std::map< Short_t, std::vector< Float_t* > > geoId2weightPtrMap;
   std::map< Short_t, std::vector< Float_t* > >::iterator geoId2weightPtrMapIter;
   std::vector< Float_t* >::iterator weightPtrVecIter;

   // container for holding sets of geoIds, and its iterator
   std::set< Short_t > geoIdSet;
   std::set< Short_t >::iterator geoIdSetIter;

   // iterate over all the hits
   StEEmcAnlHitList_t::iterator hitIter;
   Int_t hitIdx = 0;
   for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end(); ++hitIter, ++hitIdx ){
      // get the nearby strips/towers
      if( doTowers )
         StEEmcPointMap_t::instance().getTowersNearPoint( hitIter->getX(), hitIter->getY(), mTowerInclDist, geoIdSet );
      else
         StEEmcPointMap_t::instance().getStripsNearPoint( hitIter->getX(), hitIter->getY(), mStripInclDist, geoIdSet );

      StEEmcAnlElementSet_t& hitElementSet = ( doTowers ? hitIter->getTowerSet() : hitIter->getStripSet() );
      hitElementSet.clear();

      // loop over all the strips/towers for this hit
      for( geoIdSetIter = geoIdSet.begin(); geoIdSetIter != geoIdSet.end(); ++geoIdSetIter ){
         // determine nominal weight
         Float_t w = 0;

         if( doTowers ){
            w = hitIter->getEuv();
            if( mTowerDistFunc )
               w *= mTowerDistFunc->Eval( StEEmcPointMap_t::instance().getTowerDCA( hitIter->getX(), hitIter->getY(), *geoIdSetIter ) );
         } else {
            w = hitIter->getE();
            if( mStripDistFunc )
               w *= mStripDistFunc->Eval( StEEmcPointMap_t::instance().getStripDCA( hitIter->getX(), hitIter->getY(), *geoIdSetIter ) );
         };

         std::pair< StEEmcAnlElementSet_t::iterator, Bool_t > returnPair = hitElementSet.insert( StEEmcAnlElement_t( *geoIdSetIter, w ) );

         // save pointer to this weight (i.e. energy) so can later normalize 
         geoId2weightPtrMap[ *geoIdSetIter ].push_back( const_cast< StEEmcAnlElement_t* >( &(*returnPair.first) )->getEnergyPtr() );
      };
   };

   // adjust threshold
   if( mMaxRenormIters < 0 )
      mMaxRenormIters = 0;

   // need to normalize the energy of each element (strip or tower)
   StEEmcAnlElementSet_t::iterator elementSetIter;
   for( geoId2weightPtrMapIter = geoId2weightPtrMap.begin(); geoId2weightPtrMapIter != geoId2weightPtrMap.end(); ++geoId2weightPtrMapIter ){
      // need sum of weights
      Float_t totW = 0;
      for( weightPtrVecIter = geoId2weightPtrMapIter->second.begin(); weightPtrVecIter != geoId2weightPtrMapIter->second.end(); ++weightPtrVecIter )
         totW += *(*weightPtrVecIter);

      if( !totW ){
         LOG_ERROR << "SANITY CHECK FAILURE" << endm;
         totW = 1;
      };

      // need correct sum of energies
      Float_t E = 0;
      if( doTowers )
         elementSetIter = mTowerDepositedEnergy.lower_bound( StEEmcAnlElement_t( geoId2weightPtrMapIter->first, 0 ) );
      else
         elementSetIter = mStripDepositedEnergy.lower_bound( StEEmcAnlElement_t( geoId2weightPtrMapIter->first, 0 ) );

      if( elementSetIter->getGeoId() == geoId2weightPtrMapIter->first )
         E = elementSetIter->getEnergy();

      // renormalization factor
      Float_t factor = E/totW;

      Float_t minWeight = ( doTowers ? mTowerMinWeight : mStripMinWeight );

      Bool_t doneNormalizing = 0;
      for( Int_t nIter = 0; nIter <= mMaxRenormIters && !doneNormalizing; ++nIter ){
         // renormalize
         doneNormalizing = 1;
         for( weightPtrVecIter = geoId2weightPtrMapIter->second.begin(); weightPtrVecIter != geoId2weightPtrMapIter->second.end(); ++weightPtrVecIter ){
            *(*weightPtrVecIter) *= factor;

            if( *(*weightPtrVecIter) < minWeight && E ){
               totW -= *(*weightPtrVecIter);

               if( !totW ){
                  LOG_ERROR << "SANITY CHECK FAILURE" << endm;
                  E = 0;
                  totW = 1;
               };

               factor = E/totW;
               *(*weightPtrVecIter) = 0;
               doneNormalizing = 0;
            };
         };
      };
   };

   // need to purge from the hits any strips/towers that have zero energy
   StEEmcAnlElementSet_t::iterator elementSetIterCopy;
   for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end(); ++hitIter, ++hitIdx ){
      StEEmcAnlElementSet_t& hitElementSet = ( doTowers ? hitIter->getTowerSet() : hitIter->getStripSet() );

      // make sure at least the first one is non-zero
      while( !hitElementSet.empty() && hitElementSet.begin()->getEnergy() <= 0 )
         hitElementSet.erase( hitElementSet.begin() );

      Float_t totE = 0, totEv = 0;

      if( !hitElementSet.empty() ){
         elementSetIter = hitElementSet.begin();
         for( ++elementSetIter; elementSetIter != hitElementSet.end(); ++elementSetIter ){
            if( doTowers ){
               totE += elementSetIter->getEnergy();
            } else {
               Short_t sector, strip;
               Bool_t layerIsV;
               StEEmcGeoId_t::decodeSmd( stripIter->getGeoId(), sector, layerIsV, strip );
               ( layerIsV ? totEv : totE ) += elementSetIter->getEnergy();
            };

            if( elementSetIter->getEnergy() <= 0 ){
               elementSetIterCopy = elementSetIter;
               --elementSetIter;
               hitElementSet.erase( elementSetIterCopy );
            };
         };
      };

      // update total energies
      if( doTowers ){
         hitIter->setE( totE );
      } else {
         hitIter->setEu( totE );
         hitIter->setEu( totEv );
      };
   };

   return ierr;
};

Int_t StEEmcHitMakerAnlEM_t::estimatePositions(){
   Int_t ierr = kStOk;

   // need to divide strips into sectors
   std::map< Short_t, StEEmcAnlElementPtrSet_t > sectorStripMap;
   std::map< Short_t, StEEmcAnlElementPtrSet_t >::iterator sectorStripMapIter;

   std::set< Short_t > usedSectors;
   std::set< Short_t >::iterator usedSectorsIter;
   Int_t numUstripsPerSector[kEEmcNumSectors];
   Int_t numVstripsPerSector[kEEmcNumSectors];

   // some iterators
   StEEmcAnlHitList_t::iterator hitIter;
   StEEmcAnlElementSet_t::iterator stripIter;

   // loop over hits
   for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end() && ierr != kStFatal; ++hitIter ){
      // clear things
      sectorStripMap.clear();
      usedSectors.clear();
      for( Int_t *p1 = numUstripsPerSector, *p2 = numVstripsPerSector; p1 != &numUstripsPerSector[kEEmcNumSectors]; ++p1, ++p2 ){
         (*p1) = 0;
         (*p2) = 0;
      };

      // loop over strips to see how many in which sectors
      StEEmcAnlElementSet_t& hitStripSet = hitIter->getStripSet();
      for( ++stripIter; stripIter != hitStripSet.end(); ++stripIter ){
         Short_t sector;
         Bool_t layerIsV;
         Short_t strip;

         StEEmcGeoId_t::decodeSmd( stripIter->getGeoId(), sector, layerIsV, strip );
         usedSectors.insert( sector );
         ++( layerIsV ? numVstripsPerSector[sector] : numUstripsPerSector[sector] );

         // encode both sector and layer into the map key
         if( layerIsV )
            sector += kEEmcNumSectors;

         sectorStripMap[ sector ].insert( &(*stripIter) );
      };

      // try the usual cases
      Bool_t validHit = 0;
      Float_t x = 0, y = 0;
      if( usedSectors.size() == 1 ){
         Int_t sector = *(usedSectors.begin());

         if( numUstripsPerSector[sector] && numVstripsPerSector[sector] ){
            // both u and v exist and are in the same sector
            ierr = estimatePositionSingleSector( sectorStripMap[ sector ], x, y );
         };
         validHit = 1;
      } else if ( usedSectors.size() == 2 ){
         usedSectorsIter = usedSectors.begin();

         Int_t sector1 = *(usedSectorsIter);
         Int_t sector2 = *(++usedSectorsIter);

         Short_t deltaSectors = (sector1 - sector2 + kEEmcNumSectors) % kEEmcNumSectors;
         if( deltaSectors == 1 ){
            ierr = estimatePositionSplitSector( *hitIter, x, y );
            validHit = 1;
         };
      };

      // if not any of the usual cases
      if( !validHit ){
         Int_t sum = -1;
         Int_t bigSector = -1;
         LOG_ERROR << "Error: hit involves the strips from the following sectors" << endm;
         for( Int_t sector = 0; sector < kEEmcNumSectors; ++sector ){
            LOG_ERROR << sector << ": " << numUstripsPerSector[sector] << ", " << numVstripsPerSector[sector] << endm;

            Int_t localSum = numUstripsPerSector[sector] + numVstripsPerSector[sector];
            if( localSum > sum )
               bigSector = sector;
         };

         // default to using the sector with the most amount of strips, and ignore other sectors
         ierr = estimatePositionSingleSector( sectorStripMap[ bigSector ], x, y );
      };

      // invalidate hit if error
      if( ierr ){
         x = 0;
         y = 0;
      };

      // set position
      hitIter->setXY( x, y );

      // loop to next hit
   };

   return ierr;
};

Int_t StEEmcHitMakerAnlEM_t::estimatePositionSingleSector( const StEEmcAnlElementPtrSet_t& stripSet, Float_t& x, Float_t& y ){
   Int_t ierr = 0;
   Float_t uPos = 0, vPos = 0, uWeight, vWeight;
   Short_t sector = -1;

   StEEmcAnlElementPtrSet_t::const_iterator stripSetIter;
   for( stripSetIter = stripSet.begin(); stripSetIter != stripSet.end(); ++stripSetIter ){
      Bool_t layerIsV;
      Short_t strip;

      StEEmcGeoId_t::decodeSmd( (*stripSetIter)->getGeoId(), sector, layerIsV, strip );
      if( layerIsV ){
         vPos += (*stripSetIter)->getEnergy() * strip;
         vWeight += (*stripSetIter)->getEnergy();
      } else {
         uPos += (*stripSetIter)->getEnergy() * strip;
         uWeight += (*stripSetIter)->getEnergy();
      };
   };

   x = 0;
   y = 0;
   if( vWeight && uWeight ){
      uPos /= uWeight;
      vPos /= vWeight;

      TVector3 direct = EEmcSmdGeom::instance()->getIntersection( sector, uPos, vPos );
      x = direct.X();
      y = direct.Y();
   };

   return ierr;
};

Int_t StEEmcHitMakerAnlEM_t::estimatePositionSplitSector( const StEEmcAnlHit_t& hit, Float_t& x, Float_t& y ){
   StEEmcAnlHit_t::setActiveHit( &hit );
   mMinuit->SetFCN( &StEEmcAnlHit_t::meanSquaredDcaMinuitFunc );
   Int_t ierflg = 0;
   mMinuit->mnparm(0, "x", hit.getX(), mMinuitStepSize, 0, 0, ierflg);
   mMinuit->mnparm(1, "y", hit.getY(), mMinuitStepSize, 0, 0, ierflg);

   // minimize
   Double_t arglist[2] = { mMaxMinuitIters, mMinuitTolerance };
   mMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
   Double_t err, X, Y;

   mMinuit->GetParameter( 0, X, err );
   mMinuit->GetParameter( 1, Y, err );

   // copy double to float
   x = X;
   y = Y;

   return ierflg;
};

// get all points where strips in a hit "could" intersect, so that one can compute the covariance in the divide strips member function
void StEEmcHitMakerAnlEM_t::getIntersectingPointSet( const StEEmcAnlHit_t& hit, std::vector< AnlEMPoint_t >& pointVec, Float_t& meanX, Float_t& meanY, Float_t& totW ){
   meanX = 0;
   meanY = 0;
   totW = 0;

   StEEmcAnlElementPtrSet_t::const_iterator stripSetIter1, stripSetIter2;
   for( stripSetIter1 = stripSet.begin(); stripSetIter1 != stripSet.end(); ++stripSetIter1 ){

      Float_t x1start, x1stop, y1start, y1stop, a1, b1;
      StEEmcPointMap_t::instance().getStripEndPoints( stripSetIterA->getGeoId(), x1start, x1stop, y1start, y1stop );

      a1 = (y1stop - y1start ) / ( x1stop - x1start );
      b1 = y1start - a1 * x1start;

      for( stripSetIter2 = stripSet.begin(); stripSetIter2 != stripSetIter1; ++stripSetIter2 ){

         Float_t x2start, x2stop, y2start, y2stop, a2, b2;
         StEEmcPointMap_t::instance().getStripEndPoints( stripSetIterA->getGeoId(), x2start, x2stop, y2start, y2stop );

         a2 = (y2stop - y2start ) / ( x2stop - x2start );
         b2 = y2start - a2 * x2start;

         if( a1 != a2 ){
            Float_t x = ( b1 - b2 ) / ( a2 - a1 );
            Float_t y = a1*x + b1;
            Float_t w = stripSetIter1->getEnergy() * stripSetIter2->getEnergy();

            // do not check if strips really cross
            //             if( x > std::min( x1start, x1stop ) && 
            //                 x > std::min( x2start, x2stop ) && 
            //                 x < std::max( x1start, x1stop ) && 
            //                 x < std::max( x2start, x2stop ) ){


            pointVec.push_back( AnlEmPoint_t( w, x, y ) );

            meanX += x*w;
            meanY += y*w;
            totW += w;
         };
      };
   };

   if( totW ){
      meanX /= totW;
      meanY /= totW;
   };

   return;
};

Int_t StEEmcHitMakerAnlEM_t::divideHits(){

   // using NCuts Algo

   getIntersectingPointSet( const StEEmcAnlHit_t& hit, std::vector< AnlEMPoint_t >& pointVec, Float_t& meanX, Float_t& meanY, Float_t& totW ){

   // some iterators
   StEEmcAnlHitList_t::iterator hitIter;
   std::vector< AnlEMPoint_t > pointVec;
   std::vector< AnlEMPoint_t >::iterator pointVecIter;

   // loop over hits
   for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end() && ierr != kStFatal; ++hitIter ){
      Float_t meanX, meanY, towW;

      getIntersectingPointSet( *hitIter, pointVec, meanX, meanY, towW );
      for( pointVecIter = pointVec.begin(); pointVecIter != pointVec.end(); ++pointVecIter ){


      }
   };

   LOG_INFO << "NOT YET PROGRAMMED" << endm;
};

Int_t StEEmcHitMakerAnlEM_t::merge(){
   LOG_INFO << "NOT YET PROGRAMMED" << endm;
};

Bool_t StEEmcHitMakerAnlEM_t::stop(){
   LOG_INFO << "NOT YET PROGRAMMED" << endm;
};

Int_t StEEmcHitMakerAnlEM_t::convertAnlHitToEEmcHit(){
   LOG_INFO << "NOT YET PROGRAMMED" << endm;
};

ClassImp( StEEmcHitMakerAnlEM_t );

/*
 * $Id: StEEmcHitMakerAnlEM.cxx.tmp,v 1.1 2011/11/02 20:54:24 sgliske Exp $
 *
 * $Log: StEEmcHitMakerAnlEM.cxx.tmp,v $
 * Revision 1.1  2011/11/02 20:54:24  sgliske
 * update
 *
 * Revision 1.2  2011/09/01 21:52:49  sgliske
 * Working on ANL EM Algo -- still
 *
 * Revision 1.1  2011/08/31 22:05:43  sgliske
 * Working on ANL EM Algo
 *
 *
 * 
 */
@


1.1
log
@update
@
text
@d577 5
a581 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.2 2011/09/01 21:52:49 sgliske Exp $
a582 1
 * $Log: StEEmcHitMakerAnlEM.cxx,v $
@

