head	1.4;
access;
symbols
	response:1.3;
locks; strict;
comment	@// @;


1.4
date	2012.10.09.03.57.21;	author sgliske;	state dead;
branches;
next	1.3;

1.3
date	2011.08.30.20.23.30;	author sgliske;	state Exp;
branches;
next	1.2;

1.2
date	2011.08.18.15.48.38;	author sgliske;	state Exp;
branches;
next	1.1;

1.1
date	2011.08.16.16.31.15;	author sgliske;	state Exp;
branches;
next	;


desc
@@


1.4
log
@removed unused makers
@
text
@/*
 * \class StMcEEmcHitMakerTowers_t
 * \author Stephen Gliske <sgliske@@anl.gov>
 *
 * See description in StMcEEmcHitMakerTowers.h
 *
*/

#include <string>

/// Include the header
#include "StMcEEmcHitMakerTowers.h"

/// Include StRoot classes
#include "StRoot/St_base/StMessMgr.h"
#include "StRoot/St_base/Stypes.h"
#include "StRoot/StEEmcPool/StEEmcResponseTreeMaker/StMcTowerResponse.h"
#include "StRoot/StEEmcPool/StEEmcResponseTreeMaker/StMcEEmcResponse.h"
#include "StRoot/StEEmcPool/StEEmcResponseTreeMaker/StEEmcResponseKeeper.h"

#include "StEEmcHitMaker.h"

/// Construtor
StMcEEmcHitMakerTowers_t::StMcEEmcHitMakerTowers_t( const Char_t *myName,             // name of this maker in the StMaker hash table
                                                    const Char_t *responseMakerName,  // name of the maker in charge of setting the resonse
                                                    const Char_t *hitDataName )     // name of the hit maker
   : StMcEEmcHitMaker_t( myName, responseMakerName, hitDataName )
{
   // that is all!
};


/// Make: align MC tracks with Hits
Int_t StMcEEmcHitMakerTowers_t::Make(){
   Int_t ierr = kStOK;

   //LOG_INFO << GetEventNumber() << ' ' << ClassName() << "::Make()" << endm;

   // map for finding towers more easily
   // key = tower index (ID) 0..719
   // value = pointer to StMcTowerResponse_t
   std::map< Short_t, StMcTowerResponse_t* > towerMap;
   std::map< Short_t, StMcTowerResponse_t* >::iterator towerMapIter;

   TClonesArray *towerArrayPtr = mMcResponsePtr->getTowerArrayPtr();
   if( !towerArrayPtr ){
      LOG_FATAL << "Error getting tower array pointer from the response class" << endm;
      ierr = kStFatal;
   };

   mMcResponsePtr->makeMaps();

   // map for keeping track of tracks contribution to a hit
   // key = track key
   // value = weight
   std::map< Short_t, Float_t > trackWeightMap;
   std::map< Short_t, Float_t >::iterator trackWeightMapIter;


   if( !ierr ){
      // easier to work with a reference
      TClonesArray &towerArray = *towerArrayPtr;

      // copy towers into the map
      for( Int_t i=0; i<towerArray.GetEntriesFast(); ++i ){
         StMcTowerResponse_t *mcTowerRespPtr = static_cast< StMcTowerResponse_t* >( towerArray[i] );
         towerMap[ mcTowerRespPtr->getID() ] = mcTowerRespPtr;
      };
   };

   if( !ierr ){
      const StEEmcHitVec_t& hitVec = mHitDataPtr->getHitVec();
      StEEmcHitVec_t::const_iterator hitIter;
      for( hitIter = hitVec.begin(); hitIter != hitVec.end(); ++hitIter ){
         // first copy over
         mMcHitVec.push_back( *hitIter );

         // get reference
         StMcEEmcHit_t &mcHit = mMcHitVec.back();

         // clear map
         trackWeightMap.clear();

         // iterate over towers used in this hit
         Int_t nUsedTow = hitIter->getNumUsedTowers();
         for( Int_t i = 0; i<nUsedTow; ++i ){
            Short_t usedTowIdx = hitIter->getUseTowerIndex( i );
            Float_t usedTowWeight = hitIter->getUseTowerWeight( i );

            //LOG_INFO << GetEventNumber() << " aaa Hit " << hitIter->getID() << " used " << usedTowIdx << ", weight = " << usedTowWeight << endm;

            // now find the tower in the tower/track map
            towerMapIter = towerMap.find( usedTowIdx );

            // make sure it was found
            if( towerMapIter != towerMap.end() ){
               // iterate over the tracks contributing to this tower
               TArrayS& trackIdxArray = towerMapIter->second->getTrackIdxArray();
               TArrayF& trackWeightArray = towerMapIter->second->getEnergyFromTrackArray();

               Int_t nTracks = trackIdxArray.GetSize();
               if( trackWeightArray.GetSize() < nTracks )
                  nTracks = trackWeightArray.GetSize();

               for( Int_t j = 0; j < nTracks; ++j ){
                  // additional contribution to the weight of this track
                  Float_t w = trackWeightArray[j] * usedTowWeight;
                  Int_t trackKey = trackIdxArray[j];

                  if( w && trackKey >= 0 ){
                     //LOG_INFO << GetEventNumber() << " aaa Track " << trackKey << " deposited " << trackWeightArray[j] << " into this tower." << endm;

                     // check if track considered yet for this hit
                     trackWeightMapIter = trackWeightMap.find( trackKey );
                     if( trackWeightMapIter == trackWeightMap.end() ){
                        trackWeightMap[ trackKey ] = w;
                     } else {
                        trackWeightMap[ trackKey ] += w;
                     };
                  };
               };
            };
         };

         // get total sum, so can normalize contributions
         Float_t totalWeight = 0;
         for( trackWeightMapIter = trackWeightMap.begin(); trackWeightMapIter != trackWeightMap.end(); ++trackWeightMapIter )
            totalWeight += trackWeightMapIter->second;

         // get the arrays to save the tracks and weights
         TArrayS& trackIdxArray = mcHit.getTrackIdxArray();
         TArrayF& trackWeightArray = mcHit.getEnergyFromTrackArray();

         // resize
         Int_t nTracks = trackWeightMap.size();
         trackIdxArray.Set( nTracks );
         trackWeightArray.Set( nTracks );

         //LOG_INFO << GetEventNumber() << " qqq Hit at " << mcHit.getX() << ' ' << mcHit.getY() << ' ' << mcHit.getZ() << endm;

         // copy track key's and weights for the hit
         Int_t i = 0;
         for( trackWeightMapIter = trackWeightMap.begin(); trackWeightMapIter != trackWeightMap.end(); ++trackWeightMapIter, ++i ){
            trackIdxArray[i] = trackWeightMapIter->first;
            trackWeightArray[i] = trackWeightMapIter->second / totalWeight;

//             Int_t geantId = -999;
//             if( mMcResponsePtr->getMcTrackPtr( trackIdxArray[i] ) )
//                geantId = mMcResponsePtr->getMcTrackPtr( trackIdxArray[i] )->getGeantId();

//             LOG_INFO << "\tassociated with track " << trackIdxArray[i]
//                      << " (type " << geantId << ")"
//                      << ", weight " << trackWeightArray[i] << endm;
         };
      }; // end loop over hits
   }; // end ierr check

   //LOG_INFO << GetEventNumber() << "\tdone with " << ClassName() << "::Make()" << endm;

   return ierr;
};

ClassImp( StMcEEmcHitMakerTowers_t );

/*
 * $Id: StMcEEmcHitMakerTowers.cxx,v 1.3 2011/08/30 20:23:30 sgliske Exp $
 * 
 * $Log: StMcEEmcHitMakerTowers.cxx,v $
 * Revision 1.3  2011/08/30 20:23:30  sgliske
 * update
 *
 * Revision 1.2  2011/08/18 15:48:38  sgliske
 * update
 *
 * Revision 1.1  2011/08/16 16:31:15  sgliske
 * StMcEEmcHitMaker divided into parent and child classes
 *
 *
*/
@


1.3
log
@update
@
text
@d166 1
a166 1
 * $Id: StMcEEmcHitMakerTowers.cxx,v 1.2 2011/08/18 15:48:38 sgliske Exp $
d169 3
@


1.2
log
@update
@
text
@d51 2
d90 2
d110 3
a112 1
                  if( w ){
d139 2
d146 8
d166 1
a166 1
 * $Id: StMcEEmcHitMakerTowers.cxx,v 1.1 2011/08/16 16:31:15 sgliske Exp $
d169 3
@


1.1
log
@StMcEEmcHitMaker divided into parent and child classes
@
text
@a17 1
#include "StRoot/StEEmcPool/StEEmcResponseTreeMaker/StMcStripResponse.h"
a38 2
   // TODO: later add options for using SMD strips or both SMD strips and towers
   
d150 1
a150 1
 * $Id: $
d152 4
a155 1
 * $Log: $
@

