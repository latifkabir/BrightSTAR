head	1.8;
access;
symbols
	response:1.7;
locks; strict;
comment	@// @;


1.8
date	2012.10.09.03.57.21;	author sgliske;	state dead;
branches;
next	1.7;

1.7
date	2011.12.13.21.32.27;	author sgliske;	state Exp;
branches;
next	1.6;

1.6
date	2011.12.06.22.36.36;	author sgliske;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.18.01.47.03;	author sgliske;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.11.21.28.27;	author sgliske;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.08.22.22.15;	author sgliske;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.24.21.49.39;	author sgliske;	state Exp;
branches;
next	1.1;

1.1
date	2011.08.18.15.48.38;	author sgliske;	state Exp;
branches;
next	;


desc
@@


1.8
log
@removed unused makers
@
text
@/*
 * \class StMcEEmcHitMakerStrips_t
 * \author Stephen Gliske <sgliske@@anl.gov>
 *
 * See description in StMcEEmcHitMakerStrips.h
 *
*/

//#define DEBUG
//#define DEBUG1
//#define DEBUG2

#include <string>

/// Include the header
#include "StMcEEmcHitMakerStrips.h"

/// Include StRoot classes
#include "StRoot/St_base/StMessMgr.h"
#include "StRoot/St_base/Stypes.h"
#include "StRoot/StEEmcUtil/EEmcGeom/EEmcGeomDefs.h"

#include "StRoot/StEEmcPool/StEEmcResponseTreeMaker/StMcStripResponse.h"
#include "StRoot/StEEmcPool/StEEmcResponseTreeMaker/StMcEEmcResponse.h"
#include "StRoot/StEEmcPool/StEEmcResponseTreeMaker/StEEmcResponseKeeper.h"

#include "StEEmcHitMaker.h"

/// Construtor
StMcEEmcHitMakerStrips_t::StMcEEmcHitMakerStrips_t( const Char_t *myName,             // name of this maker in the StMaker hash table
                                                    const Char_t *responseMakerName,  // name of the maker in charge of setting the resonse
                                                    const Char_t *hitDataName )     // name of the hit maker
   : StMcEEmcHitMaker_t( myName, responseMakerName, hitDataName )
{
   // that is all!
};


/// Make: align MC tracks with Hits
Int_t StMcEEmcHitMakerStrips_t::Make(){
   Int_t ierr = kStOK;

   //LOG_INFO << GetEventNumber() << ' ' << ClassName() << "::Make()" << endm;

   // map for finding strips more easily
   // key = kEEmcNumStrips*sector + strip
   // value = pointer to StMcStripResponse_t
   std::map< Short_t, const StMcStripResponse_t* > uStripMap, vStripMap;
   std::map< Short_t, const StMcStripResponse_t* >::iterator stripMapIter;

   // fill mc track map
   TClonesArray *trackArrPtr = mMcResponsePtr->getMcTrackArrayPtr();
   if( trackArrPtr ){
      TClonesArray &trackArr = *trackArrPtr;

      for( Int_t i=0; i<trackArr.GetEntriesFast(); ++i ){
         StMcSimpleTrack_t *mcTrackPtr = static_cast< StMcSimpleTrack_t* >( trackArr[i] );
         if( mcTrackPtr ){
#ifdef DEBUG
            LOG_INFO << "mmm track " << i << ", E = " << mcTrackPtr->getEnergy() << ", PID = " << mcTrackPtr->getGeantId() << ", " << mcTrackPtr->getPdgId() << endm;
#endif
            // make sure have positive energy and no stop vertex (i.e. hit the endcap)
            if( mcTrackPtr->getEnergy() > 0 && mcTrackPtr->getStopVertexKey() == -999 )
               mTrackMap[ mcTrackPtr->getKey() ] = mcTrackPtr;
         };
      };
   };


   // fill map of strips
   TClonesArray *stripArrayPtr = mMcResponsePtr->getSMDArrayPtr();
   if( !stripArrayPtr ){
      LOG_FATAL << "Error getting strip array pointer from the response class" << endm;
      ierr = kStFatal;
   };

   // map for keeping track of tracks contribution to a hit
   // key = track key
   // value = weight
   std::map< Short_t, Float_t > trackWeightMap;
   std::map< Short_t, Float_t >::iterator trackWeightMapIter;

   if( !ierr ){
      // easier to work with a reference
      TClonesArray &stripArray = *stripArrayPtr;

      // copy strips into the map
      for( Int_t i=0; i<stripArray.GetEntriesFast(); ++i ){
         StMcStripResponse_t *mcStripRespPtr = static_cast< StMcStripResponse_t* >( stripArray[i] );

#ifdef DEBUG
         // debug
         {
            LOG_INFO << "mmm " << mcStripRespPtr->getSector() << ' ' << mcStripRespPtr->getPlane() << ' ' << mcStripRespPtr->getIdx() << ' ' << mcStripRespPtr->getEnergy() << endm;

            TArrayS &trIdxArr = mcStripRespPtr->getTrackIdxArray();
            TArrayF &trEnArr = mcStripRespPtr->getEnergyFromTrackArray();
            for( Int_t i=0; i<trIdxArr.GetSize(); ++i ){
               LOG_INFO << "mmm\t" << trIdxArr[i] << ' ' << trEnArr[i] << endm;
            };
         };
#endif

#ifdef DEBUG2
         cout << "DDD " << mcStripRespPtr->getSector() << ' ' << ( mcStripRespPtr->getPlane() ? 'v' : 'u' ) << ' '
              << mcStripRespPtr->getIdx() << ' ' << mcStripRespPtr->getEnergy() << endl;
#endif

         if( mcStripRespPtr->getPlane() )
            vStripMap[ kEEmcNumStrips*mcStripRespPtr->getSector() + mcStripRespPtr->getIdx() ] = mcStripRespPtr;
         else
            uStripMap[ kEEmcNumStrips*mcStripRespPtr->getSector() + mcStripRespPtr->getIdx() ] = mcStripRespPtr;
      };
   };

   // container for strips and weights used in this hit
   std::vector< StripWeightStruct_t > uStripsUsed, vStripsUsed;

   // need map of cluster IDs vs. cluster pointers
   std::map< Short_t, const StSimpleCluster_t* > uClusMap, vClusMap;

   // fill the map
   const StESMDClustersVec_t& stripClusterVec = mHitDataPtr->getESMDClustersVec();
   StSimpleClusterVec_t::const_iterator clusVecIter;

   for( UInt_t i=0; i<stripClusterVec.size(); ++i ){
      const StSimpleClusterVec_t& uClusVec = stripClusterVec[i].getClusterVecU();
      for( clusVecIter = uClusVec.begin(); clusVecIter != uClusVec.end(); ++clusVecIter )
         uClusMap[ clusVecIter->getID() ] = &(*clusVecIter);

      const StSimpleClusterVec_t& vClusVec = stripClusterVec[i].getClusterVecV();
      for( clusVecIter = vClusVec.begin(); clusVecIter != vClusVec.end(); ++clusVecIter )
         vClusMap[ clusVecIter->getID() ] = &(*clusVecIter);
   };

   if( !ierr ){
      const StEEmcHitVec_t& hitVec = mHitDataPtr->getHitVec();
      StEEmcHitVec_t::const_iterator hitIter;
      for( hitIter = hitVec.begin(); hitIter != hitVec.end(); ++hitIter ){
         // first copy over
         mMcHitVec.push_back( *hitIter );

         // get reference
         StMcEEmcHit_t &mcHit = mMcHitVec.back();

         // clear things
         uStripsUsed.clear();
         vStripsUsed.clear();
         trackWeightMap.clear();

         ierr = fillStripsUsed( mcHit.getSectorU(), mcHit.getClusIDu(), uClusMap, uStripMap, uStripsUsed );

         if( !ierr )
            ierr = fillStripsUsed( mcHit.getSectorV(), mcHit.getClusIDv(), vClusMap, vStripMap, vStripsUsed );

         if( !ierr )
            ierr = includeWeightsFromLayer( uStripsUsed, trackWeightMap );

         if( !ierr )
            ierr = includeWeightsFromLayer( vStripsUsed, trackWeightMap );

         //LOG_INFO << "Used " << uStripsUsed.size() << ' ' << vStripsUsed.size() << ", weight map size " << trackWeightMap.size() << endl;


         // keep track of those with negative indices
         std::vector< Int_t > badIdx;


         // get total sum, so can normalize contributions
         Float_t totalWeight = 0;
         for( trackWeightMapIter = trackWeightMap.begin(); trackWeightMapIter != trackWeightMap.end(); ++trackWeightMapIter )
            if( trackWeightMapIter->first > -1 )
               totalWeight += trackWeightMapIter->second;
            else 
               badIdx.push_back( trackWeightMapIter->first );

         // remove those with negative track indices
         for( std::vector< Int_t >::iterator badIter = badIdx.begin(); badIter != badIdx.end(); ++badIter )
            trackWeightMap.erase( *badIter );

         // get the arrays to save the tracks and weights
         TArrayS& trackIdxArray = mcHit.getTrackIdxArray();
         TArrayF& trackWeightArray = mcHit.getEnergyFromTrackArray();

         // resize
         Int_t nTracks = trackWeightMap.size();
         trackIdxArray.Set( nTracks );
         trackWeightArray.Set( nTracks );

         //LOG_INFO << "Event " << GetEventNumber() << ", hit " << hitIter->getID() << " (E = " << hitIter->getEnergy() << "), nMcTracks = " << trackWeightMap.size() << endm;
#ifdef DEBUG1
         LOG_INFO << "Event " << GetEventNumber() << ", " << *hitIter << ", nMcTracks = " << trackWeightMap.size() << endm;
#endif
         stringstream ss;
         ss << "Event " << GetEventNumber() << ", " << *hitIter << ", nMcTracks = " << trackWeightMap.size();
         mcHit.setMcComment( ss.str() );

         // copy track key's and weights for the hit
         Int_t i = 0;
         for( trackWeightMapIter = trackWeightMap.begin(); trackWeightMapIter != trackWeightMap.end(); ++trackWeightMapIter, ++i ){
            trackIdxArray[i] = trackWeightMapIter->first;
            trackWeightArray[i] = trackWeightMapIter->second / totalWeight;
#ifdef DEBUG1
            LOG_INFO << "\t" << trackIdxArray[i] << ' ' << trackWeightArray[i] << endm;
#endif
         };
      }; // end loop over hits
   }; // end ierr check

   //LOG_INFO << GetEventNumber() << "\tdone with " << ClassName() << "::Make()" << endm;

   return ierr;
};

Int_t StMcEEmcHitMakerStrips_t::fillStripsUsed( const Short_t sector,
                                                const Short_t ID,
                                                const std::map< Short_t, const StSimpleCluster_t* >& clusMap,
                                                const std::map< Short_t, const StMcStripResponse_t* > stripMap,
                                                std::vector< StripWeightStruct_t >& stripsUsed ){
   Int_t ierr = kStOK;

   const StSimpleCluster_t *clusPtr = 0;

   std::map< Short_t, const StSimpleCluster_t* >::const_iterator clusMapIter;
   std::map< Short_t, const StMcStripResponse_t* >::const_iterator stripMapIter;

   // find the cluster pointers
   clusMapIter = clusMap.find( ID );
   if( clusMapIter != clusMap.end() )
      clusPtr = clusMapIter->second;

   if( !clusPtr ){
      LOG_ERROR << GetEventNumber() << " Error finding cluster with ID " << ID << endm;
      ierr = kStErr;
   };

   if( !ierr ){
      const TArrayS& mArray = clusPtr->getMemberArray();
      const TArrayF& wArray = clusPtr->getWeightArray();

      Int_t n = mArray.GetSize();
      if( n > wArray.GetSize() )
         n = wArray.GetSize();

      for( Int_t i=0; i<n; ++i ){
         stripMapIter = stripMap.find( kEEmcNumStrips*sector + mArray[i] );
         if( stripMapIter == stripMap.end() ){
            LOG_WARN << GetEventNumber() << " Error finding strip with index " << mArray[i] << " in sector " << sector << endm;
         } else {
            stripsUsed.push_back( StripWeightStruct_t( stripMapIter->second, wArray[i] ) );
         };
      };
   };

   return ierr;
};

Int_t StMcEEmcHitMakerStrips_t::includeWeightsFromLayer( const std::vector< StripWeightStruct_t >& usedStrips, std::map< Short_t, Float_t >& trackWeightMap ){
   Int_t ierr = kStOK;

   std::vector< StripWeightStruct_t >::const_iterator usedStripsIter;
   std::map< Short_t, Float_t >::iterator trackWeightMapIter;
   std::map< Int_t, StMcSimpleTrack_t* >::iterator trackMapIter;

   // iterate over strips used in this hit
   for( usedStripsIter = usedStrips.begin(); usedStripsIter != usedStrips.end(); ++usedStripsIter ){

      // get arrays of tracks contributing to energy in this strip
      const TArrayS& trackIdxArray = usedStripsIter->stripRespPtr->getTrackIdxArray();
      const TArrayF& trackWeightArray = usedStripsIter->stripRespPtr->getEnergyFromTrackArray();

      Int_t nTracks = trackIdxArray.GetSize();
      if( trackWeightArray.GetSize() < nTracks )
         nTracks = trackWeightArray.GetSize();

      // iterate over the tracks contributing to this strip
      for( Int_t j = 0; j < nTracks; ++j ){
         // additional contribution to the weight of this track
         Float_t w = trackWeightArray[j] * usedStripsIter->weight;
         Int_t trackKey = trackIdxArray[j];

         // make sure this is a valid track
         trackMapIter = mTrackMap.find( trackKey );
         if( trackMapIter == mTrackMap.end() )
            w = 0;

         //LOG_INFO << j << ' ' << trackWeightArray[j] << ' ' << usedStripsIter->weight << endm;

         if( w ){
            // check if track considered yet for this hit
            trackWeightMapIter = trackWeightMap.find( trackKey );
            if( trackWeightMapIter == trackWeightMap.end() ){
               trackWeightMap[ trackKey ] = w;
            } else {
               trackWeightMap[ trackKey ] += w;
            };
         };
      };
   };

   return ierr;
};

ClassImp( StMcEEmcHitMakerStrips_t );

/*
 * $Id: StMcEEmcHitMakerStrips.cxx,v 1.7 2011/12/13 21:32:27 sgliske Exp $
 * 
 * $Log: StMcEEmcHitMakerStrips.cxx,v $
 * Revision 1.7  2011/12/13 21:32:27  sgliske
 * Bug fix: now ensure clusters have unique IDs across sectors and layers.
 * Otherwise, StMcHitMakerStrips has errors.
 * Few other small updates also included in this checkin.
 *
 * Revision 1.6  2011/12/06 22:36:36  sgliske
 * update
 *
 * Revision 1.5  2011/11/18 01:47:03  sgliske
 * today
 *
 * Revision 1.4  2011/11/11 21:28:27  sgliske
 * daily update
 *
 * Revision 1.3  2011/11/08 22:22:15  sgliske
 * daily update
 *
 * Revision 1.2  2011/10/24 21:49:39  sgliske
 * updates, working on reading MC code
 *
 * Revision 1.1  2011/08/18 15:48:38  sgliske
 * update
 *
 *
 *
 */
@


1.7
log
@Bug fix: now ensure clusters have unique IDs across sectors and layers.
Otherwise, StMcHitMakerStrips has errors.
Few other small updates also included in this checkin.
@
text
@d307 1
a307 1
 * $Id: StMcEEmcHitMakerStrips.cxx,v 1.6 2011/12/06 22:36:36 sgliske Exp $
d310 5
@


1.6
log
@update
@
text
@d11 1
d104 4
d307 1
a307 1
 * $Id: StMcEEmcHitMakerStrips.cxx,v 1.5 2011/11/18 01:47:03 sgliske Exp $
d310 3
@


1.5
log
@today
@
text
@d59 1
a59 1
            LOG_INFO << "track " << i << ", E = " << mcTrackPtr->getEnergy() << ", PID = " << mcTrackPtr->getGeantId() << ", " << mcTrackPtr->getPdgId() << endm;
d93 1
a93 1
            LOG_INFO << mcStripRespPtr->getSector() << ' ' << mcStripRespPtr->getPlane() << ' ' << mcStripRespPtr->getIdx() << ' ' << mcStripRespPtr->getEnergy() << endm;
d98 1
a98 1
               LOG_INFO << "\t" << trIdxArr[i] << ' ' << trEnArr[i] << endm;
d302 1
a302 1
 * $Id: StMcEEmcHitMakerStrips.cxx,v 1.4 2011/11/11 21:28:27 sgliske Exp $
d305 3
@


1.4
log
@daily update
@
text
@d10 1
d50 8
d59 5
a63 11
   // debug
   {
      TClonesArray *trackArrPtr = mMcResponsePtr->getMcTrackArrayPtr();
      if( trackArrPtr ){
         TClonesArray &trackArr = *trackArrPtr;

         for( Int_t i=0; i<trackArr.GetEntriesFast(); ++i ){
            StMcSimpleTrack_t *mcTrackPtr = static_cast< StMcSimpleTrack_t* >( trackArr[i] );
            if( mcTrackPtr ){
               LOG_INFO << "track " << i << ", E = " << mcTrackPtr->getEnergy() << ", PID = " << mcTrackPtr->getGeantId() << ", " << mcTrackPtr->getPdgId() << endm;
            };
a66 1
#endif
d68 2
d186 1
d188 4
d198 1
a198 1

d200 1
d258 1
d277 5
d302 1
a302 1
 * $Id: StMcEEmcHitMakerStrips.cxx,v 1.3 2011/11/08 22:22:15 sgliske Exp $
d305 3
@


1.3
log
@daily update
@
text
@d181 2
a182 1
         LOG_INFO << "Event " << GetEventNumber() << ", hit " << hitIter->getID() << ", nMcTracks = " << trackWeightMap.size() << endm;
d286 1
a286 1
 * $Id: StMcEEmcHitMakerStrips.cxx,v 1.2 2011/10/24 21:49:39 sgliske Exp $
d289 3
@


1.2
log
@updates, working on reading MC code
@
text
@d9 2
d49 17
d85 15
d181 1
a181 1
         //LOG_INFO << "Event " << GetEventNumber() << ", hit " << hitIter->getID() << endm;
d189 1
a189 1
            //LOG_INFO << "\t" << trackIdxArray[i] << ' ' << trackWeightArray[i] << endl;
d285 1
a285 1
 * $Id: StMcEEmcHitMakerStrips.cxx,v 1.1 2011/08/18 15:48:38 sgliske Exp $
d288 3
@


1.1
log
@update
@
text
@d119 6
d129 8
a136 1
            totalWeight += trackWeightMapIter->second;
d147 2
d154 2
d215 1
a215 1
   for( usedStripsIter = usedStrips.begin(); usedStripsIter == usedStrips.end(); ++usedStripsIter ){
d231 2
d251 1
a251 1
 * $Id: $
d253 4
a256 1
 * $Log: $
@

