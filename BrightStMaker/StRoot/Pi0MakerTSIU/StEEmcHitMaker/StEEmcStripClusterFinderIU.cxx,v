head	1.12;
access;
symbols
	response:1.10;
locks; strict;
comment	@// @;


1.12
date	2012.11.26.19.40.35;	author sgliske;	state dead;
branches;
next	1.11;

1.11
date	2012.05.17.22.47.02;	author sgliske;	state Exp;
branches;
next	1.10;

1.10
date	2011.12.13.22.05.31;	author sgliske;	state Exp;
branches;
next	1.9;

1.9
date	2011.12.13.21.32.27;	author sgliske;	state Exp;
branches;
next	1.8;

1.8
date	2011.08.05.15.51.28;	author sgliske;	state Exp;
branches;
next	1.7;

1.7
date	2011.08.05.13.52.35;	author sgliske;	state Exp;
branches;
next	1.6;

1.6
date	2011.08.03.22.16.53;	author sgliske;	state Exp;
branches;
next	1.5;

1.5
date	2011.08.02.16.52.02;	author sgliske;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.20.21.35.26;	author sgliske;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.12.14.13.16;	author sgliske;	state Exp;
branches;
next	1.2;

1.2
date	2011.07.11.15.14.31;	author sgliske;	state Exp;
branches;
next	1.1;

1.1
date	2011.07.05.21.48.19;	author sgliske;	state Exp;
branches;
next	;


desc
@@


1.12
log
@moved to official StEEmcPool
@
text
@/*!
 * \class StripClusterFinderIU_t
 * \author Stephen Gliske <sgliske@@anl.gov>
 *
 * See description in the header file StripClusterFinderIU.h
*/

#include <algorithm>

#include <Rtypes.h>
#include <TMath.h>
#include <TArrayS.h>
#include <TArrayF.h>

#include "StRoot/St_base/StMessMgr.h"
#include "StRoot/St_base/Stypes.h"

#include "StRoot/StEEmcPool/EEmcTreeContainers/EEmcEnergy.h"

#include "StEEmcStripClusterFinderIU.h"
#include "StSimpleCluster.h"
#include "StFinderAlg.h"

/// constructor
StEEmcStripClusterFinderIU_t::StEEmcStripClusterFinderIU_t() : StEEmcStripClusterFinder_t(),
                                                               mIgnoreCorners( true ),
                                                               mUseNaiveFloorShape( true ),
                                                               mApplyClusterSplitting( 1 ),
                                                               mMaxExtent( 3 ),
                                                               mMinStripsPerCluster( 3 ),
                                                               mMinSeedDistance( 3 ),
                                                               mSeedFloor( 2.0 ),
                                                               mNeedsToBeCleared( 1 )
{
   mSeedEnergyThres[ U_LAYER ] = 0.003;
   mSeedEnergyThres[ V_LAYER ] = 0.003;
   mLayer = U_LAYER;
   mSector = 0;
   mIsReady = 1;
};

void StEEmcStripClusterFinderIU_t::setMaxExtent( Int_t maxExtent ){
   mMaxExtent = maxExtent;

   if( mMaxExtent < 3 ){
      LOG_WARN << "StEEmcStripClusterFinderIU_t::setMaxExtent" << endm;
      LOG_WARN << "\t maxExtent must be >= 2, not " << maxExtent << endm;
      LOG_WARN << "\t defaulting to minimum: maxExtent = 2" << endm;
      maxExtent = 2;
   };
};

void StEEmcStripClusterFinderIU_t::setMinStripsPerCluster( Int_t min ){
   mMinStripsPerCluster = min;

   if( mMinStripsPerCluster < 2 ){
      LOG_WARN << "StEEmcStripClusterFinderIU_t::setMinStripsPerCluster" << endm;
      LOG_WARN << "\t MinStripsPerCluster must be >= 1, not " << mMinStripsPerCluster << endm;
      LOG_WARN << "\t setting to default value of 3" << endm;
      mMinStripsPerCluster = 3;
   };
};

void StEEmcStripClusterFinderIU_t::clear(){
   // don't waste time if clear isn't needed
   if( mNeedsToBeCleared ){
      // reset array for keeping track of strips not in clusters
      // negative flags that ID is invalid---but make sure IDs are still unique
      for( Int_t i = 0; i < kEEmcNumStrips; ++i ){
         mClosestClusterIDForEachStrip[i] = -i-1;
         mFirstClusterIDForEachStrip[i] = -i-1;
      };

      // clear seed floor array
      for( Float_t *f_ptr = mSeedFloorArray; f_ptr != mSeedFloorArray + kEEmcNumStrips; ++f_ptr )
         (*f_ptr) = 0;

      mNeedsToBeCleared = 0;
   };
};

/// find some clusters
Int_t StEEmcStripClusterFinderIU_t::find( const ESmdLayer_t& stripArray, StSimpleClusterVec_t& clusterVec ){

   if( mNeedsToBeCleared ){
      // forgot to clear it, so do it now
      clear();
   };

   //LOG_INFO << "********** StEEmcStripClusterFinderIU_t::find(...) **********" << endm;

   // just return if no hit strips, or if not enough strips to form a cluster
   if( stripArray.nStrips < mMinStripsPerCluster )
      return kStOK;

   // ensure cleared
   clear();

   double floorParam1 = 0;
   double floorParam2 = 0;

   if( mSector == 0 || mSector == 3 || mSector == 6 || mSector == 9 ){
      if( mLayer == U_LAYER ){
         floorParam1=0.4;
         floorParam2=0.2;
      } else {
         floorParam1=0.2;
         floorParam2=0.1;
      };
   } else {
      if( mLayer == U_LAYER ){
         floorParam1=0.2;
         floorParam2=0.1;
      } else {
         floorParam1=0.4;
         floorParam2=0.2;
      };
   };

   // Note: for MC data, Weihong used fixed values for all layers and sectors
   //    floorParam1=0.2;
   //    floorParam2=0.1;

   // flag that will need to clear again after this function call
   mNeedsToBeCleared = 1;

   // container for seeds
   // important that this contains pointers, not copies
   vector< const EEmcElement_t* > seedStrips;

   // set all hit strip points

   // iterate over strips to find seeds

   // Note: only iterates between 3 and 283, as per Weihong's code.   He stated this was removing the "corners" but it only removes 2 of the 4 corners.
   // It should also depend on the sector and u/v layer.
   Int_t index = 3;
   for( const EEmcElement_t *strip = &stripArray.strip[index]; strip != &stripArray.strip[283]; ++strip, ++index ){

      // determine energy threshold as the sum of the floor plus the
      // overall threshold
      Float_t threshold = mSeedEnergyThres[ mLayer ];
      if( mSeedFloor )
         threshold += mSeedFloor*mSeedFloorArray[ index ];
      //LOG_INFO << "------> threshold = " << threshold << endm;

      // check cuts
      if( !strip->fail && strip->energy > threshold ){
         // strip passes as a seed, so add to the list
         seedStrips.push_back( strip );

         //LOG_INFO << "-----> seed strip index = " << hitStripIter->index() << ", energy = " << hitStripIter->energy() << " <-----" << endm;

         // also increase floor for other strips
         if( mUseNaiveFloorShape ){
            // the not "LOOSE_CUTS" version

            for ( Int_t i = 0; i < 288; ++i ){
               Int_t delta = (i > index ? i-index : index-i);

               /// Within +/- 2 strips, find no other seeds
               if( delta < 3 )
                  mSeedFloorArray[i] += strip->energy;

               /// Within +/- 4 strips, Floor is 20 or 40% of seed
               if( delta >= 3 && delta < 5 )
                  mSeedFloorArray[i] += floorParam1*strip->energy;

               /// Within +/- 10 strips, Floor is 10 or 20% of seed
               if( delta >= 5 && delta < 11 )
                  mSeedFloorArray[i] += floorParam2*strip->energy;

               /// Within +/- 20 strips, floor is 5% of seed
               if( delta >= 11 && delta < 21 )
                  mSeedFloorArray[i] += 0.05*strip->energy;
            };

         } else {
            // the "LOOSE_CUTS" version

            Int_t imin = ( index -6  < 0              ? 0              : index - 6 );
            Int_t imax = ( index + 6 > kEEmcNumStrips ? kEEmcNumStrips : index + 6 );

            for( Int_t i = imin; i <= imax; ++i ){
               // "Within +/- 6 strips, Floor is (at least) 5% of seed"
               // Note: if threshold already above, then don't add to it
               if ( TMath::Abs(index-i) < 7 ) 
                  if ( 0.05*strip->energy > mSeedFloorArray[i] )
                     mSeedFloorArray[i] += 0.05*strip->energy;
            };

         };
         // end if statement for whether to keep
      };
      // end of iteration over strips
   };

   // note: since mMaxExtent is fixed, then any one given strip can be
   // in at most two clusters.  Also, a cluster cannot overlap with
   // more than one other cluster on each side.

   //LOG_INFO << "-----> Iterating over seeds (" << seedStrips.size() << ") to find clusters <-----" << endm;

   // sort seeds in decending order by energy
   std::sort( seedStrips.begin(), seedStrips.end(), energyGreaterThan );

   // iterate over seeds to define clusters.
   vector< const EEmcElement_t* >::iterator seedStripIter = seedStrips.begin();
   for( ; seedStripIter != seedStrips.end(); ++seedStripIter ){
      Int_t index = static_cast< Int_t >( (*seedStripIter) - stripArray.strip );

      Bool_t ok_seed = 1;

      //LOG_INFO << "VVV index " << index << " already in a cluster.  Closest is " <<  mClosestClusterIDForEachStrip[ index ] << endm;

      // if seed already in a different strip, make sure it is at least
      // so many strips apart.
      if( mClosestClusterIDForEachStrip[ index ] > -1 ){

         // find the cluster to get its seed
         Bool_t found = 0;
         ok_seed = 0;
         Int_t i = -1;

         while( i < (Int_t)clusterVec.size() - 1 && !found ){
            found = (clusterVec[++i].getID() == mClosestClusterIDForEachStrip[ index ] );
            //LOG_INFO << "vvv a) " << clusterVec[i].getID() << ' ' << clusterVec[i].getSeedMember() << endm;
         };

         // sanity check
         if( !found ){
            LOG_WARN << "a) Error finding cluster with ID " << mClosestClusterIDForEachStrip[ index ] << endm;
         } else {
            Int_t delta = TMath::Abs( index - clusterVec[i].getSeedMember() );
            ok_seed = ( delta > mMinSeedDistance );
            //LOG_INFO << "Seed " << index << " already in cluster " << i << ", delta = |" << index << " - " << clusterVec[i].getSeedMember() << "| = " << delta << endm;
            //LOG_INFO << clusterVec[i] << endm;

            if( clusterVec[i].getSeedIdx() > 10 ){
               LOG_FATAL << "Something wierd is going on" << endm;
               return kStFatal;
            };
         };
      };

      // passes critereon
      if( ok_seed ){

         //LOG_INFO << "-----> clus w/ seed index = " << (*seedStripIter)->index() << ", energy = " << (*seedStripIter)->energy() << " <-----" << endm;

         // range of strips to include
         Int_t max = index + mMaxExtent;
         Int_t min = index - mMaxExtent;

         // check range
         if( min < 0 )
            min = 0;
         if( max > kEEmcNumStrips )
            max = kEEmcNumStrips;

         // number of strips in the cluster
         Int_t nStripsInClus = 0;

         // count how many strips actually in the cluster
         for( Int_t i = min; i <= max; ++i )
            if( stripArray.strip[i].energy && !stripArray.strip[i].fail )
               ++nStripsInClus;

         // check if enough
         if( nStripsInClus >= mMinStripsPerCluster ){

            // make a new cluster
            clusterVec.push_back( StSimpleCluster_t( ++mLastClusterID ) );

            //LOG_INFO << "vvv new " << clusterVec.back().getID() << ' ' << clusterVec.back().getSeedMember() << endm;

            // get reference to the cluster.  Note: important to use
            // reference not copy constuctor in all the following places
            // references occur
            StSimpleCluster_t &cluster = clusterVec.back();

            // nominal value for the moment
            cluster.setEnergy( -999 );

            // get reference to the arrays and set the size
            TArrayS &member = cluster.getMemberArray();
            TArrayF &weight = cluster.getWeightArray();
            member.Set( nStripsInClus );
            weight.Set( nStripsInClus );

            // keep track of position in member
            Int_t member_idx = -1;

            // add the seed as the first strip (needed for splitting)
            member[ ++member_idx ] = index;
            weight[ member_idx ] = 1;
            cluster.setSeedIdx( 0 );  // member_idx == 0 at this point

            //LOG_INFO << "-----> new cluster: " << cluster << endm;

            // iterate over strips in the cluster.
            // save the index, but don't include the seed twice.
            // also add to mClosestClusterIDForEachStrip
            for( Int_t i = min; i <= max; ++i ){
               // check that index doesn't equal that for the seed.
               // Also check that the strip was really hit
               if( i != index && stripArray.strip[i].energy > 0 && !stripArray.strip[i].fail ){

                  //LOG_INFO << "www " << member_idx + 1 << ' ' << nStripsInClus << ' ' << member.GetSize() << endm;

                   member[ ++member_idx ] = i;
                   weight[ member_idx ] = 1;

                   //LOG_INFO << "www" << endm;

                   //LOG_INFO << "first cluster for index " << i << " is " << mFirstClusterIDForEachStrip[ i ] << endm;

                   if( mFirstClusterIDForEachStrip[ i ] < 0 ){
                      // this is the first one, so set is also the closest
                      mFirstClusterIDForEachStrip[ i ] = cluster.getID();
                      mClosestClusterIDForEachStrip[ i ] = cluster.getID();
                   } else {
                      // Not the first one--check to see if this clusters is "closer" than the previous closest cluster.
                      // Note: any strip can be in at most two clusters if min seed distance == max extent

                      // find other cluster
                      Bool_t found = 0;
                      Int_t j = -1;
                      while( j < (Int_t)clusterVec.size() - 1 && !found )
                         found = (clusterVec[++j].getID() == mClosestClusterIDForEachStrip[ i ] );

                      // sanity check
                      if( !found ){
                         LOG_WARN << "b) Error finding cluster with ID " << mClosestClusterIDForEachStrip[ i ] << endm;

                         // default to using the new one, since the previous cluster not found
                         mClosestClusterIDForEachStrip[ i ] = cluster.getID();
                      } else {
                         Int_t delta_other = TMath::Abs( i - clusterVec[j].getSeedMember() );
                         Int_t delta_this = TMath::Abs( i - cluster.getSeedMember() );

                         if( delta_this < delta_other ){
                            // switch to this one
                            mClosestClusterIDForEachStrip[ i ] = cluster.getID();
                         };
                      };
                   };

                   //LOG_INFO << "vvv closest cluster for strip " << i << " ID = " << mClosestClusterIDForEachStrip[ i ] << endm;
               };
            };
            //LOG_INFO << "VVV a)" << endm;
         };
         // end check that seed is far enough away from other seeds
         //LOG_INFO << "VVV b)" << endm;
      };
      // end loop over all possible seeds
      //LOG_INFO << "VVV c)" << endm;
   };

   //LOG_INFO << "VVV d)" << endm;

   if( mApplyClusterSplitting ){

      //LOG_INFO << "-----> Applying cluster splitting <-----" << endm;

      // iterate over clusters
      StSimpleClusterVec_t::iterator clusIter1 = clusterVec.begin();
      StSimpleClusterVec_t::iterator clusIter2;

      for( clusIter1 = clusterVec.begin(); clusIter1 != clusterVec.end(); ++clusIter1 ){
         for( clusIter2 = clusterVec.begin(); clusIter2 < clusIter1; ++clusIter2 ){

            // make some pointers for the two clusters to make the
            // code simpler.
            StSimpleCluster_t *rightClusPtr = &(*clusIter1);
            StSimpleCluster_t *leftClusPtr = &(*clusIter2);

            // set it so that the index of left is less than the index of right
            if( leftClusPtr->getSeedMember() > rightClusPtr->getSeedMember() ){
               // switch
               rightClusPtr = &(*clusIter2);
               leftClusPtr = &(*clusIter1); 
            };

            // check to see how close they are
            if( rightClusPtr->getSeedMember() - leftClusPtr->getSeedMember() <= 2*mMaxExtent ){
               // are overlapping, do energy sharing

               // make copies of the indices for the seeds
               Int_t leftSeedIdx = leftClusPtr->getSeedMember();
               Int_t rightSeedIdx = rightClusPtr->getSeedMember();

               // Energy on the outside halves of both strips.  Note:
               // Weihong calls leftEnergy and rightEnergy,
               // respectively, EI and EII.  Both are intialized to
               // the seed energy
               Float_t leftEnergy = stripArray.strip[ leftSeedIdx ].energy;
               Float_t rightEnergy = stripArray.strip[ rightSeedIdx ].energy;

               //LOG_INFO << "VVV e)" << endm;

               // Compute energy on the left hand side of the left cluster.
               // Note: start at 1 so don't count seed twice.
               // todo: could do a sanity check on temp_index
               {
                  TArrayS leftMember = leftClusPtr->getMemberArray();
                  Int_t i = 1;
                  for( Int_t tempIdx = leftMember[ i ]; tempIdx < leftSeedIdx && i < leftMember.GetSize()-1; tempIdx = leftMember[++i] )
                     leftEnergy += stripArray.strip[ tempIdx ].energy;
               };

               //LOG_INFO << "VVV f)" << endm;

               // Compute energy on the right hand side of the right cluster.
               {
                  TArrayS rightMember = rightClusPtr->getMemberArray();
                  Int_t i =  rightMember.GetSize()-1;
                  for( Int_t tempIdx = rightMember[ i ]; tempIdx > rightSeedIdx && i >-1; tempIdx = rightMember[--i] )
                     rightEnergy += stripArray.strip[ tempIdx ].energy;
               };

               //LOG_INFO << "VVV g)" << endm;


               //LOG_INFO << "fff " << leftEnergy << ' ' << rightEnergy << endm;

               // now that we know the energies, need to adjust
               // weights for each of the strips that are in both
               // clusters

               // for simplicity, now want pointers to the cluster
               // according to which energy of the seeds is higher or lower
               StSimpleCluster_t *lowerClusPtr = &(*clusIter1);
               StSimpleCluster_t *higherClusPtr = &(*clusIter2);

               // this probably just a sanity check, as the seeds were
               // ordered according to energy
               if( stripArray.strip[ lowerClusPtr->getSeedMember() ].energy > 
                   stripArray.strip[ higherClusPtr->getSeedMember() ].energy ){

                  // switch
                  higherClusPtr = &(*clusIter2);
                  lowerClusPtr = &(*clusIter1); 
               };

               // get references to (not copies of) arrays.
               TArrayS &lowerMemberArray = lowerClusPtr->getMemberArray();
               TArrayF &lowerWeightArray = lowerClusPtr->getWeightArray();
               TArrayS &higherMemberArray = higherClusPtr->getMemberArray();
               TArrayF &higherWeightArray = higherClusPtr->getWeightArray();

               // precompute weights
               Float_t sumOfEnergy = leftEnergy + rightEnergy;
               Float_t lowerWeight =  ( lowerClusPtr == leftClusPtr ?  leftEnergy : rightEnergy ) / sumOfEnergy;
               Float_t higherWeight = ( lowerClusPtr == leftClusPtr ? rightEnergy :  leftEnergy ) / sumOfEnergy;

               //LOG_INFO << "VVV f)" << endm;

               // iterate over strips in the cluster with lower seed energy.
               for( Int_t i=0; i<lowerMemberArray.GetSize(); ++i ){
                  //LOG_INFO << "Lower member " << i << ", index " << lowerMemberArray[i] << endm;

                  // check if shares with the other cluster
                  if( mFirstClusterIDForEachStrip[ lowerMemberArray[i] ] == higherClusPtr->getID() ){
                     // adjust weight
                     lowerWeightArray[i] = lowerWeight;

                     // reset the "first" cluster for the strip to be this cluster
                     // as a flag for the other cluster
                     mFirstClusterIDForEachStrip[ lowerMemberArray[i] ] = lowerClusPtr->getID();
                  };

                  //LOG_INFO << "fff --> L index " << lowerMemberArray[i] << " setting weight to " << lowerWeightArray[i] << endm;
               };

               //LOG_INFO << "VVV g)" << endm;

               // iterate over strips in the cluster with the higher seed energy
               for( Int_t i=0; i<higherMemberArray.GetSize(); ++i ){
                  //LOG_INFO << "Higher member " << i << ", index " << lowerMemberArray[i] << endm;

                  // check if shares with the other cluster
                  if( mFirstClusterIDForEachStrip[ higherMemberArray[i] ] == lowerClusPtr->getID() ){
                     // adjust weight
                     higherWeightArray[i] = higherWeight;

                     // reset the "first" cluster for the strip back to the real "first"
                     mFirstClusterIDForEachStrip[ higherMemberArray[i] ] = higherClusPtr->getID();
                  };

                  //LOG_INFO << "fff --> H index " << higherMemberArray[i] << " setting weight to " << higherWeightArray[i] << endm;

               };
               // end check whether seed strips are close enough to cause clusters to overlap

               //LOG_INFO << "VVV f)" << endm;

            };
            // end inner loop over clusters
         };
         // end outer loop over clusters
      };
      // end check whether to apply energy splitting
   };

   //LOG_INFO << "VVV g)" << endm;


   //LOG_INFO << "-----> Computing SMD energy per cluster <-----" << endm;

   // compute energy and mean per cluster
   StSimpleClusterVec_t::iterator clusIter = clusterVec.begin();

   Int_t ierr = kStOK;
   for( clusIter = clusterVec.begin(); clusIter != clusterVec.end() && !ierr; ++clusIter ){

      Float_t E = 0;
      Float_t mean = 0;

      TArrayS &memberArray = clusIter->getMemberArray();
      TArrayF &weightArray = clusIter->getWeightArray();

      if( memberArray.GetSize() != weightArray.GetSize() ){
         LOG_FATAL << "SANITY CHECK FAILURE IN StEEmcStripClusterFinderIU.cxx, line " << __LINE__ << endm;
         ierr = kStFatal;
      };

      //LOG_INFO << "ggg Cluster with seed " << clusIter->getSeedMember() << endm;

      if( !ierr )
         for( Int_t i = 0; i < memberArray.GetSize(); ++i ){
            Float_t stripE = stripArray.strip[ memberArray[ i ] ].energy;
            if( stripE > 0 && !stripArray.strip[ memberArray[ i ] ].fail ){

               Float_t thisE = weightArray[i]*stripE;
               E += thisE;
               mean += memberArray[i] * thisE;

               //LOG_INFO << "ggg " <<  mStripPtrArray[ memberArray[i ] ]->index()
               //         << " E += " << weightArray[i] << " * " << mStripPtrArray[ memberArray[ i ] ]->energy()
               //         << " = " << weightArray[i]*mStripPtrArray[ memberArray[ i ] ]->energy() << endm;
            };
         };
      clusIter->setEnergy( E );
      clusIter->setMeanX( E > 0 ? mean/E : memberArray[ 0 ] + 0.5 );

      //LOG_INFO << "-----> layer = " << mLayer << ", SMD cluster: " << *clusIter << endm;
   };

   return kStOK;
};

Bool_t StEEmcStripClusterFinderIU_t::energyGreaterThan( const EEmcElement_t *s1, const EEmcElement_t *s2 ){
   return s1->energy > s2->energy;
};

ClassImp( StEEmcStripClusterFinderIU_t );

/*
 *  $Id: StEEmcStripClusterFinderIU.cxx,v 1.11 2012/05/17 22:47:02 sgliske Exp $
 *
 * $Log: StEEmcStripClusterFinderIU.cxx,v $
 * Revision 1.11  2012/05/17 22:47:02  sgliske
 * working on switching to EEmcTree containers
 *
 * Revision 1.10  2011/12/13 22:05:31  sgliske
 * Removed unused variable so compiles with no warning
 *
 * Revision 1.9  2011/12/13 21:32:27  sgliske
 * Bug fix: now ensure clusters have unique IDs across sectors and layers.
 * Otherwise, StMcHitMakerStrips has errors.
 * Few other small updates also included in this checkin.
 *
 * Revision 1.8  2011/08/05 15:51:28  sgliske
 * bug fix
 *
 * Revision 1.7  2011/08/05 13:52:35  sgliske
 * cross check complete
 *
 * Revision 1.6  2011/08/03 22:16:53  sgliske
 * still debugging
 *
 * Revision 1.5  2011/08/02 16:52:02  sgliske
 * debugging
 *
 * Revision 1.4  2011/07/20 21:35:26  sgliske
 * update
 *
 * Revision 1.3  2011/07/12 14:13:16  sgliske
 * update
 *
 * Revision 1.2  2011/07/11 15:14:31  sgliske
 * before making StHitData class
 *
 * Revision 1.1  2011/07/05 21:48:19  sgliske
 * split from StEEmcAnalysisTreeMaker
 *
 * Revision 1.3  2011/06/29 16:37:59  sgliske
 * update
 *
 * Revision 1.2  2011/06/24 17:32:33  sgliske
 * Everything now compiles using cons
 *
 * Revision 1.1  2011/06/23 21:55:05  sgliske
 * daily update
 *
 */
@


1.11
log
@working on switching to EEmcTree containers
@
text
@d561 1
a561 1
 *  $Id: StEEmcStripClusterFinderIU.cxx,v 1.10 2011/12/13 22:05:31 sgliske Exp $
d564 3
@


1.10
log
@Removed unused variable so compiles with no warning
@
text
@d17 2
a18 1
#include "StRoot/StEEmcPool/StEEmcA2EMaker/StEEmcStrip.h"
a77 4
      // clear array of strip pointers
      for( const StEEmcStrip **s_ptr = mStripPtrArray; s_ptr != mStripPtrArray + kEEmcNumStrips; ++s_ptr )
         (*s_ptr) = 0;

d83 1
a83 1
Int_t StEEmcStripClusterFinderIU_t::find( const StEEmcStripVec_t& hitStripIn, StSimpleClusterVec_t& clusterVec ){
d93 1
a93 1
   if( hitStripIn.size() < static_cast< UInt_t >( mMinStripsPerCluster ) )
d129 1
a129 1
   vector< const StEEmcStrip* > seedStrips;
d131 1
a131 2
   // copy the vector, so that it can be sorted
   StEEmcStripVec_t hitStrip( hitStripIn );
d133 1
a133 11
//    for( UInt_t i=0; i<hitStrip.size(); ++i ){
//       //LOG_INFO << "zz> " << hitStrip[i].index() << ' ' << hitStrip[i].energy() << endm;
//    };

    // Sort by energy
   std::sort( hitStrip.begin(), hitStrip.end(), &StEEmcStripClusterFinderIU_t::energyLessThan );

   // Order in descending energy
   std::reverse( hitStrip.begin(), hitStrip.end() );

   //LOG_INFO << "Iterating over (" << hitStrip.size() << ") strips to find seeds in sector " << mSector << ", layer " << mLayer << " <-----" << endm;
d135 4
a138 34
//    if( !hitStrip.empty() ){
//       //LOG_INFO << "----------> energy of 1st strip is " << hitStrip[0].energy() << ", last strip " << hitStrip.back().energy() << ", thres is " << mSeedEnergyThres[ mLayer ] << endm;
//       for( UInt_t i=0; i<hitStrip.size() && i < 10; ++i ){
//          //LOG_INFO << "----------> energy of strip " << i << " is " << hitStrip[i].energy() << endm;
//       };
//    };

// set all hit strip points

   // fill the array of hit strips
   StEEmcStripVec_t::const_iterator hitStripIter = hitStrip.begin();
   for( hitStripIter = hitStrip.begin(); hitStripIter != hitStrip.end(); ++hitStripIter )
      if( !hitStripIter->fail()  )
         mStripPtrArray[ hitStripIter->index() ] = &(*hitStripIter);

   // iterate over strips to find seeds
   for( hitStripIter = hitStrip.begin(); hitStripIter->energy() > mSeedEnergyThres[ mLayer ] &&
           hitStripIter != hitStrip.end(); ++hitStripIter ){
      // apply cuts to whether to keep the tower as a seed
      Bool_t keep = 1;

      keep &= !(hitStripIter->fail());

      //LOG_INFO << "-----> hit strip index = " << hitStripIter->index() << ", energy = " << hitStripIter->energy() << " <-----" << endm;

      // check for seeds near two of the four corners.  Note: the cut
      // on the upper edge should be adjusted based on sector number,
      // as the number of strips per sector is not consistant.
      // However, this is not done for the sake of consistancy, since
      // it was not done in Weihong's code.
      if( mIgnoreCorners ){
         keep &= ( hitStripIter->index() > 3 );
         keep &= ( hitStripIter->index() < 283 );
      };
d144 1
a144 2
         threshold += mSeedFloor*mSeedFloorArray[ hitStripIter->index() ];

d147 2
a148 7
      // make sure strip is above threshold
      keep &= ( hitStripIter->energy() > threshold );

      //LOG_INFO << "Seed " << hitStripIter->index() << ", E = " << hitStripIter->energy() << " vs " << threshold << " = "
      //<< mSeedFloor << "*" << mSeedFloorArray[ hitStripIter->index() ] << " + " << mSeedEnergyThres[ mLayer ] << endm;

      if( keep ){
d150 1
a150 1
         seedStrips.push_back( &(*hitStripIter) );
a154 3
         Int_t index = hitStripIter->index();
         Float_t energy = hitStripIter->energy();

d163 1
a163 1
                  mSeedFloorArray[i] += energy;
d167 1
a167 1
                  mSeedFloorArray[i] += floorParam1*energy;
d171 1
a171 1
                  mSeedFloorArray[i] += floorParam2*energy;
d175 1
a175 1
                  mSeedFloorArray[i] += 0.05*energy;
d188 2
a189 2
                  if ( 0.05*energy > mSeedFloorArray[i] )
                     mSeedFloorArray[i] += 0.05*energy;
d204 5
a208 3
   // iterate over seeds to define clusters.  Note: seeds still in
   // descending order
   vector< const StEEmcStrip* >::iterator seedStripIter = seedStrips.begin();
d210 1
a210 1
      Int_t index = (*seedStripIter)->index();
d266 1
a266 1
            if( mStripPtrArray[i] )
d307 2
a308 1
               if( i != index && mStripPtrArray[i] ){
d398 2
a399 2
               Float_t leftEnergy = (mStripPtrArray[ leftSeedIdx ] ? mStripPtrArray[ leftSeedIdx ]->energy() : 0);
               Float_t rightEnergy = (mStripPtrArray[ rightSeedIdx ] ? mStripPtrArray[ rightSeedIdx ]->energy() : 0);
d410 1
a410 1
                     leftEnergy += (mStripPtrArray[ tempIdx ] ? mStripPtrArray[ tempIdx ]->energy() : 0 );
d420 1
a420 1
                     rightEnergy += (mStripPtrArray[ tempIdx ] ? mStripPtrArray[ tempIdx ]->energy() : 0 );
d439 3
a441 2
               if( mStripPtrArray[ lowerClusPtr->getSeedMember() ]->energy() >
                   mStripPtrArray[ higherClusPtr->getSeedMember() ]->energy() ){
d532 5
a536 3
         for( Int_t i = 0; i < memberArray.GetSize(); ++i )
            if( mStripPtrArray[ memberArray[ i ] ] ){
               Float_t thisE = weightArray[i]*mStripPtrArray[ memberArray[ i ] ]->energy();
d538 1
a538 1
               mean += mStripPtrArray[ memberArray[ i ] ]->index() * thisE;
d544 1
d546 1
a546 1
      clusIter->setMeanX( (E > 0 ? mean/E : mStripPtrArray[ memberArray[ 0 ] ]->index() ) + 0.5 );
d554 2
a555 2
Bool_t StEEmcStripClusterFinderIU_t::energyLessThan( StEEmcStrip s1, StEEmcStrip s2 ){
   return s1.energy() < s2.energy();
d561 1
a561 1
 *  $Id: StEEmcStripClusterFinderIU.cxx,v 1.9 2011/12/13 21:32:27 sgliske Exp $
d564 3
@


1.9
log
@Bug fix: now ensure clusters have unique IDs across sectors and layers.
Otherwise, StMcHitMakerStrips has errors.
Few other small updates also included in this checkin.
@
text
@a129 4
   // ID of last cluster
   // note: -1 since no last cluster id
   Int_t lastClusterID = -1;

d607 1
a607 1
 *  $Id: StEEmcStripClusterFinderIU.cxx,v 1.8 2011/08/05 15:51:28 sgliske Exp $
d610 5
@


1.8
log
@bug fix
@
text
@d328 1
a328 1
            clusterVec.push_back( StSimpleCluster_t( ++lastClusterID ) );
d611 1
a611 1
 *  $Id: StEEmcStripClusterFinderIU.cxx,v 1.7 2011/08/05 13:52:35 sgliske Exp $
d614 3
@


1.7
log
@cross check complete
@
text
@d32 1
a32 1
                                                               mNeedsToBeCleared( 0 )
d269 2
d280 1
a280 1
         while( i < (Int_t)clusterVec.size() - 1 && !found )
d282 2
d330 2
d363 2
d368 2
d403 1
a403 1
                  //LOG_INFO << "first cluster for strip " << i << " ID = " << mClosestClusterIDForEachStrip[ i ] << endm;
d406 1
d409 1
d412 1
d415 2
d455 2
d463 1
a463 1
                  for( Int_t tempIdx = leftMember[ i ]; tempIdx < leftSeedIdx; tempIdx = leftMember[++i] )
d467 2
d473 1
a473 1
                  for( Int_t tempIdx = rightMember[ i ]; tempIdx > rightSeedIdx; tempIdx = rightMember[--i] )
d477 3
d511 2
d530 2
d549 3
d560 3
d611 1
a611 1
 *  $Id: StEEmcStripClusterFinderIU.cxx,v 1.6 2011/08/03 22:16:53 sgliske Exp $
d614 3
@


1.6
log
@still debugging
@
text
@d199 2
a200 1
      //LOG_INFO << "Seed " << hitStripIter->index() << ", E = " << hitStripIter->energy() << " vs " << threshold << " = " << mSeedFloor << "*" << mSeedFloorArray[ hitStripIter->index() ] << " + " << mSeedEnergyThres[ mLayer ] << endm;
d278 1
a278 1
         while( i < (Int_t)clusterVec.size() - 1 && !found ){
a279 2
            //LOG_INFO << i << ": " << clusterVec[i].getID() << " = " << mClosestClusterIDForEachStrip[ index ] << "? " << found << endm;
         };
d458 1
a458 1
               LOG_INFO << "fff " << leftEnergy << ' ' << rightEnergy << endm;
d503 1
a503 1
                  LOG_INFO << "fff --> L index " << lowerMemberArray[i] << " setting weight to " << lowerWeightArray[i] << endm;
d519 1
a519 1
                  LOG_INFO << "fff --> H index " << higherMemberArray[i] << " setting weight to " << higherWeightArray[i] << endm;
d550 1
a550 1
      LOG_INFO << "ggg Cluster with seed " << clusIter->getSeedMember() << endm;
d559 3
a561 3
               LOG_INFO << "ggg " <<  mStripPtrArray[ memberArray[i ] ]->index()
                        << " E += " << weightArray[i] << " * " << mStripPtrArray[ memberArray[ i ] ]->energy()
                        << " = " << weightArray[i]*mStripPtrArray[ memberArray[ i ] ]->energy() << endm;
d579 1
a579 1
 *  $Id: StEEmcStripClusterFinderIU.cxx,v 1.5 2011/08/02 16:52:02 sgliske Exp $
d582 3
@


1.5
log
@debugging
@
text
@d459 2
a498 2
                     //LOG_INFO << "--> L index " << lowerMemberArray[i] << " setting weight to " << lowerWeightArray[i] << endm;

d503 2
a515 2
                     //LOG_INFO << "--> H index " << higherMemberArray[i] << " setting weight to " << higherWeightArray[i] << endm;

d519 3
d534 1
a534 1
   // compute energy per cluster
d540 3
a542 1
      double E = 0;
d551 1
a551 1
      //LOG_INFO << "Cluster with seeds " << clusIter->getSeedMember() << endm;
d555 9
a563 4
            if( mStripPtrArray[ memberArray[ i ] ] )
               E += weightArray[i]*mStripPtrArray[ memberArray[ i ] ]->energy();
      //LOG_INFO << "E += " << weightArray[i] << " * " << mStripPtrArray[ memberArray[ i ] ]->energy() << " (" << mStripPtrArray[ memberArray[ i ] ]->index() << ") = " << E << endm;

d565 1
d580 1
a580 1
 *  $Id: StEEmcStripClusterFinderIU.cxx,v 1.4 2011/07/20 21:35:26 sgliske Exp $
d583 3
@


1.4
log
@update
@
text
@d26 2
a27 2
                                                               mUseNaiveFloorShape( false ),
                                                               mApplyClusterSplitting( 0 ),
d30 1
a30 1
                                                               mMinSeedDistance( 2 ),
d68 2
a69 1
      for( Int_t i = 0; i < kEEmcNumStrips; ++i )
d71 1
d81 1
d88 5
d151 1
a151 1
  //LOG_INFO << "Iterating over (" << hitStrip.size() << ") strips to find seeds in sector " << mSector << ", layer " << mLayer << " <-----" << endm;
d199 2
d205 1
a205 1
         //LOG_INFO << "-----> hit strip index = " << hitStripIter->index() << ", energy = " << hitStripIter->energy() << " <-----" << endm;
d233 1
d237 2
a238 2
            Int_t min = ( index -6  < 0              ? 0              : index - 6 );
            Int_t max = ( index + 6 > kEEmcNumStrips ? kEEmcNumStrips : index + 6 );
d240 1
a240 1
            for( Int_t i = min; i <= max; ++i ){
d247 1
d270 1
a270 1
      if( mFirstClusterIDForEachStrip[ index ] > -1 ){
d278 2
a279 2
            found = (clusterVec[++i].getID() == mFirstClusterIDForEachStrip[ index ] );
            //LOG_INFO << i << ": " << clusterVec[i].getID() << " = " << mFirstClusterIDForEachStrip[ index ] << "? " << found << endm;
d284 1
a284 1
            LOG_WARN << "a) Error finding cluster with ID " << mFirstClusterIDForEachStrip[ index ] << endm;
d301 1
a301 1
         //LOG_INFO << "-----> seed index = " << (*seedStripIter)->index() << ", energy = " << (*seedStripIter)->energy() << " <-----" << endm;
d353 1
a353 1
            // also add to mFirstClusterIDForEachStrip
d361 2
d364 1
a364 1
                      // this is the first one, so set it
d366 1
d368 2
a369 2
                      // set to which ever is closer, rather than the
                      // one that really was "first" in the energy order
d375 1
a375 1
                         found = (clusterVec[++j].getID() == mFirstClusterIDForEachStrip[ i ] );
d379 1
a379 1
                         LOG_WARN << "b) Error finding cluster with ID " << mFirstClusterIDForEachStrip[ i ] << endm;
d381 2
a382 2
                         // default to other value
                         mFirstClusterIDForEachStrip[ i ] = cluster.getID();
d387 1
a387 1
                         if( delta_other > delta_this ){
d389 1
a389 1
                            mFirstClusterIDForEachStrip[ i ] = cluster.getID();
d394 1
a394 1
                  //LOG_INFO << "first cluster for strip " << i << " ID = " << mFirstClusterIDForEachStrip[ i ] << endm;
d490 2
d497 2
d507 2
d514 2
d546 5
a550 3
      if( !ierr ){
         for( Int_t i = 0; i < memberArray.GetSize(); ++i ){
            if( mStripPtrArray[ memberArray[ i ] ] ){
d552 1
a552 3
            };
         };
      };
d555 2
d569 1
a569 1
 *  $Id: StEEmcStripClusterFinderIU.cxx,v 1.3 2011/07/12 14:13:16 sgliske Exp $
d572 3
@


1.3
log
@update
@
text
@d67 3
a69 3
      for( StSimpleCluster_t **cl_ptr = mFirstClusterForEachStrip;
           cl_ptr != mFirstClusterForEachStrip + kEEmcNumStrips; ++cl_ptr )
         (*cl_ptr) = 0;
d83 3
a85 1
Int_t StEEmcStripClusterFinderIU_t::find( const StEEmcStripVec_t& hitStrip, StSimpleClusterVec_t& clusterVec ){
d88 1
a88 1
   if( hitStrip.size() < static_cast< UInt_t >( mMinStripsPerCluster ) )
d130 7
d138 1
a138 1
   std::sort( seedStrips.begin(), seedStrips.end(), &StEEmcStripClusterFinderIU_t::seedEnergyLessThan );
d141 1
a141 1
   std::reverse( seedStrips.begin(), seedStrips.end() );
d143 16
a158 1
   //LOG_INFO << "----------> Iterating over strips to find seeds in sector " << mSector << ", layer " << mLayer << " <----------" << endm;
d161 2
a162 3
   StEEmcStripVec_t::const_iterator hitStrip_iter = hitStrip.begin();
   for( ; hitStrip_iter->energy() > mSeedEnergyThres[ mLayer ] &&
           hitStrip_iter != hitStrip.end(); ++hitStrip_iter ){
d166 1
a166 3
      keep &= !(hitStrip_iter->fail());

      //LOG_INFO << "----------> hit strip index = " << hitStrip_iter->index() << ", energy = " << hitStrip_iter->energy() << " <----------" << endm;
d168 1
a168 3
      // add into the array of hit strips
      if( keep )
         mStripPtrArray[ hitStrip_iter->index() ] = &(*hitStrip_iter);
d170 5
a174 1
      // check for seeds near two of the four corners
d176 2
a177 2
         keep &= ( hitStrip_iter->index() > 3 );
         keep &= ( hitStrip_iter->index() > 3 );
d184 3
a186 1
         threshold += mSeedFloor*mSeedFloorArray[ hitStrip_iter->index() ];
d189 1
a189 1
      keep &= ( hitStrip_iter->energy() > threshold );
d193 3
a195 1
         seedStrips.push_back( &(*hitStrip_iter) );
d198 2
a199 2
         Int_t index = hitStrip_iter->index();
         Float_t energy = hitStrip_iter->energy();
d246 1
a246 1
   //LOG_INFO << "----------> Iterating over seeds (" << seedStrips.size() << ") to find clusters <----------" << endm;
d250 3
a252 3
   vector< const StEEmcStrip* >::iterator seedStrip_iter = seedStrips.begin();
   for( ; seedStrip_iter != seedStrips.end(); ++seedStrip_iter ){
      Int_t index = (*seedStrip_iter)->index();
d258 26
a283 4
      if( mFirstClusterForEachStrip[ index ] ){
         Int_t index_for_other_seed = mFirstClusterForEachStrip[ index ]->getSeedMember();
         Int_t delta = TMath::Abs( index - index_for_other_seed );
         ok_seed = ( delta < mMinSeedDistance );
d288 3
d302 6
a307 1
         Int_t nStripsInClus = max - min + 1;
d320 3
d337 6
a342 3
            // iterate over strips in the cluster
            // save the index, but don't include the seed twice
            for( int i = min; i <= max; ++i ){
d346 34
a379 2
                  member[ ++member_idx ] = i;
                  weight[ member_idx ] = 1;
d390 1
a390 1
      //LOG_INFO << "----------> Applying cluster splitting <----------" << endm;
d393 2
a394 2
      StSimpleClusterVec_t::iterator clus_iter1 = clusterVec.begin();
      StSimpleClusterVec_t::iterator clus_iter2;
d396 2
a397 2
      for( clus_iter1 = clusterVec.begin(); clus_iter1 != clusterVec.end(); ++clus_iter1 ){
         for( clus_iter2 = clusterVec.begin(); clus_iter2 < clus_iter1; ++clus_iter2 ){
d401 2
a402 2
            StSimpleCluster_t *rightClusPtr = &(*clus_iter1);
            StSimpleCluster_t *leftClusPtr = &(*clus_iter2);
d407 2
a408 2
               rightClusPtr = &(*clus_iter2);
               leftClusPtr = &(*clus_iter1); 
d450 2
a451 2
               StSimpleCluster_t *lowerClusPtr = &(*clus_iter1);
               StSimpleCluster_t *higherClusPtr = &(*clus_iter2);
d458 2
a459 2
                  higherClusPtr = &(*clus_iter2);
                  lowerClusPtr = &(*clus_iter1); 
d476 1
a476 1
                  if( mFirstClusterForEachStrip[ lowerMemberArray[i] ] == higherClusPtr ){
d482 1
a482 1
                     mFirstClusterForEachStrip[ lowerMemberArray[i] ] = lowerClusPtr;
d489 1
a489 1
                  if( mFirstClusterForEachStrip[ higherMemberArray[i] ] == lowerClusPtr ){
d494 1
a494 1
                     mFirstClusterForEachStrip[ higherMemberArray[i] ] = higherClusPtr;
d506 1
a506 1
   //LOG_INFO << "----------> Computing SMD energy per cluster <----------" << endm;
d509 1
a509 1
   StSimpleClusterVec_t::iterator clus_iter = clusterVec.begin();
d512 1
a512 1
   for( clus_iter = clusterVec.begin(); clus_iter != clusterVec.end() && !ierr; ++clus_iter ){
d515 2
a516 2
      TArrayS &memberArray = clus_iter->getMemberArray();
      TArrayF &weightArray = clus_iter->getWeightArray();
d531 1
a531 1
      clus_iter->setEnergy( E );
d537 2
a538 2
Bool_t StEEmcStripClusterFinderIU_t::seedEnergyLessThan( const StEEmcStrip *s1, const StEEmcStrip *s2 ){
   return s1->energy() < s2->energy();
d544 1
a544 1
 *  $Id: StEEmcStripClusterFinderIU.cxx,v 1.2 2011/07/11 15:14:31 sgliske Exp $
d547 3
@


1.2
log
@before making StHitData class
@
text
@d85 2
a86 2
   // just return if no hit strips
   if( hitStrip.empty() )
a88 2
   LOG_INFO << "----------> Finding clusters in some SMD layer <----------" << endm;

d134 1
a134 1
   LOG_INFO << "----------> Iterating over strips to find seeds in sector " << mSector << ", layer " << mLayer << " <----------" << endm;
d145 1
a145 1
      LOG_INFO << "----------> hit strip index = " << hitStrip_iter->index() << ", energy = " << hitStrip_iter->energy() << " <----------" << endm;
d219 1
a219 1
   LOG_INFO << "----------> Iterating over seeds to find clusters <----------" << endm;
d229 1
a229 1
      // if seed already in a different strip, max sure it is at least
a238 1

d295 1
a295 1
      LOG_INFO << "----------> Applying cluster splitting <----------" << endm;
d328 2
a329 2
               Float_t leftEnergy = mStripPtrArray[ leftSeedIdx ]->energy();
               Float_t rightEnergy = mStripPtrArray[ rightSeedIdx ]->energy();
d338 1
a338 1
                     leftEnergy += mStripPtrArray[ tempIdx ]->energy();
d346 1
a346 1
                     rightEnergy += mStripPtrArray[ tempIdx ]->energy();
d411 1
a411 1
   LOG_INFO << "----------> Computing SMD energy per cluster <----------" << endm;
d424 1
a424 1
         LOG_FATAL << "SANITY CHECK FAILURE IN StEEmcStripClusterFinderIU.cxx, line " << __LINE__ << endl;
d430 3
a432 1
            E += weightArray[i]*mStripPtrArray[ memberArray[ i ] ]->energy();
a438 2
   LOG_INFO << "----------> Clustering done, found " << clusterVec.size() << " clusters <----------" << endm;

d449 1
a449 1
 *  $Id: StEEmcStripClusterFinderIU.cxx,v 1.1 2011/07/05 21:48:19 sgliske Exp $
d452 3
@


1.1
log
@split from StEEmcAnalysisTreeMaker
@
text
@d37 2
d84 7
d94 20
a113 2
   double floor_para1 = 0;
   double floor_para2 = 0;
d115 3
a117 3
   // need to program these values
   LOG_FATAL << "HAVE NOT YET PROGRAMMED 'floor_para1' or 'floor_para2'" << endm;
   return kStFatal;
d136 2
d147 2
d188 1
a188 1
                  mSeedFloorArray[i] += floor_para1*energy;
d192 1
a192 1
                  mSeedFloorArray[i] += floor_para2*energy;
d221 2
d297 3
d414 2
d440 2
d449 2
d452 1
a452 1
 *  $Id: StEEmcStripClusterFinderIU.cxx,v 1.3 2011/06/29 16:37:59 sgliske Exp $
d455 3
@

