head	1.22;
access;
symbols
	response:1.21;
locks; strict;
comment	@// @;


1.22
date	2012.10.09.03.57.20;	author sgliske;	state dead;
branches;
next	1.21;

1.21
date	2011.12.15.22.21.18;	author sgliske;	state Exp;
branches;
next	1.20;

1.20
date	2011.12.06.22.36.35;	author sgliske;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.30.23.03.14;	author sgliske;	state Exp;
branches;
next	1.18;

1.18
date	2011.11.28.16.52.23;	author sgliske;	state Exp;
branches;
next	1.17;

1.17
date	2011.11.23.17.55.44;	author sgliske;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.18.01.51.02;	author sgliske;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.18.01.47.03;	author sgliske;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.11.23.01.50;	author sgliske;	state Exp;
branches;
next	1.13;

1.13
date	2011.11.11.21.28.22;	author sgliske;	state Exp;
branches;
next	1.12;

1.12
date	2011.11.11.04.15.36;	author sgliske;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.10.23.33.33;	author sgliske;	state Exp;
branches;
next	1.10;

1.10
date	2011.11.09.23.12.32;	author sgliske;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.08.22.22.15;	author sgliske;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.07.22.08.04;	author sgliske;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.03.17.18.35;	author sgliske;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.03.17.12.59;	author sgliske;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.02.22.04.45;	author sgliske;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.02.20.54.24;	author sgliske;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.26.21.37.35;	author sgliske;	state Exp;
branches;
next	1.2;

1.2
date	2011.09.01.21.52.49;	author sgliske;	state Exp;
branches;
next	1.1;

1.1
date	2011.08.31.22.05.43;	author sgliske;	state Exp;
branches;
next	;


desc
@@


1.22
log
@removed unused makers
@
text
@/*!
 *
 * \class EEmcHitMakerAnlEM_t
 * \author Stephen Gliske <sgliske@@anl.gov>
 *
 * See header file for description.
 *
 */

#define DEBUG

/// Include Root headers
#include <TF1.h>
#include "assert.h"

/// Include StRoot headers
#include "StRoot/St_base/Stypes.h"
#include "StRoot/St_base/StMessMgr.h"
#include "StRoot/StEEmcPool/StEEmcGeoId/StEEmcGeoId.h"
#include "StRoot/StEEmcUtil/EEmcGeom/EEmcGeomDefs.h"
#include "StRoot/StEEmcUtil/StEEmcSmd/EEmcSmdGeom.h"
#include "StRoot/StEEmcPool/StEEmcPointMap/StEEmcPointMap.h"

/// Include related classes
#include "StEEmcHitMakerAnlEM.h"
#include "StEEmcAnlElement.h"
#include "StEEmcAnlHit.h"
#include "StSimpleCluster.h"
#include "StEEmcHit.h"
#include "StEEmcAnlShowerShapeModel.h"
#include "StEEmcAnlDistMatrixElement.h"
#include "StEEmcAnlDistMatrixPruner.h"
#include "StEEmcAnlSplitHitAlgo.h"

/// Construtor
StEEmcHitMakerAnlEM_t::StEEmcHitMakerAnlEM_t( const Char_t *myName,             // name of this maker in the StMaker hash table
                                              const Char_t *responseMakerName,  // name of the keeper in charge of the response
                                              StEEmcTowerClusterFinder_t* towerClusterFinder ) :
   StEEmcHitMaker_t(    myName, responseMakerName ),
   mTowerClusterFinder( towerClusterFinder ),
   mStripInclDist(10),
   mStripMinWeight(5e-4),
   mTowerInclDist(10),
   mTowerMinWeight(1e-3),
   mMinHitDist(2.5),
   mMinHitEtoSplit(1.0),
   mMaxIters(10),
   mMaxRenormIters(2),
   mMinIterSameNhits(10),
   mMinNumStripsPerLayer(5),
   mStripModelPtr(0),
   mTowerModelPtr(0) { /* */ };

/// Deconstructor
StEEmcHitMakerAnlEM_t::~StEEmcHitMakerAnlEM_t(){
   // nothing to do
};

/// Initialize
Int_t StEEmcHitMakerAnlEM_t::Init(){
   // set flags to correct data copied over in StEEmcHitMaker
   mDoClusterTower[ TOWER ] = 1;
   mDoClusterSMDStrips = 1;

   // init parent
   Int_t ierr = StEEmcHitMaker_t::Init();

   // just check pointers and functions, otherwise is ready
   if( !ierr && !mTowerClusterFinder ){
      LOG_FATAL << ClassName() << "::Init() -- null pointer for tower cluster finder" << endm;
      ierr = kStFatal;
   };
   if( !ierr && !mTowerClusterFinder->isReady() ){
      LOG_FATAL << ClassName() << "::Init() -- tower cluster finder not in ready state" << endm;
      ierr = kStFatal;
   };
   if( !ierr && !mTowerModelPtr ){
      LOG_FATAL << ClassName() << "::Init() -- mTowerModelPtr is null" << endl;
      ierr = kStFatal;
   };
   if( !ierr && !mStripModelPtr ){
      LOG_FATAL << ClassName() << "::Init() -- mStripModelPtr is null" << endl;
      ierr = kStFatal;
   };
   if( !ierr && !mHitSplitterPtr ){
      LOG_FATAL << ClassName() << "::Init() -- mHitSplitterPtr is null" << endl;
      ierr = kStFatal;
   };
   if( !ierr ){
      ierr = mTowerModelPtr->Init();
      if( ierr ){
         LOG_FATAL << ClassName() << "::Init() -- error initializing tower shower shape model" << endl;
         ierr = kStFatal;
      };
   };
   if( !ierr ){
      ierr = mStripModelPtr->Init();
      if( ierr ){
         LOG_FATAL << ClassName() << "::Init() -- error initializing strip shower shape model" << endl;
         ierr = kStFatal;
      };
   };
   if( !ierr ){
      ierr = mHitSplitterPtr->Init();
      if( ierr ){
         LOG_FATAL << ClassName() << "::Init() -- error initializing hit splitter" << endl;
         ierr = kStFatal;
      };
   };

   // get the R range of the detector
   Float_t Z = EEmcGeomSimple::Instance().getZMean();
   Float_t etaMin = EEmcGeomSimple::Instance().getEtaMin();
   Float_t etaMax = EEmcGeomSimple::Instance().getEtaMax();

   mInnerRsq = Z/TMath::SinH( etaMin );
   mInnerRsq *= mInnerRsq;
   mOuterRsq = Z/TMath::SinH( etaMax );
   mOuterRsq *= mOuterRsq;

   // for some reason EEmcGeomSimple may have these backwards
   // fix if this is the case
   if( mInnerRsq > mOuterRsq ){
      Float_t temp = mInnerRsq;
      mInnerRsq = mOuterRsq;
      mOuterRsq = temp;
   };

   return ierr;
};

/// Find all the hits
Int_t StEEmcHitMakerAnlEM_t::Make(){
   // make parent
   Int_t ierr = StEEmcHitMaker_t::Make();
   Bool_t doContinue = 1;

   // I.
   ierr = init();

   mIterSameNhits = 0;
   mNhitsLastIter = -1;

   // debug
#ifdef DEBUG
   {
      StEEmcAnlHitList_t::iterator hitIter;
      Int_t hitIdx = 0;
      for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end(); ++hitIter, ++hitIdx ){
         LOG_INFO << "I. hit " << hitIter->getKey() << ", E = " << hitIter->getE() << ", Esmd = " << hitIter->getEsmd()
                  << ", at (" << hitIter->getX() << ", " << hitIter->getY() << ")" << endm;
      };
   };
#endif

   if( mAnlHitList.empty() ){
      LOG_WARN << "No hits during initialization stage" << endm;
      doContinue = 0;
   };

   mIterNum = 0;
   for( mIterNum = 0; mIterNum<mMaxIters && doContinue && !ierr; ++mIterNum ){
#ifdef DEBUG
      LOG_INFO << "Event " << GetEventNumber() << ") on iteration " << mIterNum << " of " << mMaxIters << endm;
#endif

      // II.
      if(!ierr)
         ierr = updateEnergies(0);


      // debug
#ifdef DEBUG
      {
         LOG_INFO << "II. nhits = " << mAnlHitList.size() << endm;

         StEEmcAnlHitList_t::iterator hitIter;
         Int_t hitIdx = 0;
         for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end(); ++hitIter, ++hitIdx ){
            LOG_INFO << "II. hit " << hitIter->getKey() << ", E = " << hitIter->getE() << ", Esmd = " << hitIter->getEsmd()
                     << ", at (" << hitIter->getX() << ", " << hitIter->getY() << ")" << endm;
         };
      };

      // debug
      Int_t nHits = mAnlHitList.size();
#endif


      // III.
      if(!ierr)
         ierr = divideHits();

      // debug
#ifdef DEBUG
      {
         LOG_INFO << "III. After dividing, total number of hits went from " << nHits << " to " << mAnlHitList.size() << endm;
         nHits = mAnlHitList.size();

         StEEmcAnlHitList_t::iterator hitIter;
         Int_t hitIdx = 0;
         for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end(); ++hitIter, ++hitIdx ){
            LOG_INFO << "III. hit " << hitIter->getKey() << ", E = " << hitIter->getE() << ", Esmd = " << hitIter->getEsmd()
                     << ", at (" << hitIter->getX() << ", " << hitIter->getY() << ")" << endm;
         };
      };
#endif

      // IV.
      if(!ierr)
         ierr = estimatePositions();

      // debug
#ifdef DEBUG
      {
         LOG_INFO << "IV. nhits = " << mAnlHitList.size() << endm;
         nHits = mAnlHitList.size();

         StEEmcAnlHitList_t::iterator hitIter;
         Int_t hitIdx = 0;
         for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end(); ++hitIter, ++hitIdx ){
            LOG_INFO << "IV. hit " << hitIter->getKey() << ", E = " << hitIter->getE() << ", Esmd = " << hitIter->getEsmd()
                     << ", at (" << hitIter->getX() << ", " << hitIter->getY() << ")" << endm;
         };
      };
#endif

      // V.
      if(!ierr)
         ierr = updateEnergies(1);

      // debug 
#ifdef DEBUG
      {
         LOG_INFO << "V. nhits = " << mAnlHitList.size() << endm;
         nHits = mAnlHitList.size();

         StEEmcAnlHitList_t::iterator hitIter;
         Int_t hitIdx = 0;
         for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end(); ++hitIter, ++hitIdx ){
            LOG_INFO << "V. hit " << hitIter->getKey() << ", E = " << hitIter->getE() << ", Esmd = " << hitIter->getEsmd()
                     << ", at (" << hitIter->getX() << ", " << hitIter->getY() << ")" << endm;
         };
      };
#endif

      // VI.
      if(!ierr)
         ierr = merge();

      // debug
#ifdef DEBUG
      {
         LOG_INFO << "VI. After merging, total number of hits went from " << nHits << " to " << mAnlHitList.size() << endm;
         nHits = mAnlHitList.size();

         Int_t hitIdx = 0;
         StEEmcAnlHitList_t::iterator hitIter;
         for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end(); ++hitIter, ++hitIdx ){
            LOG_INFO << "VI. hit " << hitIter->getKey() << ", E = " << hitIter->getE() << ", Esmd = " << hitIter->getEsmd()
                     << ", at (" << hitIter->getX() << ", " << hitIter->getY() << ")" << endm;
         };
      };
#endif

      //cout << "nhits " << mIterNum << ' ' << mAnlHitList.size() << endl;

      // VII.
      if(!ierr )
         doContinue = !stop();
   };

   // debug
#ifdef DEBUG
   /*
   StEEmcAnlHitList_t::iterator hitIter;
   StEEmcAnlElementSet_t::const_iterator stripSetIter;
   for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end(); ++hitIter ){
      const StEEmcAnlElementSet_t stripSet = hitIter->getStripSet();
      for( stripSetIter = stripSet.begin(); stripSetIter != stripSet.end(); ++stripSetIter ){
         Short_t sector, strip;
         Bool_t layerIsV;

         StEEmcGeoId_t::decodeSmd( stripSetIter->getGeoId(), sector, layerIsV, strip );
         cout << GetEventNumber() << ' ' << hitIter->getKey() << ' ' << stripSetIter->getGeoId() << ' ' << sector << ' ' << layerIsV << ' ' << strip << ' ' << stripSetIter->getEnergy() << endl;
      };
   };
   */
#endif

   if( !ierr )
      convertAnlHitToEEmcHit();

   return ierr;
};

/// Clear for next event
void  StEEmcHitMakerAnlEM_t::Clear(Option_t *opts ){
   StEEmcHitMaker_t::Clear( opts );
   mTowerClusterFinder->clear();
   mAnlHitList.clear();
   mStripDepositedEnergy.clear();
   mTowerDepositedEnergy.clear();
   mStripModelPtr->Clear();
   mTowerModelPtr->Clear();
   StEEmcAnlHit_t::resetKeyNumbering();
};


// Initialize the list of hits using the tower cluster finder.
// Also set up maps to find hit strips/towers easier
Int_t StEEmcHitMakerAnlEM_t::init(){
   Int_t ierr = kStOk;

   // cluster the towers
   StEEmcTowerVec_t &towVec = *(mHitTowerPtr[ TOWER ]);
   assert( mHitTowerPtr[ TOWER ] );

   if( towVec.empty() ){
      LOG_WARN << "No towers hit!" << endm;
      ierr = kStWarn;
   };

   // debug
#ifdef DEBUG
   {
      LOG_INFO << "Number of hit towers: " << towVec.size() << endm;
   };
#endif

   if( !ierr )
      mTowerClusterFinder->find( towVec, mTowerClusterVec[ TOWER ] );

   if( !ierr ){
      // copy the results
      for( StSimpleClusterVec_t::iterator iter = mTowerClusterVec[ TOWER ].begin(); iter != mTowerClusterVec[ TOWER ].end(); ++iter )
         mAnlHitList.push_back( *iter );
   };

   // copy deposited energy into sets so can do lookups easier
   StEEmcStripVec_t::iterator stripIter;
   StEEmcTowerVec_t::iterator towerIter;
   for( Int_t sector = 0; sector < kEEmcNumSectors && !ierr; ++sector ){
      StEEmcStripVec_t &uVec = *(mHitUStripPtr[sector]);
      StEEmcStripVec_t &vVec = *(mHitVStripPtr[sector]);

      for( stripIter = uVec.begin(); stripIter != uVec.end(); ++stripIter ){
         if( !stripIter->fail() && !stripIter->stat() ){
            Short_t geoId = StEEmcGeoId_t::encodeSmd( sector, 0, stripIter->index() );
            mStripDepositedEnergy.insert( StEEmcAnlElement_t( geoId, stripIter->energy() ) );
#ifdef DEBUG
            LOG_INFO << "aaa " << geoId << ' ' << sector << " U " << stripIter->index() << ' ' << stripIter->energy() << endm;
#endif
         };
      };
      for( stripIter = vVec.begin(); stripIter != vVec.end(); ++stripIter ){
         if( !stripIter->fail() && !stripIter->stat() ){
            Short_t geoId = StEEmcGeoId_t::encodeSmd( sector, 1, stripIter->index() );
            mStripDepositedEnergy.insert( StEEmcAnlElement_t( geoId, stripIter->energy() ) );
#ifdef DEBUG
            LOG_INFO << "aaa " << geoId << ' ' << sector << " V " << stripIter->index() << ' ' << stripIter->energy() << endm;
#endif
         };
      };
   };
   if( mStripDepositedEnergy.empty() ){
      LOG_WARN << "No hit strips" << endm;
      ierr = kStWarn;
   };

   for( towerIter = towVec.begin(); towerIter != towVec.end(); ++towerIter ){
      if( !towerIter->fail() && !towerIter->stat() ){
         Short_t geoId = StEEmcGeoId_t::encodeTow( towerIter->sector(), towerIter->subsector(), towerIter->etabin() );
         mTowerDepositedEnergy.insert( StEEmcAnlElement_t( geoId, towerIter->energy() ) );
      };
   };
   if( mTowerDepositedEnergy.empty() ){
      LOG_WARN << "No hit towers" << endm;
      ierr = kStWarn;
   };

   // double check that the tower cluster finder set the energies
   // correctly, and correct if not
   StEEmcAnlHitList_t::iterator hitIter;
   for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end(); ++hitIter ){
      StEEmcAnlElementSet_t& hitElementSet = hitIter->getTowerSet();
      StEEmcAnlElementSet_t::iterator elemIter;

      for( elemIter = hitElementSet.begin(); elemIter != hitElementSet.end(); ++elemIter ){
         Float_t E1 = getTowerDepositedEnergy( elemIter->getGeoId() );
         Float_t E2 = elemIter->getEnergy();
         if( E2 && E1 != E2 )
            const_cast< StEEmcAnlElement_t* >( &*elemIter )->setEnergy( E1 );
      };

      Float_t totE = 0;
      purgeElements( hitElementSet, mTowerMinWeight, totE );
      hitIter->setE( totE );
   }; 

   return ierr;
};

Int_t StEEmcHitMakerAnlEM_t::updateEnergies( Bool_t doTowers ){
   Int_t ierr = kStOK;

   // container to store all weights for a given geoId (strip or tower)
   std::map< Short_t, std::vector< Float_t* > > geoId2weightPtrMap;
   std::map< Short_t, std::vector< Float_t* > >::iterator geoId2weightPtrMapIter;
   std::vector< Float_t* >::iterator weightPtrVecIter;

   // container for holding sets of geoIds, and its iterator
   std::set< Short_t > geoIdSet;
   std::set< Short_t >::iterator geoIdSetIter;

   // iterate over all the hits
   StEEmcAnlHitList_t::iterator hitIter;
   Int_t hitIdx = 0;
   for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end(); ++hitIter, ++hitIdx ){
      // get the nearby strips/towers
      if( doTowers )
         StEEmcPointMap_t::instance().getTowersNearPoint( hitIter->getX(), hitIter->getY(), mTowerInclDist, geoIdSet );
      else
         StEEmcPointMap_t::instance().getStripsNearPoint( hitIter->getX(), hitIter->getY(), mStripInclDist, geoIdSet );

      StEEmcAnlElementSet_t& hitElementSet = ( doTowers ? hitIter->getTowerSet() : hitIter->getStripSet() );
      hitElementSet.clear();

      // loop over all the strips/towers for this hit and compute I_{ strip/tower, hit }
      for( geoIdSetIter = geoIdSet.begin(); geoIdSetIter != geoIdSet.end(); ++geoIdSetIter ){
         // determine nominal weight
         Float_t w = 0;

         w = ( doTowers ?
               hitIter->getEsmd()*mTowerModelPtr->getEnergyFromHitIntoElement( *hitIter,  *geoIdSetIter ) :
               hitIter->getE()   *mStripModelPtr->getEnergyFromHitIntoElement( *hitIter,  *geoIdSetIter )   );

         //LOG_INFO << "Hit " << hitIter->getKey() << ", geoId " << *geoIdSetIter << ", weight = " << w << endm;

         std::pair< StEEmcAnlElementSet_t::iterator, Bool_t > returnPair = hitElementSet.insert( StEEmcAnlElement_t( *geoIdSetIter, w ) );


         // Save pointer to this weight (i.e. energy) so can later
         // normalize.  NOTE: set iterators are always constant, as
         // modifying the elements might reorder the set.  In the
         // following, only the energy is modified, which does not
         // effect the order.
         geoId2weightPtrMap[ *geoIdSetIter ].push_back( const_cast< StEEmcAnlElement_t* >( &(*returnPair.first) )->getEnergyPtr() );
      };
   };

   // adjust number of normalization iterations
   // (this is needed as weights are cut if below threshold, causing all weights to need to be updated)
   if( mMaxRenormIters < 0 )
      mMaxRenormIters = 0;

   // need to normalize the energy of each element (strip or tower)
   StEEmcAnlElementSet_t::iterator elementSetIter;
   for( geoId2weightPtrMapIter = geoId2weightPtrMap.begin(); geoId2weightPtrMapIter != geoId2weightPtrMap.end(); ++geoId2weightPtrMapIter ){
      // need sum of weights
      Float_t totW = 0;
      for( weightPtrVecIter = geoId2weightPtrMapIter->second.begin(); weightPtrVecIter != geoId2weightPtrMapIter->second.end(); ++weightPtrVecIter )
         totW += *(*weightPtrVecIter);

      // allow elements to be removed
//       if( !totW ){
//          LOG_ERROR << "SANITY CHECK FAILURE: total weight is zero" << endm;
//          totW = 1;
//       };

      // need to find what the sum of energies should be, so look it
      // up in sets of data
      Float_t E = ( doTowers ? getTowerDepositedEnergy( geoId2weightPtrMapIter->first ) : getStripDepositedEnergy( geoId2weightPtrMapIter->first ) );

//       if( !doTowers ){
//          LOG_INFO << "total weight of geoId " << geoId2weightPtrMapIter->first << " before norm: " << totW << ", shared amoung " << geoId2weightPtrMapIter->second.size()
//                   << " (total in element = " << E << ")" << endm;
//       };

      Float_t minWeight = ( doTowers ? mTowerMinWeight : mStripMinWeight );

      if( geoId2weightPtrMapIter->second.size() > 1 ){
         Bool_t doneNormalizing = 0;
         for( Int_t nIter = 0; nIter <= mMaxRenormIters && !doneNormalizing; ++nIter ){
            // renormalize
            doneNormalizing = 1;

            // renormalization factor
            Double_t factor = (totW ? E/totW : 0);

            if( factor != factor )
               factor = 0;

            //LOG_INFO << "---------------> factor = " << factor << " = " << E << " / " << totW << endm;

            totW = 0;

            for( weightPtrVecIter = geoId2weightPtrMapIter->second.begin(); weightPtrVecIter != geoId2weightPtrMapIter->second.end(); ++weightPtrVecIter ){
               Float_t &w = *(*weightPtrVecIter);

               //LOG_INFO << "renorm iter " << nIter << ", geoId " << geoId2weightPtrMapIter->first << " w = " << w << " * " << factor;

               w *= factor;

               if( w < minWeight && w > 0 ){
                  w = 0;
                  doneNormalizing = 0;
               };

               totW += w;

               //LOG_INFO << " -> " << w << " (tot = " << totW << ")" << endm;
               //LOG_INFO << geoId2weightPtrMapIter->first << ' ' << w << ' ' << minWeight << endm;
            };
         };
      } else {
         *(geoId2weightPtrMapIter->second.front()) = ( E > minWeight ? E : 0 );
      };
   };

   Float_t minWeight = ( doTowers ? mTowerMinWeight : mStripMinWeight );

   // need to purge from the hits any strips/towers that have zero energy.
   // also need to resum the SMD energy
   for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end(); ++hitIter ){
      StEEmcAnlElementSet_t& hitElementSet = ( doTowers ? hitIter->getTowerSet() : hitIter->getStripSet() );

      Float_t totE = 0;
      purgeElements( hitElementSet, minWeight, totE );

      // update total energies
      if( doTowers )
         hitIter->setE( totE );
      else
         hitIter->setEsmd( totE );
   };

   return ierr;
};


void StEEmcHitMakerAnlEM_t::purgeElements( StEEmcAnlElementSet_t& hitElementSet, Float_t minE, Float_t& totE ) const {

   // make something to hold copy
   StEEmcAnlElementSet_t hitElementSet_COPY;
   totE = 0;

   // copy elements and sum

   StEEmcAnlElementSet_t::iterator elementSetIter;
   for( elementSetIter = hitElementSet.begin(); elementSetIter != hitElementSet.end(); ++elementSetIter ){
      if( elementSetIter->getEnergy() > minE ) {
         totE += elementSetIter->getEnergy();
         hitElementSet_COPY.insert( *elementSetIter );
      };
//       if( minE > 0.001 ){
//          LOG_INFO << "element E " << elementSetIter->getEnergy() << " vs " << minE << " -> totE = " << totE << endm;
//       };
   };

   // swap copy and real storage container
   hitElementSet.swap( hitElementSet_COPY );
};

Int_t StEEmcHitMakerAnlEM_t::divideHits(){
   Int_t ierr = kStOk;

   // for the new hits
   StEEmcAnlHitList_t newHitList;

   // some needed iterators
   StEEmcAnlElementSet_t::iterator newStripIter1, newStripIter2;

   // points to save positions, if need to split
   AnlEMPoint_t point1, point2;

   // loop over hits
   StEEmcAnlHitList_t::iterator hitIter;
   for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end() && ierr != kStFatal; ++hitIter ){
      if( hitIter->getE() > mMinHitEtoSplit ){
         Bool_t doSplit = 0;
         Bool_t doInvalidate = 0;

         ierr = mHitSplitterPtr->splitHit( *hitIter, doSplit, doInvalidate, point1, point2 );

         if( doInvalidate ){
            doSplit = 0;
            hitIter->invalidate();

#ifdef DEBUG
            LOG_INFO << "III. Invalidating hit " << hitIter->getKey() << " due to hit splitter flag" << endm;
#endif
         };

         if( !ierr && doSplit ){
            hitIter->clearSpreadMap();

            // make new hits and add to list
            newHitList.push_back( *hitIter );
            StEEmcAnlHit_t &newHit1 = newHitList.back();
            newHit1.setKeyToNext();

            // make a second copy
            newHitList.push_back( newHit1 );
            StEEmcAnlHit_t &newHit2 = newHitList.back();
            newHit2.setKeyToNext();

            Float_t w1 = point1.W();
            Float_t w2 = point2.W();
            Float_t wSum = w1 + w2;
            if( !wSum ){
               // Algo must not have set these.  Default to 0.5 each
               w1 = 0.5;
               w2 = 0.5;
            };
            if( wSum != 1 ){
               w1 /= wSum;
               w2 /= wSum;
            };

            newHit1.setE( w1*newHit1.getE() );
            newHit2.setE( w2*newHit2.getE() );
            newHit1.setEsmd( w1*newHit1.getEsmd() );
            newHit2.setEsmd( w2*newHit2.getEsmd() );

            StEEmcAnlElement_t::scaleSet( newHit1.getTowerSet(), w1 );
            StEEmcAnlElement_t::scaleSet( newHit2.getTowerSet(), w2 );

#ifdef DEBUG
            //LOG_INFO << "New energies are " << newHit1.getE() << ' ' << newHit2.getE() << endm;
#endif

            // purge all towers below threshold and reset total energy
            Float_t totE = 0;
            purgeElements( newHit1.getTowerSet(), mTowerMinWeight, totE );
            newHit1.setE( totE );

            totE = 0;
            purgeElements( newHit2.getTowerSet(), mTowerMinWeight, totE );
            newHit2.setE( totE );

#ifdef DEBUG
            LOG_INFO << "New energies are " << newHit1.getE() << ' ' << newHit2.getE() << endm;
#endif

            newHit1.setXY( point1.X(), point1.Y() );
            newHit2.setXY( point2.X(), point2.Y() );

            // todo: check to make sure the point is on the EEMC

            // now reset the SMD strip energies
            StEEmcAnlElementSet_t& newStripSet1 = newHit1.getStripSet();
            StEEmcAnlElementSet_t& newStripSet2 = newHit2.getStripSet();

            newStripIter1 = newStripSet1.begin();
            newStripIter2 = newStripSet2.begin();

            Float_t smdSum1 = 0, smdSum2 = 0;
            for( ; newStripIter1 != newStripSet1.end(); ++newStripIter1, ++newStripIter2 ){
               assert( newStripIter1->getGeoId() == newStripIter2->getGeoId() );

               Float_t w1 = newHit1.getE()*mStripModelPtr->getEnergyFromHitIntoElement( newHit1, newStripIter1->getGeoId() );
               Float_t w2 = newHit2.getE()*mStripModelPtr->getEnergyFromHitIntoElement( newHit2, newStripIter2->getGeoId() );

               Float_t wSum = w1 + w2;
               if( wSum ){
                  w1 /= wSum;
                  w2 /= wSum;
               };

               Float_t temp = w1*newStripIter1->getEnergy();
               if( temp < mStripMinWeight )
                  temp = 0;
               smdSum1 += temp;

#ifdef DEBUG_TO_PLOT
               {
                  Short_t sector, strip;
                  Bool_t layerIsV;
         
                  StEEmcGeoId_t::decodeSmd( newStripIter1->getGeoId(), sector, layerIsV, strip );
                  cout << "ppp " << mIterNum << ' ' << sector << ' ' << (layerIsV ? 'v' : 'u') << ' ' << strip << ' '
                       << newHit1.getKey() << ' ' << temp << ' ';
               };
#endif
         
               //cout << "qqq " << newStripIter1->getGeoId() << ' ' << w1 << ' ' << w2 << ' ' << temp;

               // NOTE: set iterators are always constant, as modifying the
               // elements might reorder the set.  In the following, only
               // the energy is modified, which does not effect the order.
               const_cast< StEEmcAnlElement_t* >( &*newStripIter1 )->setEnergy( temp );

               temp = w2*newStripIter2->getEnergy();
               if( temp < mStripMinWeight )
                  temp = 0;
               smdSum2 += temp;

#ifdef DEBUG_TO_PLOT
               cout << newHit2.getKey() << ' ' << temp << endl;
#endif

               //cout << ' ' << temp << endl;

               const_cast< StEEmcAnlElement_t* >( &*newStripIter2 )->setEnergy( temp );
            };

            newHit1.setEsmd( smdSum1 );
            newHit2.setEsmd( smdSum2 );

            // purge all strips below threshold and reset total energy
            purgeElements( newStripSet1, mStripMinWeight, smdSum1 );
            newHit1.setEsmd( smdSum1 );

            purgeElements( newStripSet2, mStripMinWeight, smdSum2 );
            newHit2.setEsmd( smdSum2 );

            // invalidate if smdSums too low
            if( !smdSum1 ){
               newHit1.invalidate();
#ifdef DEBUG
               LOG_INFO << "III. Invalidating hit " << newHit1.getKey() << " as no energy in SMD" << endm;
#endif
            };

            if( !smdSum2 ){
               newHit2.invalidate();
#ifdef DEBUG
               LOG_INFO << "III. Invalidating hit " << newHit2.getKey() << " as no energy in SMD" << endm;
#endif
            };

            // copy uncert values, if available
            Int_t twiceSector;
            Float_t u1u, v1u, u2u, v2u;
            if( !mHitSplitterPtr->getUncert( twiceSector, u1u, v1u, u2u, v2u ) ){
               twiceSector *= 2;
               newHit1.clearSpreadMap();
               newHit1.setSpread( twiceSector, u1u );
               newHit1.setSpread( twiceSector+1, v1u );

               newHit2.clearSpreadMap();
               newHit2.setSpread( twiceSector, u2u );
               newHit2.setSpread( twiceSector+1, v2u );
            };

            // flag to remove this hit
            hitIter->invalidate();
         };
      };
   };

   // remove invalid hits
   mAnlHitList.remove_if( StEEmcAnlHit_t::isNotValid );
   newHitList.remove_if(  StEEmcAnlHit_t::isNotValid );

   // add new hits into the usual list
   mAnlHitList.splice( mAnlHitList.end(), newHitList );

   return ierr;
};


Int_t StEEmcHitMakerAnlEM_t::estimatePositions(){
   Int_t ierr = kStOk;

   // some iterators
   StEEmcAnlHitList_t::iterator hitIter;
   StEEmcAnlElementSet_t::const_iterator stripSetIter;

   std::map< Float_t, Int_t > slopeToIdxMap;
   std::map< Float_t, Int_t >::iterator slopeToIdxMapIter;

   std::vector< Float_t > slopeVec;
   std::vector< Float_t > offsetVec;
   std::vector< Float_t > energyVec;
   std::vector< Int_t > nStripsVec;

   // loop over hits
   for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end() && ierr != kStFatal; ++hitIter ){

      // clear things
      slopeToIdxMap.clear();
      slopeVec.clear();
      offsetVec.clear();
      energyVec.clear();
      nStripsVec.clear();

      const StEEmcAnlElementSet_t stripSet = hitIter->getStripSet();
      for( stripSetIter = stripSet.begin(); stripSetIter != stripSet.end(); ++stripSetIter ){
         Float_t a = 0; // slope
         Float_t b = 0; // offset
         Float_t e = stripSetIter->getEnergy();

         StEEmcPointMap_t::instance().getStripLineParam( stripSetIter->getGeoId(), a, b );

#ifdef DEBUG
         //LOG_INFO << "hit " << hitIter->getKey() << ", strip " << stripSetIter->getGeoId() << ", a,b,e = " << a << ' ' << b << ' ' << e << endm;
#endif

         if( e ){
            slopeToIdxMapIter = slopeToIdxMap.find( a );
            if( slopeToIdxMapIter == slopeToIdxMap.end() ){
               slopeVec.push_back( a );
               offsetVec.push_back( e*b );
               energyVec.push_back( e );
               nStripsVec.push_back( 1 );
               slopeToIdxMap[ a ] = slopeVec.size()-1;
            } else {
               Int_t idx = slopeToIdxMapIter->second;
               offsetVec[ idx ] += e*b;
               energyVec[ idx ] += e;
               nStripsVec[ idx ] += 1;
            };
         };
      };

#ifdef DEBUG
      LOG_INFO << "IV. hit " << hitIter->getKey() << ", number of layers " << slopeVec.size() << endm;
#endif

      // ensure at least two layers with more than minumum number of strips
      Int_t nEffLayers = 0;
      for( UInt_t i = 0; i < nStripsVec.size(); ++i )
         if( nStripsVec[i] >= mMinNumStripsPerLayer )
            ++nEffLayers;

      // make sure at least two layers involved
      if( nEffLayers > 1 ){

         // divide to convert average to sum
         for( UInt_t i = 0; i < slopeVec.size(); ++i ){
            offsetVec[i] /= energyVec[i];
            energyVec[i] /= nStripsVec[i];
         };

         Float_t x = 0, y = 0;

         if( slopeVec.size() == 2 ){
            // exists point of intersection
            //cout << "bbmm = " << offsetVec[0] << ' ' << offsetVec[1] << ' ' << slopeVec[0] << ' ' << slopeVec[1] << endl;
            x = (offsetVec[0]-offsetVec[1]) / (slopeVec[1]-slopeVec[0]);
            y = slopeVec[1]*x + offsetVec[1];
         } else {
            // minimize the energy weighted sum of distances squared

            // coefficients
            Float_t a, b, c, d, e, f;

            // compute coefficients
            for( UInt_t i = 0; i < slopeVec.size(); ++i ){
               Float_t slope = slopeVec[i];
               Float_t energy = energyVec[i];

               Float_t temp = 1./(slope*slope + 1);
               Float_t A = slope*temp;
               Float_t B = -temp;
               Float_t C = offsetVec[i]*temp;

               a += energy*A*A;
               b += energy*2.*A*B;
               c += energy*B*B;
               d += energy*2.*A*C;
               e += energy*2.*B*C;
               f += energy*C*C;
            };

            x = (2*c*d-e*b)/(4*a*c-b*b);
            y = -(2*a*x+d)/b;
         };
         hitIter->setXY( x, y );
      } else {
         hitIter->invalidate();
#ifdef DEBUG
         LOG_INFO << "IV. Invalidating hit " << hitIter->getKey() << " due to number of effective layers = " << nEffLayers << endm;
#endif
      };

      // loop to next hit
   };

   // remove invalid hits
   mAnlHitList.remove_if( StEEmcAnlHit_t::isNotValid );

   return ierr;
};

Int_t StEEmcHitMakerAnlEM_t::merge(){
   Int_t ierr = kStOk;

   // first thing is to compute all the distances

   if( mMinHitDist <= 0 )
      return kStOk;

   // make a map for reverse lookup of hits by key
   std::map< Int_t, StEEmcAnlHit_t* > hitMap;

   // some iterators
   StEEmcAnlHitList_t::iterator hitIter1, hitIter2;

   // distance 'matrix' (actually a linked list)
   StEEmcAnlDistMatrix_t distMatrix;
   StEEmcAnlDistMatrix_t::iterator distMatrixIter;

#ifdef DEBUG
   LOG_INFO << "VI. number of hits: " << mAnlHitList.size() << endm;
#endif

   // loop over hits
   for( hitIter1 = mAnlHitList.begin(); hitIter1 != mAnlHitList.end(); ++hitIter1 ){

      // fill the map
      hitMap[ hitIter1->getKey() ] = &(*hitIter1);

      // compute distances
      for( hitIter2 = mAnlHitList.begin(); hitIter2 != hitIter1; ++hitIter2 ){
         if( hitIter2->isValid() ){
            Float_t dist = hitIter1->getDistToHit( *hitIter2 );

            //cout << hitIter1->getKey() << ' ' << hitIter2->getKey() << ' ' << dist << endl;

            // insert so that the list is always ordered
            if( distMatrix.empty() ){
               distMatrix.push_back( StEEmcAnlDistMatrixElement_t( dist, hitIter1->getKey(), hitIter2->getKey() ) );
            } else {
               StEEmcAnlDistMatrixElement_t element( dist, hitIter1->getKey(), hitIter2->getKey() );
               distMatrixIter = std::lower_bound( distMatrix.begin(), distMatrix.end(), element );
               distMatrix.insert( distMatrixIter, element );
            };
         };
      };
   };

   StEEmcAnlDistMatrixPruner_t pruner;

   // iterate over the list, merging the closest ones first
   while( !distMatrix.empty() && distMatrix.front().getDist() < mMinHitDist ){
#ifdef DEBUGDIST
   {
      LOG_INFO << "--> a) distance matrix size " << distMatrix.size() << endm;
      for( distMatrixIter = distMatrix.begin(); distMatrixIter != distMatrix.end(); ++distMatrixIter ){
         LOG_INFO << "--> " << *distMatrixIter << endm;
      };
   };
#endif

      // going to merge the front
      StEEmcAnlHit_t *hit1 = hitMap[ distMatrix.front().getIdx1() ];
      StEEmcAnlHit_t *hit2 = hitMap[ distMatrix.front().getIdx2() ];

      // sanity check
      if( hit1 == hit2 ){
         distMatrix.pop_front();
      } else {
#ifdef DEBUGDIST
         LOG_INFO << "-----------------------> merging hits " << distMatrix.front().getIdx1() << " and " << distMatrix.front().getIdx2() << ", distance = " << distMatrix.front().getDist() << endm;
#endif

         // merge
         (*hit1) += (*hit2);

         // remove from the map
         hitMap.erase( hit1->getKey() );
         hitMap.erase( hit2->getKey() );

         // reset the key
         hit1->setKeyToNext();

         // add to the map with new key
         hitMap[ hit1->getKey() ] = hit1;

         // invalidate the other
         hit2->invalidate();

         // remove all rows and columns from the matrix with these indices
         pruner.setIdx1( distMatrix.front().getIdx1() );
         pruner.setIdx2( distMatrix.front().getIdx2() );
         distMatrix.remove_if( pruner );

#ifdef DEBUGDIST
   {
      LOG_INFO << "--> b) distance matrix size " << distMatrix.size() << endm;
      for( distMatrixIter = distMatrix.begin(); distMatrixIter != distMatrix.end(); ++distMatrixIter ){
         LOG_INFO << "--> " << *distMatrixIter << endm;
      };
   };
#endif

         // now compute all the new distances to this hit
         for( hitIter2 = mAnlHitList.begin(); hitIter2 != mAnlHitList.end(); ++hitIter2 ){
            if( hitIter2->isValid() && hitIter2->getKey() != hit1->getKey() ){
               Float_t dist = hit1->getDistToHit( *hitIter2 );

               // insert so that the list is always ordered
               if( distMatrix.empty() ){
                  distMatrix.push_back( StEEmcAnlDistMatrixElement_t( dist, hit1->getKey(), hitIter2->getKey() ) );
               } else {
                  StEEmcAnlDistMatrixElement_t element( dist, hit1->getKey(), hitIter2->getKey() );
                  distMatrixIter = std::lower_bound( distMatrix.begin(), distMatrix.end(), element );
                  distMatrix.insert( distMatrixIter, element );
               };
            };
         };
      };
   };

   // remove invalid hits
   mAnlHitList.remove_if( StEEmcAnlHit_t::isNotValid );

   return ierr;
};

Bool_t StEEmcHitMakerAnlEM_t::stop(){
   //LOG_INFO << "Stopping criterea not yet programmed. Will just stop when it hits the max number of iterations" << endm;

   Bool_t doStop = 0;

   if( mIterNum ){
      Int_t nHits = mAnlHitList.size();

      if( nHits == mNhitsLastIter )
         ++mIterSameNhits;

      mNhitsLastIter = nHits;
   };

   doStop = mAnlHitList.empty();

   if( !doStop )
      doStop = (mIterSameNhits >= mMinIterSameNhits);

   return doStop;
};

Int_t StEEmcHitMakerAnlEM_t::convertAnlHitToEEmcHit(){
   // need to use mAnlHitList to fill mHitVec

   Int_t towerIdx = -1;
   Int_t stripIdx = -1;

   // clear things just to make sure they are cleared
   mHitVec.clear();

   mTowerClusterVec[ TOWER ].clear();
   mTowerClusterVec[ PRESHOWER1 ].clear();
   mTowerClusterVec[ PRESHOWER2 ].clear();
   mTowerClusterVec[ POSTSHOWER ].clear();

   mESMDClusterVec.clear();

   // sectors per hit
   std::map< Int_t, Int_t > sectorPerHit;
   std::map< Int_t, StESMDClustersPerSector_t* > smdClustersPerSector;
   std::map< Int_t, StESMDClustersPerSector_t* >::iterator smdClustersPerSectorIter;

   // find all the sectors that have been hit
   StEEmcAnlHitList_t::iterator anlIter;
   for( anlIter = mAnlHitList.begin(); anlIter != mAnlHitList.end(); ++anlIter ){
      if( anlIter->isValid() ){
         Short_t hitSector = StEEmcPointMap_t::instance().getSectorOfPoint( anlIter->getX(), anlIter->getY() );
         sectorPerHit[ anlIter->getKey() ] = hitSector;

         smdClustersPerSectorIter = smdClustersPerSector.find( hitSector );
         if( smdClustersPerSectorIter == smdClustersPerSector.end() ){
            mESMDClusterVec.push_back( hitSector );
            smdClustersPerSector[ hitSector ] = &mESMDClusterVec.back();
         };
      };
   };


   // iterate
   Int_t hitIdx = -1;
   for( anlIter = mAnlHitList.begin(); anlIter != mAnlHitList.end(); ++anlIter ){
      if( anlIter->isValid() ){

         // tower cluster
         mTowerClusterVec[ TOWER ].push_back( ++towerIdx );
         StSimpleCluster_t &towerCluster = mTowerClusterVec[ TOWER ].back();

         // strip clusters

         Short_t hitSector = sectorPerHit[ anlIter->getKey() ];
         StESMDClustersPerSector_t* clusPerSector = smdClustersPerSector[ hitSector ];

         StSimpleClusterVec_t& uClusterVec = clusPerSector->getClusterVecU();
         uClusterVec.push_back( ++stripIdx );
         StSimpleCluster_t &uCluster = uClusterVec.back();

         StSimpleClusterVec_t& vClusterVec = clusPerSector->getClusterVecV();
         vClusterVec.push_back( ++stripIdx );
         StSimpleCluster_t &vCluster = vClusterVec.back();

         // EEmc Hit
         mHitVec.push_back( StEEmcHit_t() );
         StEEmcHit_t &eemcHit = mHitVec.back();

         anlIter->copyToEEmcData( towerCluster, uCluster, vCluster, eemcHit );
         eemcHit.setID( ++hitIdx );
      };
   };

   return kStOK;
};


Float_t StEEmcHitMakerAnlEM_t::getStripDepositedEnergy( Int_t geoId ) const {
   Float_t E = 0;

   // find energy of this strip
   StEEmcAnlElementSet_t::iterator elementSetIter = mStripDepositedEnergy.upper_bound( StEEmcAnlElement_t( geoId, 0 ) );

   // go back one, since upper_bound is the first one past the right spot
   if( elementSetIter != mStripDepositedEnergy.begin() )
      --elementSetIter;

#ifdef DEBUG
//     StEEmcAnlElementSet_t::iterator elementSetIter2;
//     for( elementSetIter2 = mStripDepositedEnergy.begin(); elementSetIter2 != mStripDepositedEnergy.end(); ++elementSetIter2 ){
//        cout << "eee " << elementSetIter2->getGeoId() << ' ' << elementSetIter2->getEnergy() << endl;
//     };
//     cout << "eee Input GeoId is " << geoId << ", found element is " << elementSetIter->getGeoId() << ' ' << elementSetIter->getEnergy() << endl;
#endif

   // check if found
   if( elementSetIter->getGeoId() == geoId )
      E = elementSetIter->getEnergy();
 
   return E;
};

Float_t StEEmcHitMakerAnlEM_t::getTowerDepositedEnergy( Int_t geoId ) const {
   Float_t E = 0;

   // find energy of this strip
   StEEmcAnlElementSet_t::iterator elementSetIter = mTowerDepositedEnergy.upper_bound( StEEmcAnlElement_t( geoId, 0 ) );

   // go back one, since upper_bound is the first one past the right spot
   if( elementSetIter != mTowerDepositedEnergy.begin() )
      --elementSetIter;

   if( elementSetIter->getGeoId() == geoId )
      E = elementSetIter->getEnergy();

   return E;
};

ClassImp( StEEmcHitMakerAnlEM_t );

/*
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.21 2011/12/15 22:21:18 sgliske Exp $
 *
 * $Log: StEEmcHitMakerAnlEM.cxx,v $
 * Revision 1.21  2011/12/15 22:21:18  sgliske
 * update
 *
 * Revision 1.20  2011/12/06 22:36:35  sgliske
 * update
 *
 * Revision 1.19  2011/11/30 23:03:14  sgliske
 * today
 *
 * Revision 1.18  2011/11/28 16:52:23  sgliske
 * today
 *
 * Revision 1.17  2011/11/23 17:55:44  sgliske
 * update
 *
 * Revision 1.16  2011/11/18 01:51:02  sgliske
 * today
 *
 * Revision 1.15  2011/11/18 01:47:03  sgliske
 * today
 *
 * Revision 1.14  2011/11/11 23:01:50  sgliske
 * daily update
 *
 * Revision 1.13  2011/11/11 21:28:22  sgliske
 * daily update
 *
 * Revision 1.12  2011/11/11 04:15:36  sgliske
 * update: it compiles!
 *
 * Revision 1.11  2011/11/10 23:33:33  sgliske
 * Re-arranged hit splitting & added new base class and algos
 *
 * Revision 1.10  2011/11/09 23:12:32  sgliske
 * daily update
 *
 * Revision 1.9  2011/11/08 22:22:15  sgliske
 * daily update
 *
 * Revision 1.8  2011/11/07 22:08:04  sgliske
 * daily update
 *
 * Revision 1.7  2011/11/03 17:18:35  sgliske
 * it compiles
 *
 * Revision 1.6  2011/11/03 17:12:59  sgliske
 * it compiles
 *
 * Revision 1.5  2011/11/02 22:04:45  sgliske
 * update
 *
 * Revision 1.4  2011/11/02 20:54:24  sgliske
 * update
 *
 * Revision 1.3  2011/10/26 21:37:35  sgliske
 * Working on ANL EM Algo
 *
 * Revision 1.2  2011/09/01 21:52:49  sgliske
 * Working on ANL EM Algo -- still
 *
 * Revision 1.1  2011/08/31 22:05:43  sgliske
 * Working on ANL EM Algo
 *
 *
 * 
 */
@


1.21
log
@update
@
text
@d1152 1
a1152 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.20 2011/12/06 22:36:35 sgliske Exp $
d1155 3
@


1.20
log
@update
@
text
@d10 1
a10 1
//#define DEBUG
d1152 1
a1152 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.19 2011/11/30 23:03:14 sgliske Exp $
d1155 3
@


1.19
log
@today
@
text
@d10 1
a10 1
#define DEBUG
d46 1
d351 3
a353 1
            //LOG_INFO << geoId << ' ' << sector << " U " << stripIter->index() << ' ' << stripIter->energy() << endm;
d360 3
a362 1
            //LOG_INFO << geoId << ' ' << sector << " V " << stripIter->index() << ' ' << stripIter->energy() << endm;
d378 1
a378 1
      LOG_WARN << "No towers strips" << endm;
d580 9
a588 2
      Bool_t doSplit = 0;
      Bool_t doInvalidate = 0;
d590 4
a593 1
      ierr = mHitSplitterPtr->splitHit( *hitIter, doSplit, doInvalidate, point1, point2 );
d595 2
a596 3
      if( doInvalidate ){
         doSplit = 0;
         hitIter->invalidate();
d598 9
a606 4
#ifdef DEBUG
         LOG_INFO << "III. Invalidating hit " << hitIter->getKey() << " due to hit splitter flag" << endm;
#endif
      };
d608 12
a619 23
      if( !ierr && doSplit ){
         // make new hits and add to list
         newHitList.push_back( *hitIter );
         StEEmcAnlHit_t &newHit1 = newHitList.back();
         newHit1.setKeyToNext();

         // make a second copy
         newHitList.push_back( newHit1 );
         StEEmcAnlHit_t &newHit2 = newHitList.back();
         newHit2.setKeyToNext();

         Float_t w1 = point1.W();
         Float_t w2 = point2.W();
         Float_t wSum = w1 + w2;
         if( !wSum ){
            // Algo must not have set these.  Default to 0.5 each
            w1 = 0.5;
            w2 = 0.5;
         };
         if( wSum != 1 ){
            w1 /= wSum;
            w2 /= wSum;
         };
d621 4
a624 4
         newHit1.setE( w1*newHit1.getE() );
         newHit2.setE( w2*newHit2.getE() );
         newHit1.setEsmd( w1*newHit1.getEsmd() );
         newHit2.setEsmd( w2*newHit2.getEsmd() );
d626 2
a627 2
         StEEmcAnlElement_t::scaleSet( newHit1.getTowerSet(), w1 );
         StEEmcAnlElement_t::scaleSet( newHit2.getTowerSet(), w2 );
d630 1
a630 1
         //LOG_INFO << "New energies are " << newHit1.getE() << ' ' << newHit2.getE() << endm;
d633 4
a636 4
         // purge all towers below threshold and reset total energy
         Float_t totE = 0;
         purgeElements( newHit1.getTowerSet(), mTowerMinWeight, totE );
         newHit1.setE( totE );
d638 3
a640 3
         totE = 0;
         purgeElements( newHit2.getTowerSet(), mTowerMinWeight, totE );
         newHit2.setE( totE );
d643 1
a643 1
         LOG_INFO << "New energies are " << newHit1.getE() << ' ' << newHit2.getE() << endm;
d646 2
a647 2
         newHit1.setXY( point1.X(), point1.Y() );
         newHit2.setXY( point2.X(), point2.Y() );
d649 1
a649 1
         // todo: check to make sure the point is on the EEMC
d651 3
a653 3
         // now reset the SMD strip energies
         StEEmcAnlElementSet_t& newStripSet1 = newHit1.getStripSet();
         StEEmcAnlElementSet_t& newStripSet2 = newHit2.getStripSet();
d655 2
a656 2
         newStripIter1 = newStripSet1.begin();
         newStripIter2 = newStripSet2.begin();
d658 3
a660 3
         Float_t smdSum1 = 0, smdSum2 = 0;
         for( ; newStripIter1 != newStripSet1.end(); ++newStripIter1, ++newStripIter2 ){
            assert( newStripIter1->getGeoId() == newStripIter2->getGeoId() );
d662 2
a663 2
            Float_t w1 = newHit1.getE()*mStripModelPtr->getEnergyFromHitIntoElement( newHit1, newStripIter1->getGeoId() );
            Float_t w2 = newHit2.getE()*mStripModelPtr->getEnergyFromHitIntoElement( newHit2, newStripIter2->getGeoId() );
d665 5
a669 5
            Float_t wSum = w1 + w2;
            if( wSum ){
               w1 /= wSum;
               w2 /= wSum;
            };
d671 9
a679 9
            Float_t temp = w1*newStripIter1->getEnergy();
            if( temp < mStripMinWeight )
               temp = 0;
            smdSum1 += temp;

#ifdef DEBUG
            {
               Short_t sector, strip;
               Bool_t layerIsV;
d681 4
a684 4
               StEEmcGeoId_t::decodeSmd( newStripIter1->getGeoId(), sector, layerIsV, strip );
               cout << "ppp " << mIterNum << ' ' << sector << ' ' << (layerIsV ? 'v' : 'u') << ' ' << strip << ' '
                    << newHit1.getKey() << ' ' << temp << ' ';
            };
d687 1
a687 1
            //cout << "qqq " << newStripIter1->getGeoId() << ' ' << w1 << ' ' << w2 << ' ' << temp;
d689 4
a692 4
            // NOTE: set iterators are always constant, as modifying the
            // elements might reorder the set.  In the following, only
            // the energy is modified, which does not effect the order.
            const_cast< StEEmcAnlElement_t* >( &*newStripIter1 )->setEnergy( temp );
d694 4
a697 4
            temp = w2*newStripIter2->getEnergy();
            if( temp < mStripMinWeight )
               temp = 0;
            smdSum2 += temp;
d699 2
a700 2
#ifdef DEBUG
            cout << newHit2.getKey() << ' ' << temp << endl;
d703 1
a703 1
            //cout << ' ' << temp << endl;
d705 2
a706 9
            const_cast< StEEmcAnlElement_t* >( &*newStripIter2 )->setEnergy( temp );
         };

         newHit1.setEsmd( smdSum1 );
         newHit2.setEsmd( smdSum2 );

         // purge all strips below threshold and reset total energy
         purgeElements( newStripSet1, mStripMinWeight, smdSum1 );
         newHit1.setEsmd( smdSum1 );
d708 2
a709 2
         purgeElements( newStripSet2, mStripMinWeight, smdSum2 );
         newHit2.setEsmd( smdSum2 );
d711 10
a720 3
         // invalidate if smdSums too low
         if( !smdSum1 ){
            newHit1.invalidate();
d722 1
a722 1
            LOG_INFO << "III. Invalidating hit " << newHit1.getKey() << " as no energy in SMD" << endm;
d724 1
a724 1
         };
d726 2
a727 2
         if( !smdSum2 ){
            newHit2.invalidate();
d729 1
a729 1
            LOG_INFO << "III. Invalidating hit " << newHit2.getKey() << " as no energy in SMD" << endm;
d731 1
a731 1
         };
d733 13
d747 3
a749 2
         // flag to remove this hit
         hitIter->invalidate();
d1118 9
d1129 1
a1129 1

d1152 1
a1152 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.18 2011/11/28 16:52:23 sgliske Exp $
d1155 3
@


1.18
log
@today
@
text
@d583 4
d615 2
d635 1
a635 1
         //LOG_INFO << "New energies are " << newHit1.getE() << ' ' << newHit2.getE() << endm;
d652 2
d664 2
d668 13
d687 2
d691 6
a697 3

            // could ensure that elements with zero energy are removed,
            // but whole set will be updated next iteration anyhow
d707 2
a708 2
         purgeElements( newStripSet2, mStripMinWeight, smdSum1 );
         newHit1.setEsmd( smdSum1 );
d711 1
a711 1
         if( !smdSum1 )
d713 4
d718 1
a718 1
         if( !smdSum2 )
d720 5
d852 3
d1121 1
a1121 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.17 2011/11/23 17:55:44 sgliske Exp $
d1124 3
@


1.17
log
@update
@
text
@d10 1
a10 1
//#define DEBUG
d1081 1
a1081 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.16 2011/11/18 01:51:02 sgliske Exp $
d1084 3
@


1.16
log
@today
@
text
@d10 1
a10 1
#define DEBUG
d257 1
d263 1
a264 1
#endif
d274 1
d287 1
d377 19
d551 3
d567 1
a567 1
   StEEmcAnlElementSet_t::iterator elementIter, newStripIter1, newStripIter2;
d591 27
a617 10
         // reset the tower energies before making second hit (so only
         // have to divide in half once)
         newHit1.setE( 0.5*newHit1.getE() );
         StEEmcAnlElementSet_t& towerSet = newHit1.getTowerSet();

         // NOTE: set iterators are always constant, as modifying the
         // elements might reorder the set.  In the following, only
         // the energy is modified, which does not effect the order.
         for( elementIter = towerSet.begin(); elementIter != towerSet.end(); ++elementIter )
            (*(const_cast< StEEmcAnlElement_t* >( &*elementIter )->getEnergyPtr())) *= 0.5;
d621 1
a621 1
         purgeElements( towerSet, mTowerMinWeight, totE );
d624 7
a630 4
         // make a second copy
         newHitList.push_back( newHit1 );
         StEEmcAnlHit_t &newHit2 = newHitList.back();
         newHit2.setKeyToNext();
d1081 1
a1081 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.15 2011/11/18 01:47:03 sgliske Exp $
d1084 3
@


1.15
log
@today
@
text
@d10 1
a10 1
//#define DEBUG
d1036 1
a1036 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.14 2011/11/11 23:01:50 sgliske Exp $
d1039 3
@


1.14
log
@daily update
@
text
@d264 1
a264 1
      cout << "nhits " << mIterNum << ' ' << mAnlHitList.size() << endl;
d272 1
a272 1

d285 1
a285 1

d1036 1
a1036 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.13 2011/11/11 21:28:22 sgliske Exp $
d1039 3
@


1.13
log
@daily update
@
text
@d48 2
d51 1
a51 6
   mTowerModelPtr(0)
   //mMaxMinuitIters(50),
   //mMinuitTolerance(0.1),
   //mMinuitStepSize(0.1){ 
   //mMinuit = new TMinuit(2);
{ /* */ };
d55 1
a55 1
   //delete mMinuit;
a262 1
      cout << "nhits " << mIterNum << ' ' << nHits << endl;
d264 1
d275 1
a275 1
   for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end(); ++hitIter, ++hitIdx ){
d282 1
a282 1
         cout << GetEventNumber() << ' ' << hitIter->getKey() << ' ' << sector << ' ' << layerIsV << ' ' << strip << ' ' << stripSetIter->getEnergy() << endl;
d486 1
d494 2
a497 1
   StEEmcAnlElementSet_t::iterator elementSetIterCopy;
a500 6
#ifdef DEBUG
      //LOG_INFO << "Hit " << hitIter->getKey() << ", number of " << (doTowers?"towers":"strips") << ": " << hitElementSet.size() << endm;
#endif

      // make something to hold copy
      StEEmcAnlElementSet_t hitElementSet_COPY;
d502 1
a502 17

      // copy elements and sum
      for( elementSetIter = hitElementSet.begin(); elementSetIter != hitElementSet.end(); ++elementSetIter ){
         if( elementSetIter->getEnergy() > 0 ) {
            totE += elementSetIter->getEnergy();
            hitElementSet_COPY.insert( *elementSetIter );
//             if( !doTowers ){
//                LOG_INFO << " hit " << hitIter->getKey() << ", element " << elementSetIter->getGeoId() << ' ' << elementSetIter->getEnergy() << " -> E = " << totE << endm;
//             };
         };
      };

      // swap copy and real storage container
      hitElementSet.swap( hitElementSet_COPY );

      //LOG_INFO << "Hit " << hitIter->getKey() << ", number of " << (doTowers?"towers":"strips") << " reduced to " << hitElementSet.size() << endm;
      //LOG_INFO << "Hit " << hitIter->getKey() << ", energy = " << totE << endm;
d514 21
d577 5
d630 7
d718 6
d725 1
a725 1
      if( slopeVec.size() > 1 ){
d1036 1
a1036 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.12 2011/11/11 04:15:36 sgliske Exp $
d1039 3
@


1.12
log
@update: it compiles!
@
text
@d10 1
a10 1
#define DEBUG
d143 3
a258 1
         StEEmcAnlHitList_t::iterator hitIter;
d265 2
d274 16
d414 1
a414 1
         LOG_INFO << "Hit " << hitIter->getKey() << ", geoId " << *geoIdSetIter << ", weight = " << w << endm;
d418 6
a423 1
         // save pointer to this weight (i.e. energy) so can later normalize 
a446 2
      //LOG_INFO << "total weight of geoId " << geoId2weightPtrMapIter->first << " before norm: " << totW << endm;

d451 5
d465 6
a470 1
            Float_t factor = (totW ? E/totW : 0);
d476 3
d481 1
a481 1
               if( w < minWeight ){
d487 2
d515 3
d573 3
a575 2
         // NOTE: set iterators are always constant.  Need to fix this.
         assert( 1 == 0 );
d610 3
a612 3
            // NOTE: set iterators are always constant.  Need to fix this.
            assert( 1 == 0 );
            // weird bug: shouldn't need the const cast here
a617 1
            // weird bug: shouldn't need the const cast here
d895 10
d907 3
d1020 1
a1020 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.11 2011/11/10 23:33:33 sgliske Exp $
d1023 3
@


1.11
log
@Re-arranged hit splitting & added new base class and algos
@
text
@d512 1
d514 6
a519 1
      ierr = mHitSplitterPtr->splitHit( *hitIter, doSplit, point1, point2 );
d966 1
a966 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.10 2011/11/09 23:12:32 sgliske Exp $
d969 3
@


1.10
log
@daily update
@
text
@d33 1
a33 1
#include "AnlEMLineParams.h"
a42 1
   mMaxEigenvalue(0.6),
d87 4
d105 6
a110 4
   if( mMaxEigenvalue <= 0 ){
      LOG_WARN << "Invalid max eigenvalue parameter '" << mMaxEigenvalue << "'" << endm;
      mMaxEigenvalue = 0.6;
      LOG_WARN << "Reset max eigenvalue parameter to '" << mMaxEigenvalue << "'" << endm;
a460 1
   StEEmcAnlElementSet_t::iterator hitBegin, hitEnd;
d468 2
a469 4
      hitBegin = hitElementSet.begin();
      hitEnd = hitElementSet.end();
      std::remove_if( hitElementSet.begin(), hitElementSet.end(), StEEmcAnlElement_t::isNotPositive );

a470 2
      for( elementSetIter = hitElementSet.begin(); elementSetIter != hitElementSet.end(); ++elementSetIter )
         totE += elementSetIter->getEnergy();
d472 5
a476 14
      /*
      if( !hitElementSet.empty() ){
         // this one is valid
         elementSetIter = hitElementSet.begin();
         totE += elementSetIter->getEnergy();

         for( ++elementSetIter; elementSetIter != hitElementSet.end(); ++elementSetIter ){
            if( elementSetIter->getEnergy() > 0 ) {
               totE += elementSetIter->getEnergy();
            } else {
               elementSetIterCopy = elementSetIter;
               --elementSetIter;
               hitElementSet.erase( elementSetIterCopy );
            };
d479 3
a481 1
      */
d499 4
a502 4
   // some iterators
   AnlEMPointVec_t pointVec;
   AnlEMPointVec_t::iterator pointVecIter;
   StEEmcAnlHitList_t::iterator hitIter;
d505 2
a506 2
   // for the new hits
   StEEmcAnlHitList_t newHitList;
d509 1
d511 1
a511 4
      AnlEMPoint_t sum( 0, 0, 0 );

      // find all points where strips in this hit intersect
      getIntersectingPointSet( *hitIter, pointVec, sum );
d513 1
a513 7
      // make a copy for the mean
      AnlEMPoint_t mean( sum );

      if( sum.W() ){
         mean.X() /= mean.W();
         mean.Y() /= mean.W();
      };
d515 2
a516 67
      Float_t varX = 0, varY = 0, varXY = 0, sumW2 = 0;

#ifdef DEBUG
      LOG_INFO << "III. mean position of intersections = (" << mean.X() << ' ' << mean.Y() << ")" << endm;
#endif

      // compute covariance
      for( pointVecIter = pointVec.begin(); pointVecIter != pointVec.end(); ++pointVecIter ){
         Float_t tempX = ( pointVecIter->X() - mean.X() );
         Float_t tempY = ( pointVecIter->Y() - mean.Y() );
         Float_t w = pointVecIter->W(); // faster?

         //std::cout << "zzz " << w << ' ' << pointVecIter->X() << ' ' << pointVecIter->Y() << ", " << tempX << ' ' << tempY << std::endl;

         varX += w*tempX*tempX;
         varY += w*tempY*tempY;
         varXY += w*tempX*tempY;
         sumW2 += w*w;
      };

      Float_t lambda = 0;
      Float_t tanAngle = 0;

      if( sumW2 ){
         //LOG_INFO << "Covariance before normalization: " << varX << ' ' << varY << ' ' << varXY << " | " << sum.W() << ' ' << sumW2 << endm;
         Float_t normFactor = sum.W() / ( sum.W()*sum.W() + sumW2 );

         LOG_INFO << "normFactor = " << normFactor*sum.W() << endm;

         varX *= normFactor;
         varY *= normFactor;
         varXY *= normFactor;

         // solve for eigen value and rotation angle

         // default value if no covariance
         lambda = ( varX > varY ? varX : varY );

         if( varXY ){
            Float_t half_trace = varX + varY;
            half_trace /= 2;
            Float_t det = varX*varY - varXY*varXY;
            Float_t temp = half_trace*half_trace - det; 

            // give a litte rounding error tolerance
            if( temp < 0 && temp > -1e-3 )
               temp = 0;

            //LOG_INFO << "half_trace = " << half_trace << ", det = " << det << ", lambda = " << half_trace << " + sqrt(" << temp << ")" << endm;

            if( temp >= 0 )
               lambda = half_trace + sqrt( temp );

            tanAngle = ( lambda - varX ) / varXY;

#ifdef DEBUG
            LOG_INFO << "st. dev = " << sqrt(varX) << ' ' << sqrt(varY) << ", cov. " << varXY << ", cor. " << varXY/sqrt(varX*varY) << ", lambda = " << lambda << ", tanAngle = " << tanAngle << endm;
#endif
         };
      };

      if( lambda > mMaxEigenvalue ){
#ifdef DEBUG
         LOG_INFO << GetEventNumber() << ": Splitting hit at (" << hitIter->getX() << ", " << hitIter->getY() << "), eigenvalue is " << lambda << endm;
#endif

         // make new hits into new list
d526 2
a527 2
         // weird bug: shouldn't need the const cast here

a530 1

d536 2
a537 10
         // reset the (x,y) position
         Float_t xOffset = 0, yOffset = 0;

         if( varXY ){
            xOffset = sqrt( lambda / (1 + tanAngle*tanAngle) );
            yOffset = xOffset*tanAngle;
         } else {
            xOffset = ( varX > varY ? sqrt(varX) : 0 );
            yOffset = ( varY > varX ? sqrt(varY) : 0 );
         };
d539 1
a539 2
         newHit1.setXY( newHit1.getX()+xOffset, newHit1.getY()+yOffset );
         newHit2.setXY( newHit2.getX()-xOffset, newHit2.getY()-yOffset );
d562 2
a602 81
// Get all points where strips in a hit "could" intersect, so that one
// can compute the covariance in the divide strips member function.
// Weight should be set to membership weight, not the energy
void StEEmcHitMakerAnlEM_t::getIntersectingPointSet( const StEEmcAnlHit_t& hit, AnlEMPointVec_t& pointVec, AnlEMPoint_t& sum ){
   sum.X() = 0;
   sum.Y() = 0;
   sum.W() = 0;

   TVector3 temp3vec;

   const StEEmcAnlElementSet_t stripSet = hit.getStripSet();

   AnlEMLineParamsVec_t lineParamsVec;
   AnlEMLineParamsVec_t::iterator lineParamsIter;

   Float_t thres = 0;

   if( hit.getStripSet().size() ){
      // set to 1/10ths the average strip height
      thres = 0.1 * hit.getEsmd()/hit.getStripSet().size();
   }

   StEEmcAnlElementSet_t::const_iterator stripSetIter1;
   for( stripSetIter1 = stripSet.begin(); stripSetIter1 != stripSet.end(); ++stripSetIter1 ){

      Bool_t layerIsV;
      Short_t sector1, strip;
      Float_t a1, b1;
      StEEmcPointMap_t::instance().getStripLineParam( stripSetIter1->getGeoId(), a1, b1 );
      StEEmcGeoId_t::decodeSmd( stripSetIter1->getGeoId(), sector1, layerIsV, strip );

      //Float_t hitE = stripSetIter1->getEnergy();
      //Float_t stripE = getStripDepositedEnergy( stripSetIter1->getGeoId() );
      //Float_t w1 = ( stripE ? hitE / stripE : 0 );
      //Float_t w1 = hitE;
      //Float_t w1 = (stripSetIter1->getEnergy() > mStripMinWeight ? log( stripSetIter1->getEnergy()/mStripMinWeight ) : 0 );
      Float_t w1 = (stripSetIter1->getEnergy() > thres ? log( stripSetIter1->getEnergy()/thres ) : 0 );

      //cout << "line for strip " << stripSetIter1->getGeoId() << ' '  << a1 << ' ' << b1 << ", layer = " << layerIsV << endl;

      // don't push back these values until after the loop, to avoid looking for the intersection of a strip with itself

      // use the previously computed values
      for( lineParamsIter = lineParamsVec.begin(); lineParamsIter != lineParamsVec.end(); ++lineParamsIter ){
         const Int_t &sector2 = lineParamsIter->sector();
         const Float_t &a2 = lineParamsIter->a();
         const Float_t &b2 = lineParamsIter->b();

         // make sure in same or adjacent sectors, but not parallel
         if( a1 != a2 && TMath::Abs(sector2-sector1) < 2 ){
            Float_t x = ( b1 - b2 ) / ( a2 - a1 );
            Float_t y = a1*x + b1;

            Float_t w = w1 * lineParamsIter->weight();

            Float_t rSq = x*x + y*y;
            if( rSq > mInnerRsq && rSq < mOuterRsq ){

               //cout << "hit " << hit.getKey() << ", intersection: (" << x << ", " << y << "), " << w << endl;

               // do not check if strips really cross
               //             if( x > std::min( x1start, x1stop ) && 
               //                 x > std::min( x2start, x2stop ) && 
               //                 x < std::max( x1start, x1stop ) && 
               //                 x < std::max( x2start, x2stop ) ){

               pointVec.push_back( AnlEMPoint_t( w, x, y ) );

               sum.X() += x*w;
               sum.Y() += y*w;
               sum.W() += w;
            };
         };
      };

      lineParamsVec.push_back( AnlEMLineParams_t( sector1, w1, a1, b1 ) );
   };

   return;
};

d674 1
a674 1
            cout << "bbmm = " << offsetVec[0] << ' ' << offsetVec[1] << ' ' << slopeVec[0] << ' ' << slopeVec[1] << endl;
d960 1
a960 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.9 2011/11/08 22:22:15 sgliske Exp $
d963 3
@


1.9
log
@daily update
@
text
@d389 1
a389 1
         //LOG_INFO << "Hit " << hitIter->getKey() << ", geoId " << *geoIdSetIter << ", weight = " << w << endm;
d411 5
a415 4
      if( !totW ){
         LOG_ERROR << "SANITY CHECK FAILURE: total weight is zero" << endm;
         totW = 1;
      };
d453 2
a454 1
   // need to purge from the hits any strips/towers that have zero energy
d456 1
d464 3
a466 3
      // make sure at least the first one is non-zero
      while( !hitElementSet.empty() && hitElementSet.begin()->getEnergy() <= 0 )
         hitElementSet.erase( hitElementSet.begin() );
d469 2
d472 1
d488 1
d555 1
a555 1
         Float_t normFactor = 1 / ( sum.W()*sum.W() + sumW2 );
d557 1
a557 1
         //LOG_INFO << "normFactor = " << normFactor << endm;
d668 7
d682 1
d706 7
d722 1
a722 1
      Float_t hitE = stripSetIter1->getEnergy();
d725 3
a727 1
      Float_t w1 = hitE;
d749 1
a749 1
               //cout << "intersection: (" << x << ", " << y << "), " << w << endl;
d809 14
a822 12
         slopeToIdxMapIter = slopeToIdxMap.find( a );
         if( slopeToIdxMapIter == slopeToIdxMap.end() ){
            slopeVec.push_back( a );
            offsetVec.push_back( e*b );
            energyVec.push_back( e );
            nStripsVec.push_back( 1 );
            slopeToIdxMap[ a ] = slopeVec.size()-1;
         } else {
            Int_t idx = slopeToIdxMapIter->second;
            offsetVec[ idx ] += e*b;
            energyVec[ idx ] += e;
            nStripsVec[ idx ] += 1;
d843 1
d962 4
d969 3
d1129 1
a1129 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.8 2011/11/07 22:08:04 sgliske Exp $
d1132 3
@


1.8
log
@daily update
@
text
@d10 1
a10 1
//#define DEBUG
d64 1
a64 1
   // set flags to correct data copied over in StEEmcHitMaker::Make
d325 1
d332 1
d420 1
a420 12
      Float_t E = 0;
      if( doTowers )
         elementSetIter = mTowerDepositedEnergy.upper_bound( StEEmcAnlElement_t( geoId2weightPtrMapIter->first, 0 ) );
      else
         elementSetIter = mStripDepositedEnergy.upper_bound( StEEmcAnlElement_t( geoId2weightPtrMapIter->first, 0 ) );

      // go back one, since upper_bound is the first one past the right spot
      if( elementSetIter != mStripDepositedEnergy.begin() )
         --elementSetIter;

      if( elementSetIter->getGeoId() == geoId2weightPtrMapIter->first )
         E = elementSetIter->getEnergy();
d564 1
a564 1
            Float_t det = varX*varY - 2*varXY;
d571 2
d579 1
a579 1
            LOG_INFO << "st. dev = " << sqrt(varX) << ' ' << sqrt(varY) << ", lambda = " << lambda << ", tanAngle = " << tanAngle << endm;
d676 3
a678 1
// get all points where strips in a hit "could" intersect, so that one can compute the covariance in the divide strips member function
d700 5
d719 2
a720 1
            Float_t w = stripSetIter1->getEnergy() * lineParamsIter->energy();
d742 1
a742 1
      lineParamsVec.push_back( AnlEMLineParams_t( sector1, stripSetIter1->getEnergy(), a1, b1 ) );
d1026 1
d1052 1
d1059 33
d1095 1
a1095 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.7 2011/11/03 17:18:35 sgliske Exp $
d1098 3
@


1.7
log
@it compiles
@
text
@d10 2
d14 1
d33 1
d64 7
d72 1
a72 3

   Int_t ierr = kStOK;
   if( !mTowerClusterFinder ){
d108 18
d131 2
a132 1
   Int_t ierr = kStOk;
d138 17
d157 3
a159 1
      LOG_INFO << GetEventNumber() << " On iteration " << mIterNum << " of " << mMaxIters << endm;
d165 19
d188 15
d207 15
d226 15
d245 15
d287 1
a287 3

   // flag that tower clusters exist
   mDoClusterTower[ TOWER ] = 1;
d291 16
a306 1
   Int_t ierr = mTowerClusterFinder->find( towVec, mTowerClusterVec[ TOWER ] );
d334 4
d342 1
a342 1
         mStripDepositedEnergy.insert( StEEmcAnlElement_t( geoId, towerIter->energy() ) );
d345 4
d387 2
d410 1
a410 1
         LOG_ERROR << "SANITY CHECK FAILURE" << endm;
d414 2
d420 1
a420 1
         elementSetIter = mTowerDepositedEnergy.lower_bound( StEEmcAnlElement_t( geoId2weightPtrMapIter->first, 0 ) );
d422 6
a427 1
         elementSetIter = mStripDepositedEnergy.lower_bound( StEEmcAnlElement_t( geoId2weightPtrMapIter->first, 0 ) );
a430 3
      // renormalization factor
      Float_t factor = E/totW;

d433 18
a450 14
      Bool_t doneNormalizing = 0;
      for( Int_t nIter = 0; nIter <= mMaxRenormIters && !doneNormalizing; ++nIter ){
         // renormalize
         doneNormalizing = 1;
         for( weightPtrVecIter = geoId2weightPtrMapIter->second.begin(); weightPtrVecIter != geoId2weightPtrMapIter->second.end(); ++weightPtrVecIter ){
            *(*weightPtrVecIter) *= factor;

            if( *(*weightPtrVecIter) < minWeight && E ){
               totW -= *(*weightPtrVecIter);

               if( !totW ){
                  LOG_ERROR << "SANITY CHECK FAILURE" << endm;
                  E = 0;
                  totW = 1;
d453 1
a453 3
               factor = E/totW;
               *(*weightPtrVecIter) = 0;
               doneNormalizing = 0;
d456 2
d466 4
d477 1
d479 2
d492 3
d534 4
d544 2
d556 4
a559 1
         Float_t normFactor = sum.W() / ( sum.W()*sum.W() + sumW2 );
d585 3
d592 3
a594 1
         LOG_INFO << GetEventNumber() << ": Splitting hit at (" << hitIter->getX() << ", " << hitIter->getY() << ", eigenvalue is " << lambda << endm;
d599 1
d615 1
d689 2
d693 4
a696 1
   StEEmcAnlElementSet_t::const_iterator stripSetIter1, stripSetIter2;
d699 15
a713 2
      Float_t x1start, x1stop, y1start, y1stop, a1, b1;
      StEEmcPointMap_t::instance().getStripEndPoints( stripSetIter1->getGeoId(), x1start, x1stop, y1start, y1stop );
d715 5
a719 2
      a1 = (y1stop - y1start ) / ( x1stop - x1start );
      b1 = y1start - a1 * x1start;
d721 2
a722 1
      for( stripSetIter2 = stripSet.begin(); stripSetIter2 != stripSetIter1; ++stripSetIter2 ){
d724 1
a724 2
         Float_t x2start, x2stop, y2start, y2stop, a2, b2;
         StEEmcPointMap_t::instance().getStripEndPoints( stripSetIter2->getGeoId(), x2start, x2stop, y2start, y2stop );
d726 5
a730 2
         a2 = (y2stop - y2start ) / ( x2stop - x2start );
         b2 = y2start - a2 * x2start;
d732 1
a732 4
         if( a1 != a2 ){
            Float_t x = ( b1 - b2 ) / ( a2 - a1 );
            Float_t y = a1*x + b1;
            Float_t w = stripSetIter1->getEnergy() * stripSetIter2->getEnergy();
d734 4
a737 11
            // do not check if strips really cross
            //             if( x > std::min( x1start, x1stop ) && 
            //                 x > std::min( x2start, x2stop ) && 
            //                 x < std::max( x1start, x1stop ) && 
            //                 x < std::max( x2start, x2stop ) ){

            pointVec.push_back( AnlEMPoint_t( w, x, y ) );

            sum.X() += x*w;
            sum.Y() += y*w;
            sum.W() += w;
d740 2
d774 3
a776 1
         Float_t x1start, x1stop, y1start, y1stop;
d778 1
a778 1
         StEEmcPointMap_t::instance().getStripEndPoints( stripSetIter->getGeoId(), x1start, x1stop, y1start, y1stop );
d780 3
a782 3
         Float_t a = (y1stop - y1start ) / ( x1stop - x1start );  // slope
         Float_t b = y1start - a * x1start;                       // offset
         Float_t e = stripSetIter->getEnergy();
d787 1
a787 1
            offsetVec.push_back( b );
d790 1
a790 1
            slopeToIdxMap[ a ] = slopeVec.size();
d793 1
a793 1
            offsetVec[ idx ] += b;
d799 4
d804 1
a804 1
      if( slopeVec.size() > 2 ){
d808 2
a809 3
            Float_t n = nStripsVec[i];
            offsetVec[i] /= n;
            energyVec[i] /= n;
d877 4
d889 2
a890 1
         Float_t dist = hitIter1->getDistToHit( *hitIter2 );
d892 10
a901 7
         // insert so that the list is always ordered
         if( distMatrix.empty() ){
            distMatrix.push_back( StEEmcAnlDistMatrixElement_t( dist, hitIter1->getKey(), hitIter2->getKey() ) );
         } else {
            StEEmcAnlDistMatrixElement_t element( dist, hitIter1->getKey(), hitIter2->getKey() );
            distMatrixIter = std::lower_bound( distMatrix.begin(), distMatrix.end(), element );
            distMatrix.insert( distMatrixIter, StEEmcAnlDistMatrixElement_t( dist, hitIter1->getKey(), hitIter2->getKey() ) );
d909 10
a918 1
   while( distMatrix.front().getDist() < mMinHitDist ){
d927 3
a929 1
         LOG_INFO << "merging hits " << distMatrix.front().getIdx1() << " and " << distMatrix.front().getIdx2() << ", distance = " << distMatrix.front().getDist() << endm;
d945 9
d955 2
a956 2
         for( hitIter2 = mAnlHitList.begin(); hitIter2 != mAnlHitList.end(); ++hitIter1 ){
            if( hitIter2->getKey() != hit1->getKey() ){
d965 1
a965 1
                  distMatrix.insert( distMatrixIter, StEEmcAnlDistMatrixElement_t( dist, hitIter1->getKey(), hitIter2->getKey() ) );
d972 3
d979 1
a979 2
   LOG_INFO << "NOT YET PROGRAMMED" << endm;
   LOG_INFO << "will just stop when it hits the max number of iterations" << endm;
d981 4
a984 1
   return kStOk;
d988 66
a1053 2
   LOG_INFO << "NOT YET PROGRAMMED" << endm;
   return kStFatal;
d1059 1
a1059 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.6 2011/11/03 17:12:59 sgliske Exp $
d1062 3
@


1.6
log
@it compiles
@
text
@a98 18

//    if( !ierr && mStripDistFunc && mStripDistFunc->IsZombie() ){
//       LOG_FATAL << ClassName() << "::Init() -- strip distance function is a zombie" << endm;
//       ierr = kStFatal;
//    };
//    if( !ierr && mStripDistFunc && mTowerDistFunc->IsZombie() ){
//       LOG_FATAL << ClassName() << "::Init() -- tower distance function is a zombie" << endm;
//       ierr = kStFatal;
//    };
//    if( !ierr && !mPointDistFunc ){
//       LOG_FATAL << ClassName() << "::Init() -- no point distance function provided" << endm;
//       ierr = kStFatal;
//    };
//    if( !ierr && mPointDistFunc->IsZombie() ){
//       LOG_FATAL << ClassName() << "::Init() -- point distance function is a zombie" << endm;
//       ierr = kStFatal;
//    };

d110 3
a112 3
   Int_t iterNum = 0;
   for( iterNum = 0; iterNum<mMaxIters && doContinue && !ierr; ++iterNum ){
      LOG_INFO << GetEventNumber() << " On iteration " << iterNum << " of " << mMaxIters << endm;
a146 1
   StEEmcAnlHit_t::resetKeyNumbering();
d154 1
d745 3
a747 1
   return kStFatal;
d758 1
a758 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.5 2011/11/02 22:04:45 sgliske Exp $
d761 3
@


1.5
log
@update
@
text
@d28 2
d593 1
a593 1
         Float_t x1start, x1stop, y1start, y1stop, a1, b1;
d595 1
a595 1
         StEEmcPointMap_t::instance().getStripEndPoints( stripSetIter1->getGeoId(), x1start, x1stop, y1start, y1stop );
d598 2
a599 1
         Float_t b = y1start - a1 * x1start;                      // offset
d695 1
a695 1
      hitMap[ hitIter1->getKey() ] = *(*hitIter1);
d699 1
a699 1
         Float_t dist = hitIter1->getDistToHit( *histIter2 );
d712 2
d736 3
a738 4
         StEEmcAnlDistMatrixPruner_t::setIdx1( distMatrix.front().getIdx1() );
         StEEmcAnlDistMatrixPruner_t::setIdx2( distMatrix.front().getIdx2() );

         distMatrix.remove_if( StEEmcAnlDistMatrixPruner_t() );
d742 2
a743 2
            if( hitIter2->getKey() !+ hit1->getKey() ){
               Float_t dist = hit1->getDistToHit( *histIter2 );
d774 1
a774 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.4 2011/11/02 20:54:24 sgliske Exp $
d777 3
@


1.4
log
@update
@
text
@d163 1
a566 1

d671 84
a754 2
   LOG_INFO << "NOT YET PROGRAMMED" << endm;
   return kStFatal;
d770 1
a770 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.3 2011/10/26 21:37:35 sgliske Exp $
d773 3
@


1.3
log
@Working on ANL EM Algo
@
text
@d27 1
a36 1
   //mStripDistFunc(0),
a39 1
   //mTowerDistFunc(0),
d42 3
a44 1
   mMaxRenormIters(2)
d69 29
d168 2
d252 2
a253 2
               hitIter->getEsmd()*TowIntegral( *geoIdSetIter, *hitIter ) :
               hitIter->getE()   *SmdIntegral( *geoIdSetIter, *hitIter ) );
a352 10
Float_t TowIntegral( Short_t geoId, const StEEmcAnlHit_t& hitPtr ){
   LOG_INFO << "NOT YET PROGRAMMED" << endm;
   return 0;
};

Float_t SmdIntegral( Short_t geoId, const StEEmcAnlHit_t& hitPtr ){
   LOG_INFO << "NOT YET PROGRAMMED" << endm;
   return 0;
};

a356 1
   StEEmcAnlHitList_t::iterator hitIter;
d359 5
d367 1
a367 1
      AnlEMPoint_t mean( 0, 0, 0 );
d370 11
a380 1
      getIntersectingPointSet( *hitIter, pointVec, mean );
d384 118
a501 1
         LOG_INFO << "NOT YET PROGRAMMED" << endm;
d505 5
a509 2
   LOG_INFO << "NOT YET PROGRAMMED" << endm;
   ierr = kStFatal;
d516 4
a519 4
void StEEmcHitMakerAnlEM_t::getIntersectingPointSet( const StEEmcAnlHit_t& hit, AnlEMPointVec_t& pointVec, AnlEMPoint_t& mean ){
   mean.X() = 0;
   mean.Y() = 0;
   mean.W() = 0;
d553 3
a555 3
            mean.X() += x*w;
            mean.Y() += y*w;
            mean.W() += w;
a559 5
   if( mean.W() ){
      mean.X() /= mean.W();
      mean.Y() /= mean.W();
   };

a565 8
   // need to divide strips into sectors
   std::map< Short_t, StEEmcAnlElementPtrSet_t > sectorStripMap;
   std::map< Short_t, StEEmcAnlElementPtrSet_t >::iterator sectorStripMapIter;

   std::set< Short_t > usedSectors;
   std::set< Short_t >::iterator usedSectorsIter;
   Int_t numUstripsPerSector[kEEmcNumSectors];
   Int_t numVstripsPerSector[kEEmcNumSectors];
d569 9
a577 1
   StEEmcAnlElementSet_t::iterator stripIter;
d581 1
d583 28
a610 5
      sectorStripMap.clear();
      usedSectors.clear();
      for( Int_t *p1 = numUstripsPerSector, *p2 = numVstripsPerSector; p1 != &numUstripsPerSector[kEEmcNumSectors]; ++p1, ++p2 ){
         (*p1) = 0;
         (*p2) = 0;
d613 2
a614 10
      // loop over strips to see how many in which sectors
      StEEmcAnlElementSet_t& hitStripSet = hitIter->getStripSet();
      for( ++stripIter; stripIter != hitStripSet.end(); ++stripIter ){
         Short_t sector;
         Bool_t layerIsV;
         Short_t strip;

         StEEmcGeoId_t::decodeSmd( stripIter->getGeoId(), sector, layerIsV, strip );
         usedSectors.insert( sector );
         ++( layerIsV ? numVstripsPerSector[sector] : numUstripsPerSector[sector] );
d616 5
a620 16
         // encode both sector and layer into the map key
         if( layerIsV )
            sector += kEEmcNumSectors;

         sectorStripMap[ sector ].insert( &(*stripIter) );
      };

      // try the usual cases
      Bool_t validHit = 0;
      Float_t x = 0, y = 0;
      if( usedSectors.size() == 1 ){
         Int_t sector = *(usedSectors.begin());

         if( numUstripsPerSector[sector] && numVstripsPerSector[sector] ){
            // both u and v exist and are in the same sector
            ierr = estimatePositionSingleSector( sectorStripMap[ sector ], x, y );
a621 3
         validHit = 1;
      } else if ( usedSectors.size() == 2 ){
         usedSectorsIter = usedSectors.begin();
d623 1
a623 2
         Int_t sector1 = *(usedSectorsIter);
         Int_t sector2 = *(++usedSectorsIter);
d625 27
a651 14
         Short_t deltaSectors = (sector1 - sector2 + kEEmcNumSectors) % kEEmcNumSectors;
         if( deltaSectors == 1 ){
            ierr = estimatePositionSplitSector( *hitIter, x, y );
            validHit = 1;
         };
      };

      // if not any of the usual cases
      if( !validHit ){
         Int_t sum = -1;
         Int_t bigSector = -1;
         LOG_ERROR << "Error: hit involves the strips from the following sectors" << endm;
         for( Int_t sector = 0; sector < kEEmcNumSectors; ++sector ){
            LOG_ERROR << sector << ": " << numUstripsPerSector[sector] << ", " << numVstripsPerSector[sector] << endm;
d653 2
a654 3
            Int_t localSum = numUstripsPerSector[sector] + numVstripsPerSector[sector];
            if( localSum > sum )
               bigSector = sector;
d656 3
a658 9

         // default to using the sector with the most amount of strips, and ignore other sectors
         ierr = estimatePositionSingleSector( sectorStripMap[ bigSector ], x, y );
      };

      // invalidate hit if error
      if( ierr ){
         x = 0;
         y = 0;
a660 3
      // set position
      hitIter->setXY( x, y );

d664 2
a665 33
   return ierr;
};

Int_t StEEmcHitMakerAnlEM_t::estimatePositionSingleSector( const StEEmcAnlElementPtrSet_t& stripSet, Float_t& x, Float_t& y ){
   Int_t ierr = 0;
   Float_t uPos = 0, vPos = 0, uWeight, vWeight;
   Short_t sector = -1;

   StEEmcAnlElementPtrSet_t::const_iterator stripSetIter;
   for( stripSetIter = stripSet.begin(); stripSetIter != stripSet.end(); ++stripSetIter ){
      Bool_t layerIsV;
      Short_t strip;

      StEEmcGeoId_t::decodeSmd( (*stripSetIter)->getGeoId(), sector, layerIsV, strip );
      if( layerIsV ){
         vPos += (*stripSetIter)->getEnergy() * strip;
         vWeight += (*stripSetIter)->getEnergy();
      } else {
         uPos += (*stripSetIter)->getEnergy() * strip;
         uWeight += (*stripSetIter)->getEnergy();
      };
   };

   x = 0;
   y = 0;
   if( vWeight && uWeight ){
      uPos /= uWeight;
      vPos /= vWeight;

      TVector3 direct = EEmcSmdGeom::instance()->getIntersection( sector, uPos, vPos );
      x = direct.X();
      y = direct.Y();
   };
a669 25
Int_t StEEmcHitMakerAnlEM_t::estimatePositionSplitSector( const StEEmcAnlHit_t& hit, Float_t& x, Float_t& y ){
//    StEEmcAnlHit_t::setActiveHit( &hit );
//    mMinuit->SetFCN( &StEEmcAnlHit_t::meanSquaredDcaMinuitFunc );
//    Int_t ierflg = 0;
//    mMinuit->mnparm(0, "x", hit.getX(), mMinuitStepSize, 0, 0, ierflg);
//    mMinuit->mnparm(1, "y", hit.getY(), mMinuitStepSize, 0, 0, ierflg);

//    // minimize
//    Double_t arglist[2] = { mMaxMinuitIters, mMinuitTolerance };
//    mMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
//    Double_t err, X, Y;

//    mMinuit->GetParameter( 0, X, err );
//    mMinuit->GetParameter( 1, Y, err );

//    // copy double to float
//    x = X;
//    y = Y;

//    return ierflg;
   return kStFatal;
};



d688 1
a688 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.2 2011/09/01 21:52:49 sgliske Exp $
d691 3
@


1.2
log
@Working on ANL EM Algo -- still
@
text
@d35 2
a36 2
   mStripMinWeight(1e-3),
   mStripDistFunc(0),
d40 1
a40 1
   mTowerDistFunc(0),
d43 6
a48 6
   mMaxRenormIters(2),
   mMaxMinuitIters(50),
   mMinuitTolerance(0.1),
   mMinuitStepSize(0.1){ 
   mMinuit = new TMinuit(2);
};
d52 1
a52 1
   delete mMinuit;
d68 17
a84 8
   if( !ierr && mStripDistFunc && mStripDistFunc->IsZombie() ){
      LOG_FATAL << ClassName() << "::Init() -- strip distance function is a zombie" << endm;
      ierr = kStFatal;
   };
   if( !ierr && mStripDistFunc && mTowerDistFunc->IsZombie() ){
      LOG_FATAL << ClassName() << "::Init() -- tower distance function is a zombie" << endm;
      ierr = kStFatal;
   };
d93 1
d100 1
d104 1
d108 1
d112 1
d116 1
a116 3
      if(!ierr)
         ierr = estimateEnergy();

d120 1
d136 2
d140 1
a157 1

d214 1
a214 1
      // loop over all the strips/towers for this hit
d219 3
a221 9
         if( doTowers ){
            w = hitIter->getEuv();
            if( mTowerDistFunc )
               w *= mTowerDistFunc->Eval( StEEmcPointMap_t::instance().getTowerDCA( hitIter->getX(), hitIter->getY(), *geoIdSetIter ) );
         } else {
            w = hitIter->getE();
            if( mStripDistFunc )
               w *= mStripDistFunc->Eval( StEEmcPointMap_t::instance().getStripDCA( hitIter->getX(), hitIter->getY(), *geoIdSetIter ) );
         };
d230 2
a231 1
   // adjust threshold
d248 2
a249 1
      // need correct sum of energies
a254 1

d289 1
a289 1
   for( hitIter = mAnlHitList.begin(); hitIter != mAnlHitList.end(); ++hitIter, ++hitIdx ){
d296 1
a296 1
      Float_t totE = 0, totEv = 0;
d301 1
a301 1
            if( doTowers ){
a303 7
               Short_t sector, strip;
               Bool_t layerIsV;
               StEEmcGeoId_t::decodeSmd( stripIter->getGeoId(), sector, layerIsV, strip );
               ( layerIsV ? totEv : totE ) += elementSetIter->getEnergy();
            };

            if( elementSetIter->getEnergy() <= 0 ){
d312 1
a312 1
      if( doTowers ){
d314 35
a348 3
      } else {
         hitIter->setEu( totE );
         hitIter->setEu( totEv );
d352 3
d358 54
d547 17
a563 17
   StEEmcAnlHit_t::setActiveHit( &hit );
   mMinuit->SetFCN( &StEEmcAnlHit_t::meanSquaredDcaMinuitFunc );
   Int_t ierflg = 0;
   mMinuit->mnparm(0, "x", hit.getX(), mMinuitStepSize, 0, 0, ierflg);
   mMinuit->mnparm(1, "y", hit.getY(), mMinuitStepSize, 0, 0, ierflg);

   // minimize
   Double_t arglist[2] = { mMaxMinuitIters, mMinuitTolerance };
   mMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
   Double_t err, X, Y;

   mMinuit->GetParameter( 0, X, err );
   mMinuit->GetParameter( 1, Y, err );

   // copy double to float
   x = X;
   y = Y;
d565 2
a566 5
   return ierflg;
};

Int_t StEEmcHitMakerAnlEM_t::divideHits(){
   LOG_INFO << "NOT YET PROGRAMMED" << endm;
a568 34
// get all points where strips in a hit "could" intersect, so that one can compute the covariance in the divide strips member function
void StEEmcHitMakerAnlEM_t::getIntersectingPointSet( const StEEmcAnlHit_t& hit, std::vector< AnlEMPoint_t >& pointVec, Float_t& meanX, Float_t& meanY, Float_t& totW ){
   meanX = 0;
   meanY = 0;
   totW = 0;

   StEEmcAnlElementPtrSet_t::const_iterator stripSetIter1, stripSetIter2;
   for( stripSetIter1 = stripSet.begin(); stripSetIter1 != stripSet.end(); ++stripSetIter1 ){

      Float_t x1start, x1stop, y1start, y1stop, a1, b1;
      StEEmcPointMap_t::instance().getStripEndPoints( stripSetIterA->getGeoId(), x1start, x1stop, y1start, y1stop );

      a1 = (y1stop - y1start ) / ( x1stop - x1start );
      b1 = y1start - a1 * x1start;

      for( stripSetIter2 = stripSet.begin(); stripSetIter2 != stripSetIter1; ++stripSetIter2 ){

         Float_t x2start, x2stop, y2start, y2stop, a2, b2;
         StEEmcPointMap_t::instance().getStripEndPoints( stripSetIterA->getGeoId(), x2start, x2stop, y2start, y2stop );

         a2 = (y2stop - y2start ) / ( x2stop - x2start );
         b2 = y2start - a2 * x2start;

         if( a1 != a2 ){
            Float_t x = ( b1 - b2 ) / ( a2 - a1 );
            Float_t y = a1*x + b1;
            Float_t w = stripSetIter1->getEnergy() * stripSetIter2->getEnergy();

            // do not check if strips really cross
            //             if( x > std::min( x1start, x1stop ) && 
            //                 x > std::min( x2start, x2stop ) && 
            //                 x < std::max( x1start, x1stop ) && 
            //                 x < std::max( x2start, x2stop ) ){

a569 16
            pointVec.push_back( AnlEmPoint_t( w, x, y ) );

            meanX += x*w;
            meanY += y*w;
            totW += w;
         };
      };
   };

   if( totW ){
      meanX /= totW;
      meanY /= totW;
   };

   return;
};
d573 1
d578 1
d583 1
d589 1
a589 1
 * $Id: StEEmcHitMakerAnlEM.cxx,v 1.1 2011/08/31 22:05:43 sgliske Exp $
d592 3
@


1.1
log
@Working on ANL EM Algo
@
text
@d17 3
d43 6
a48 1
   mStripMaxRenormIters(0) { /* */ };
d51 3
a53 1
StEEmcHitMakerAnlEM_t::~StEEmcHitMakerAnlEM_t(){ /* */ };
d91 1
a91 1
         ierr = updateStripEnergies();
d100 1
a100 1
         ierr = updateTowerEnergies();
d174 1
a174 1
Int_t StEEmcHitMakerAnlEM_t::updateStripEnergies(){
d177 3
a179 3
   // container to store all hits for a given strip
   std::map< Short_t, std::vector< Float_t* > > strip2weightPtrMap;
   std::map< Short_t, std::vector< Float_t* > >::iterator strip2weightPtrMapIter;
d182 3
a184 3
   // container for holding sets of strips, and its iterator
   std::set< Short_t > stripSet;
   std::set< Short_t >::iterator stripSetIter;
d190 5
a194 2
      // get the nearby strips
      mPointMap.getStripsNearPoint( hitIter->getX(), hitIter->getY(), mStripInclDist, stripSet );
d196 2
a197 2
      StEEmcAnlElementSet_t& hitStripSet = hitIter->getStripSet();
      hitStripSet.clear();
d199 2
a200 2
      // loop over all the strips for this hit
      for( stripSetIter = stripSet.begin(); stripSetIter != stripSet.end(); ++stripSetIter ){
d202 11
a212 3
         Float_t w = hitIter->getE();
         if( mStripDistFunc )
            w *= mStripDistFunc->Eval( mPointMap.getStripDCA( hitIter->getX(), hitIter->getY(), *stripSetIter ) );
d214 1
a214 1
         std::pair< StEEmcAnlElementSet_t::iterator, Bool_t > returnPair = hitStripSet.insert( StEEmcAnlElement_t( *stripSetIter, w ) );
d217 1
a217 1
         strip2weightPtrMap[ *stripSetIter ].push_back( const_cast< StEEmcAnlElement_t* >( &(*returnPair.first) )->getEnergyPtr() );
d222 2
a223 2
   if( mStripMaxRenormIters < 0 )
      mStripMaxRenormIters = 0;
d225 3
a227 3
   // need to normalize the energy of each strip
   StEEmcAnlElementSet_t::iterator stripIter;
   for( strip2weightPtrMapIter = strip2weightPtrMap.begin(); strip2weightPtrMapIter != strip2weightPtrMap.end(); ++strip2weightPtrMapIter ){
d230 1
a230 1
      for( weightPtrVecIter = strip2weightPtrMapIter->second.begin(); weightPtrVecIter != strip2weightPtrMapIter->second.end(); ++weightPtrVecIter )
d240 7
a246 3
      stripIter = mStripDepositedEnergy.lower_bound( StEEmcAnlElement_t( strip2weightPtrMapIter->first, 0 ) );
      if( stripIter->getGeoId() == strip2weightPtrMapIter->first )
         E = stripIter->getEnergy();
d251 2
d254 1
a254 1
      for( Int_t nIter = 0; nIter <= mStripMaxRenormIters && !doneNormalizing; ++nIter ){
d257 1
a257 1
         for( weightPtrVecIter = strip2weightPtrMapIter->second.begin(); weightPtrVecIter != strip2weightPtrMapIter->second.end(); ++weightPtrVecIter ){
d260 1
a260 1
            if( *(*weightPtrVecIter) < mStripMinWeight && E ){
d277 2
a278 2
   // need to purge from the hits any strips that have zero energy
   StEEmcAnlElementSet_t::iterator stripIterCopy;
d280 1
a280 1
      StEEmcAnlElementSet_t& hitStripSet = hitIter->getStripSet();
d283 4
a286 2
      while( !hitStripSet.empty() && hitStripSet.begin()->getEnergy() <= 0 )
         hitStripSet.erase( hitStripSet.begin() );
d288 10
a297 7
      if( !hitStripSet.empty() ){
         stripIter = hitStripSet.begin();
         for( ++stripIter; stripIter != hitStripSet.end(); ++stripIter ){
            if( stripIter->getEnergy() <= 0 ){
               stripIterCopy = stripIter;
               --stripIter;
               hitStripSet.erase( stripIterCopy );
d299 100
d400 3
d404 11
d420 32
a451 2
Int_t StEEmcHitMakerAnlEM_t::divideHits(){
   LOG_INFO << "NOT YET PROGRAMMED" << endm;
d454 20
a473 2
Int_t StEEmcHitMakerAnlEM_t::estimatePositions(){
   LOG_INFO << "NOT YET PROGRAMMED" << endm;
d476 1
a476 1
Int_t StEEmcHitMakerAnlEM_t::updateTowerEnergies(){
d480 50
a529 2
Int_t StEEmcHitMakerAnlEM_t::estimateEnergy(){
   LOG_INFO << "NOT YET PROGRAMMED" << endm;
d547 5
a551 1
 * $Id: $
a552 1
 * $Log: $
@

