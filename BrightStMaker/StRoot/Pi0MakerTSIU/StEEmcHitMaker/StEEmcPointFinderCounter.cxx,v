head	1.5;
access;
symbols
	response:1.4;
locks; strict;
comment	@// @;


1.5
date	2012.10.09.03.57.20;	author sgliske;	state dead;
branches;
next	1.4;

1.4
date	2011.12.15.22.21.18;	author sgliske;	state Exp;
branches;
next	1.3;

1.3
date	2011.12.15.22.03.44;	author sgliske;	state Exp;
branches;
next	1.2;

1.2
date	2011.12.15.20.59.52;	author sgliske;	state Exp;
branches;
next	1.1;

1.1
date	2011.12.15.18.06.02;	author sgliske;	state Exp;
branches;
next	;


desc
@@


1.5
log
@removed unused makers
@
text
@/*!
 * \class StEEmcPointFinderCounter_t
 * \author Stephen Gliske <sgliske@@anl.gov>
 *
 * See header for description.
 *
*/

#include <TMath.h>
#include <map>

#include "StRoot/St_base/StMessMgr.h"
#include "StRoot/St_base/Stypes.h"
#include "StEEmcPointFinderCounter.h"

//#define DEBUG

StEEmcPointFinderCounter_t::StEEmcPointFinderCounter_t() : StEEmcPointFinderTopo_t() {
   mNonZeroEvents = 0;
   for( Int_t i = 0; i < kMaxNum; ++ i )
      for( Int_t j = 0; j < kMaxNum; ++ j )
         mCounts[i][j] = 0;
};


StEEmcPointFinderCounter_t::~StEEmcPointFinderCounter_t() {
   cout << "CLUSTER TOPOLOGY COUNTS" << endl;
   for( Int_t i = 1; i < kMaxNum; ++ i )
      for( Int_t j = 1; j < kMaxNum; ++ j )
         cout << i << 'x' << j << ' ' << mCounts[i][j] << endl;
   cout << "NUMBER OF NONZERO EVENTS: " << endl;
   cout << "\t" << mNonZeroEvents << endl;

};

/// find some some points
Int_t StEEmcPointFinderCounter_t::find( const StSimpleClusterVec_t &towerClusterVec,
                                        const StESMDClustersVec_t &smdClusterVec,
                                        StEEmcHitVec_t& hitVec ) {

   mThisEventCouldMakeHits = 0;

   Int_t ierr = StEEmcPointFinderTopo_t::find( towerClusterVec, smdClusterVec, hitVec );

   if( !ierr && mThisEventCouldMakeHits > 0 )
      ++mNonZeroEvents;

   // return the error code
   return ierr;
};

// find points on a minimal set of u and v clusters
Int_t StEEmcPointFinderCounter_t::findHits( const StClusterPool_t& uClusPool, const StClusterPool_t& vClusPool, StEEmcHitVec_t& newHits ){

   // determine the topology
   Int_t nClusU = uClusPool.size();
   Int_t nClusV = vClusPool.size();

#ifdef DEBUG
   LOG_INFO << nClusU << 'x' << nClusV << endm;
#endif

   // a "real" point finder would now decide how to proceed
   // this on, instead, just counts
   if( nClusU >= kMaxNum )
      nClusU = kMaxNum - 1;
   if( nClusV >= kMaxNum )
      nClusV = kMaxNum - 1;

   ++mCounts[ nClusU ][ nClusV ];
   mThisEventCouldMakeHits += ( nClusU && nClusV );

   return kStOk;
};


ClassImp( StEEmcPointFinderCounter_t );

/*
 * $Id: StEEmcPointFinderCounter.cxx,v 1.4 2011/12/15 22:21:18 sgliske Exp $
 * $Log: StEEmcPointFinderCounter.cxx,v $
 * Revision 1.4  2011/12/15 22:21:18  sgliske
 * update
 *
 * Revision 1.3  2011/12/15 22:03:44  sgliske
 * Made child class of StEEmcPointFinderTopo_t
 *
 * Revision 1.2  2011/12/15 20:59:52  sgliske
 * upate
 *
 * Revision 1.1  2011/12/15 18:06:02  sgliske
 * creation
 *
 *
 */
@


1.4
log
@update
@
text
@d80 1
a80 1
 * $Id: StEEmcPointFinderCounter.cxx,v 1.3 2011/12/15 22:03:44 sgliske Exp $
d82 3
@


1.3
log
@Made child class of StEEmcPointFinderTopo_t
@
text
@d53 1
a53 1
Int_t StEEmcPointFinderCounter_t::findAssignments( const StClusterPool_t& uClusPool, const StClusterPool_t& vClusPool, StAssignmentVec_t& assignments ){
d80 1
a80 1
 * $Id: StEEmcPointFinderCounter.cxx,v 1.2 2011/12/15 20:59:52 sgliske Exp $
d82 3
@


1.2
log
@upate
@
text
@a13 6
#include "StRoot/StEEmcUtil/EEmcGeom/EEmcGeomDefs.h"
#include "StRoot/StEEmcUtil/EEmcGeom/EEmcGeomSimple.h"
#include "StRoot/StEEmcUtil/EEmcSmdMap/EEmcSmdMap.h"
#include "StRoot/StEEmcUtil/StEEmcSmd/EEmcSmdGeom.h"
#include "StRoot/StEEmcPool/StEEmcA2EMaker/StEEmcTower.h"

a14 6
#include "StFinderAlg.h"
#include "StSimpleCluster.h"
#include "StEEmcHit.h"
#include "StEEmcStripClusterFinder.h"
#include "StESMDClustersPerSector.h"
#include "StEEmcHitMaker.h"
d18 1
a18 5
StEEmcPointFinderCounter_t::StEEmcPointFinderCounter_t() : StEEmcPointFinder_t(), 
                                                           mTowerThreshold( 1.0 ) 
{
   mIsReady = 0;

d36 1
a36 18
Int_t StEEmcPointFinderCounter_t::setHitMakerPtr( StEEmcHitMaker_t *hitMakerPtr ){
   Int_t ierr = kStOK;

   if( !hitMakerPtr ){
      LOG_FATAL << "::SetHitMakerPtr(...) given invalid pointer." << endm;
      ierr = kStFatal;
   } else {
      mHitMakerPtr = hitMakerPtr;
      mIsReady = 1;
   };

   return ierr;
};


/// find some some points.  Note: input is towerClusterVec and
/// stripClusterVec results are stored in mHit, and the return Int_t
/// is an error code or kStOK.
d38 2
a39 2
                                   const StESMDClustersVec_t &smdClusterVec,
                                   StEEmcHitVec_t& hitVec ){
d41 1
a41 1
   Int_t ierr = kStOK;
d43 1
a43 1
   Int_t thisEventCouldMakeHits = 0;
d45 2
a46 2
   // Cluster pools
   StClusterPool_t uClusterPool, vClusterPool;
d48 3
a50 19
   // maps to get hits associated with given u or v cluster and the pointer to the cluster
   std::map< Int_t, std::pair< StSimpleCluster_t, StEEmcHitPtrVec_t > > uClus2HitMap;
   std::map< Int_t, std::pair< StSimpleCluster_t, StEEmcHitPtrVec_t > > vClus2HitMap;
   std::map< Int_t, std::pair< StSimpleCluster_t, StEEmcHitPtrVec_t > >::iterator clus2HitMapIter;
   StEEmcHitPtrVec_t::iterator hitPtrVecIter;

   // define some iterators
   StESMDClustersVec_t::const_iterator  smdClusterVecIter;
   StSimpleClusterVec_t::const_iterator uClusVecIter, vClusVecIter;
   StClusterPool_t::const_iterator      clusPoolIter;

   // last hit ID
   Int_t lastSMDhitID = -1;

   // iterate over sectors with at least one cluster
   for( smdClusterVecIter = smdClusterVec.begin(); smdClusterVecIter != smdClusterVec.end(); ++smdClusterVecIter ){
      Int_t sector = smdClusterVecIter->getSector();

      //LOG_INFO << "sector = " << sector << " (" << (Int_t)(smdClusterVecIter-smdClusterVec.begin()) << " of " << smdClusterVec.size() << ")" << endm;
d52 2
a53 5
      // clear the pools and maps
      uClusterPool.clear();
      vClusterPool.clear();
      uClus2HitMap.clear();
      vClus2HitMap.clear();
d55 3
a57 13
      // some references to make code cleaner
      const StSimpleClusterVec_t &uClusVec = smdClusterVecIter->getClusterVecU();
      const StSimpleClusterVec_t &vClusVec = smdClusterVecIter->getClusterVecV();

      //LOG_INFO << "--> Num clusters = " << uClusVec.size() << ' ' << vClusVec.size() << endm;

      // u layer
      for( uClusVecIter = uClusVec.begin(); uClusVecIter != uClusVec.end(); ++uClusVecIter )
         uClusterPool.insert( uClusVecIter->getID() );

      // v layer
      for( vClusVecIter = vClusVec.begin(); vClusVecIter != vClusVec.end(); ++vClusVecIter )
         vClusterPool.insert( vClusVecIter->getID() );
d60 1
a60 1
      LOG_INFO << "Have " << uClusterPool.size() << " u clus and " << vClusterPool.size() << " v clus" << endm;
d63 6
a68 76
      // First try finding all candidate hits.  Any pair of u & v
      // clusters under an "active" tower are considered candidates, with
      // "active" being defined below

      // containter for all possible hits to consider
      // Call these the stage 0 hits
      StEEmcHitVec_t hitsSMDstage0;

      // iterate over u and v clusters to make pairs
      for( uClusVecIter = uClusVec.begin(); uClusVecIter != uClusVec.end(); ++uClusVecIter ){
         for( vClusVecIter = vClusVec.begin(); vClusVecIter != vClusVec.end(); ++vClusVecIter ){

            // get mean position
            Float_t uSeedMean = uClusVecIter->getMeanX();
            Float_t vSeedMean = vClusVecIter->getMeanX();

            // determine which tower this SMD point/hit is under
            Bool_t isValid = 0;

            TVector3 position = EEmcSmdGeom::instance()->getIntersection( sector, uSeedMean, vSeedMean );
            Int_t sec,sub,eta;
            if( mEEmcGeomSimple.getTower(position,sec,sub,eta) ){
               // is valid tower so, check sectors agree
               isValid = ( sec == sector );
            };

            // tower ptr may return null if had no energy or it had fail bits set.
            const StEEmcTower *towerPtr = mHitMakerPtr->getTowerPtr( StEEmcHitMaker_t::TOWER, sec, sub, eta );
            isValid &= (towerPtr != 0);

            if( isValid )
               isValid = !towerPtr->fail() && towerPtr->energy() > mTowerThreshold;

            if( isValid ) {
               // push back a potential hit
               hitsSMDstage0.push_back( StEEmcHit_t(++lastSMDhitID) );

               // get reference
               StEEmcHit_t &hit = hitsSMDstage0.back();

               // set UV info
               hit.setEnergyU( uClusVecIter->getEnergy() );
               hit.setEnergyV( vClusVecIter->getEnergy() );
               hit.setClusIDu( uClusVecIter->getID() );
               hit.setClusIDv( vClusVecIter->getID() );
               hit.setTowerIdx( towerPtr->index() );

               // set sector
               hit.setSector( sector );

               // pre-compute ttest value
               hit.computeTtest2();

               // set position
               hit.setX( position.X() );
               hit.setY( position.Y() );
               hit.setZ( position.Z() );

               if( position.Z() < -998 ){
                  // bad pairing, remove the candidate hit
                  hitsSMDstage0.pop_back();
               } else {
                  // update maps
                  clus2HitMapIter = uClus2HitMap.find( uClusVecIter->getID() );
                  if( clus2HitMapIter == uClus2HitMap.end() ){
                     ( uClus2HitMap[ uClusVecIter->getID() ] = std::make_pair( (*uClusVecIter), StEEmcHitPtrVec_t() ) ).second.push_back( &hit );
                  } else {
                     clus2HitMapIter->second.second.push_back( &hit );
                  };

                  clus2HitMapIter = vClus2HitMap.find( vClusVecIter->getID() );
                  if( clus2HitMapIter == vClus2HitMap.end() ){
                     ( vClus2HitMap[ vClusVecIter->getID() ] = std::make_pair( (*vClusVecIter), StEEmcHitPtrVec_t() ) ).second.push_back( &hit );
                  } else {
                     clus2HitMapIter->second.second.push_back( &hit );
                  };
d70 2
a71 3
#ifdef DEBUG
                  LOG_INFO << "Hit with u clus ID " << uClusVecIter->getID() << " and v clus ID " << vClusVecIter->getID() << endm;
#endif
d73 1
a73 137
               };
            }; // end if( isValid )
         };
         // end loop over v clusters
      };
      // end loop over u v clusters

      //LOG_INFO << "At stage 0, exists " << hitsSMDstage0.size() << " candidates" << endm;

      // if not enough candidate hits, then give up trying (or if there was an error)
      // Note: this is not an error, but a stopping criteria
      if( hitsSMDstage0.empty() || ierr )
         return ierr;

      // the following is basically a while !uClusterPool.empty() with
      // a sanity check on the number of iterations
      Int_t maxN = uClusterPool.size()*2+10;
      for( Int_t i1 = 0; i1 < maxN && !uClusterPool.empty(); ++i1 ){
#ifdef DEBUG
         LOG_INFO << i1 << " Have " << uClusterPool.size() << " u clus and " << vClusterPool.size() << " v clus in the main pool" << endm;
#endif

         StClusterPool_t uPool2, uPoolNew, vPool2, vPoolNew, tempPool;

         // move the first cluster from the first to second u pools
         uPoolNew.insert(    *uClusterPool.begin() );
         uClusterPool.erase(  uClusterPool.begin() );

         // the following is basically a while !uPoolNew.empty() with
         // a sanity check on the number of iterations
         for( Int_t i2 = 0; i2 < maxN && !uPoolNew.empty(); ++i2 ){
            // for all the new u clusters, add all the corresponding v's
            for( clusPoolIter = uPoolNew.begin(); clusPoolIter != uPoolNew.end(); ++clusPoolIter ){
               StEEmcHitPtrVec_t& hitPtrVec = uClus2HitMap[ (*clusPoolIter) ].second;

               // iterate over hits associated with this u cluster, and add v clusters to the new v pool
               for( hitPtrVecIter = hitPtrVec.begin(); hitPtrVecIter != hitPtrVec.end(); ++hitPtrVecIter )
                  vPoolNew.insert( (*hitPtrVecIter)->getClusIDv() );
            };

            // compute union of uPoolNew and uPool2, store result in tempPool;
            std::set_union(uPool2.begin(), uPool2.end(), 
                           uPoolNew.begin(), uPoolNew.end(), 
                           std::inserter(tempPool, tempPool.begin()) );

            // move results to uPool2
            uPool2.swap(tempPool);
            tempPool.clear();

            // clear uPoolNew
            uPoolNew.clear();

            // for all the new v clusters, find the new u clusters
            for( clusPoolIter = vPoolNew.begin(); clusPoolIter != vPoolNew.end(); ++clusPoolIter ){
               StEEmcHitPtrVec_t& hitPtrVec = vClus2HitMap[ (*clusPoolIter) ].second;

               // iterate over hits associated with this v cluster, and add u clusters to the new u pool
               for( hitPtrVecIter = hitPtrVec.begin(); hitPtrVecIter != hitPtrVec.end(); ++hitPtrVecIter )
                  uPoolNew.insert( (*hitPtrVecIter)->getClusIDu() );
            };

            // compute union of vPoolNew and vPool2, store the results in tempPool
            std::set_union(vPool2.begin(), vPool2.end(), 
                           vPoolNew.begin(), vPoolNew.end(), 
                           std::inserter(tempPool, tempPool.begin()) );

            // move results to vPool2
            vPool2.swap(tempPool);
            tempPool.clear();

            // clear vPoolNew
            vPoolNew.clear();

            // of the new u clusters, determine how many are really "new", i.e. take a set difference
            std::set_difference(uPoolNew.begin(), uPoolNew.end(), 
                                uPool2.begin(), uPool2.end(), 
                                std::inserter(tempPool, tempPool.begin()) );

            // move results to uPoolNew
            uPoolNew.swap(tempPool);
            tempPool.clear();

#ifdef DEBUG
            LOG_INFO << i2 << " Have " << uPool2.size() << " u clus and " << vPool2.size() << " v clus in the second pool" << endm;
            LOG_INFO << i2 << " Have " << uPoolNew.size() << " u clus and " << vPoolNew.size() << " v clus in the new pool" << endm;

            LOG_INFO << "uPool2:" << endm;
            for( clusPoolIter = uPool2.begin(); clusPoolIter != uPool2.end(); ++clusPoolIter ){
               LOG_INFO << (*clusPoolIter) << endm;
            };
            LOG_INFO << "uPoolNew:" << endm;
            for( clusPoolIter = uPoolNew.begin(); clusPoolIter != uPoolNew.end(); ++clusPoolIter ){
               LOG_INFO << (*clusPoolIter) << endm;
            };
#endif
         };

         // uPool2 and vPool2 now contain a set of "tangled" u and v clusters

         // remove these pools from the main pools
         tempPool.clear();
         std::set_difference(uClusterPool.begin(), uClusterPool.end(), 
                             uPool2.begin(), uPool2.end(), 
                             std::inserter(tempPool, tempPool.begin()) );
         uClusterPool.swap( tempPool );
         tempPool.clear();
         std::set_difference(vClusterPool.begin(), vClusterPool.end(), 
                             vPool2.begin(), vPool2.end(), 
                             std::inserter(tempPool, tempPool.begin()));
         vClusterPool.swap( tempPool );
         tempPool.clear();

         // determine the topology
         Int_t nClusU = uPool2.size();
         Int_t nClusV = vPool2.size();

#ifdef DEBUG
         LOG_INFO << nClusU << 'x' << nClusV << endm;
#endif

         // a "real" point finder would now decide how to proceed
         // this on, instead, just counts
         if( nClusU >= kMaxNum )
            nClusU = kMaxNum - 1;
         if( nClusV >= kMaxNum )
            nClusV = kMaxNum - 1;

         ++mCounts[ nClusU ][ nClusV ];
         thisEventCouldMakeHits += ( nClusU && nClusV );
      }; // looping over the pool
   }; // looping over sectors

   if( !ierr && thisEventCouldMakeHits > 0 )
      ++mNonZeroEvents;

   // return the error code
   return ierr;
d80 1
a80 1
 * $Id: StEEmcPointFinderCounter.cxx,v 1.1 2011/12/15 18:06:02 sgliske Exp $
d82 3
@


1.1
log
@creation
@
text
@d10 1
d14 5
a18 2
#include "StEEmcUtil/EEmcGeom/EEmcGeomDefs.h"

d26 3
d30 3
a32 1
StEEmcPointFinderCounter_t::StEEmcPointFinderCounter_t() : StEEmcPointFinder_t() {
d35 1
d44 2
a45 2
   for( Int_t i = 0; i < kMaxNum; ++ i )
      for( Int_t j = 0; j < kMaxNum; ++ j )
d47 2
d52 1
a52 1
Int_t StEEmcPointFinderCounter_t::SetHitMakerPtr( StEEmcHitMaker_t *hitMakerPtr ){
d76 2
d88 3
a90 5
   StESMDClustersVec_t::const_iterator smdClusterVecIter;
   StSimpleClusterVec_t::const_iterator clusterIter;
   StClusterPool_t::const_iterator uClusPoolIter;
   StClusterPool_t::const_iterator vClusPoolIter;
   StClusterPool_t::const_iterator clusPoolIter;
d114 2
a115 2
      for( clusterIter = uClusVec.begin(); clusterIter != uClusVec.end(); ++clusterIter )
         uClusterPool.insert( &(*clusterIter) );
d118 6
a123 2
      for( clusterIter = vClusVec.begin(); clusterIter != vClusVec.end(); ++clusterIter )
         vClusterPool.insert( &(*clusterIter) );
d134 2
a135 2
      for( uClusPoolIter = uClusterPool.begin(); uClusPoolIter != uClusterPool.end() && !ierr; ++uClusPoolIter ){
         for( vClusPoolIter = vClusterPool.begin(); vClusPoolIter != vClusterPool.end() && !ierr; ++vClusPoolIter ){
d138 2
a139 2
            Float_t uSeedMean = (*uClusPoolIter)->getMeanX();
            Float_t vSeedMean = (*vClusPoolIter)->getMeanX();
d153 1
a153 1
            isValid &= towerPtr;
d166 4
a169 4
               hit.setEnergyU( (*uClusPoolIter)->getEnergy() );
               hit.setEnergyV( (*vClusPoolIter)->getEnergy() );
               hit.setClusIDu( (*uClusPoolIter)->getID() );
               hit.setClusIDv( (*vClusPoolIter)->getID() );
d187 2
a188 1
                  clus2HitMapIter = uClus2HitMap.find( (*uClusPoolIter)->getID() );
d190 1
a190 1
                     ( std:uClus2HitMap[ (*uClusPoolIter)->getID() ] = std::make_pair( (*uClusPoolIter), StEEmcHitPtrVec_t() ) ).second.push_back( &hit );
d194 12
d220 8
a227 1
      while( !uClusterPool.empty() ){
d231 2
a232 4
         uPoolNew.insert( uClusterPool.front() );
         uClusterPool.erase( uClusterPool.begin() );

         while( !uPoolNew.empty() ){
d234 3
d239 1
a239 1
               StEEmcHitPtrVec_t& hitPtrVec = uClus2HitMap[ clusPoolIter->getID() ].second;
d242 2
a243 2
               for( hitPtrVecIter = hitPtrVec; hitPtrVecIter != hitPtrVec; ++hitPtrVecIter )
                  vPoolNew.insert( vClus2HitMap[ (*hitPtrVecIter)->getClusIDv() ].first );
d249 1
a249 1
                           std::inserter(tempPool, tempPool.begin()));
d260 1
a260 1
               StEEmcHitPtrVec_t& hitPtrVec = vClus2HitMap[ clusPoolIter->getID() ].second;
d263 2
a264 2
               for( hitPtrVecIter = hitPtrVec; hitPtrVecIter != hitPtrVec; ++hitPtrVecIter )
                  uPoolNew.insert( uClus2HitMap[ (*hitPtrVecIter)->getClusIDu() ].first );
d270 1
a270 1
                           std::inserter(tempPool, tempPool.begin()));
d282 1
a282 1
                                std::inserter(tempPool, tempPool.begin()));
d287 14
d303 1
a303 1
         // uPool2 and vPool2 now contain sets of "tangled" u and v clusters
d309 1
a309 1
                             std::inserter(tempPool, tempPool.begin()));
d322 3
a324 1
         cout << nClusU << 'x' << nClusV << endl;
d334 1
d338 3
d349 5
a353 2
 * $Id: $
 * $Log: $
@

