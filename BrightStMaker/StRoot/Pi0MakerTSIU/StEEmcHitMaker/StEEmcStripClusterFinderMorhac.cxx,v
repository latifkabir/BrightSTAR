head	1.8;
access;
symbols
	response:1.6;
locks; strict;
comment	@// @;


1.8
date	2012.11.26.19.40.35;	author sgliske;	state dead;
branches;
next	1.7;

1.7
date	2012.05.17.22.47.02;	author sgliske;	state Exp;
branches;
next	1.6;

1.6
date	2012.03.07.22.30.46;	author sgliske;	state Exp;
branches;
next	1.5;

1.5
date	2011.12.13.21.32.27;	author sgliske;	state Exp;
branches;
next	1.4;

1.4
date	2011.12.09.18.01.26;	author sgliske;	state Exp;
branches;
next	1.3;

1.3
date	2011.12.08.15.43.02;	author sgliske;	state Exp;
branches;
next	1.2;

1.2
date	2011.12.07.22.33.27;	author sgliske;	state Exp;
branches;
next	1.1;

1.1
date	2011.12.07.22.33.11;	author sgliske;	state Exp;
branches;
next	;


desc
@@


1.8
log
@moved to official StEEmcPool
@
text
@/*!
 * \class StEEmcStripClusterFinderMorhac_t
 * \author Stephen Gliske <sgliske@@anl.gov>
 *
 * See header for description.
 *
*/

#include <list>
#include <TMath.h>
#include <TH1.h>

#include "StRoot/St_base/StMessMgr.h"
#include "StRoot/St_base/Stypes.h"

#include "StEEmcStripClusterFinderMorhac.h"
#include "StRoot/StEEmcPool/EEmcTreeContainers/EEmcEnergy.h"

//#define DEBUG
//#define DEBUG2
//#define DEBUG3

StEEmcStripClusterFinderMorhac_t::StEEmcStripClusterFinderMorhac_t( Int_t maxNumPoints, Float_t resolution ) : 
   mRemoveBkg( 1 ),
   mDoMarkov( 1 ),
   mMaxNumPoints( maxNumPoints ),
   mMinStripsPerCluster( 5 ),
   mNumDeconIters( 3 ),
   mAverWindow( 3 ),
   mNumSmoothIters( 10 ),
   mWidth( 3 ),
   mThreshold( 5 ),
   mMinPeakEnergy( 0.01 ),
   mMinClusterEnergy( 0.01 )
{
   peakFinderPtr = new TSpectrum( maxNumPoints, resolution );

   // initialize a few parent variables
   mLayer = U_LAYER;
   mSector = 0;
   mIsReady = 1;
};

StEEmcStripClusterFinderMorhac_t::~StEEmcStripClusterFinderMorhac_t(){
   delete peakFinderPtr;
};


/// find some clusters
Int_t StEEmcStripClusterFinderMorhac_t::find( const ESmdLayer_t& stripArray, StSimpleClusterVec_t& clusters ){
   clusters.clear();
   Int_t ierr = kStOk;

   if( mThreshold > 100 ){
      LOG_WARN << "Must specificy a threshold below 100.  Resetting to 99.9" << endm;
      mThreshold = 99.9;
   };

   if( mThreshold <= 0 ){
      LOG_WARN << "Must specificy a positive threshold.  Resetting to 1" << endm;
      mThreshold = 1;
   };

   // skip if not enough strips hit
   if( stripArray.nStrips < mMinStripsPerCluster )
      return ierr;

   // clear array
   for( Float_t *p = mStripEnergyArray, *p2 = mSmoothedEnergyArray; p != &mStripEnergyArray[kEEmcNumStrips]; ++p, ++p2 )
      (*p) = (*p2) = 0;

   // copy 
   Int_t stripIdx = 0;
   for( const EEmcElement_t *strip = stripArray.strip; strip != &stripArray.strip[288]; ++strip, ++stripIdx ){
      if( !strip->fail && strip->energy ){
         mStripEnergyArray[    stripIdx ] = strip->energy;
         mSmoothedEnergyArray[ stripIdx ] = strip->energy;

#ifdef DEBUG_INPUT
         cout << "ccc " << iter->index() << ' ' << iter->energy() << endl;
#endif
      };
   };

   // copied from TSpectrum::Search function, so set OK sigma
   Float_t sigma = mWidth;
   if( mWidth < 1 ) {
      sigma = kEEmcNumStrips/mMaxNumPoints;
      if (sigma < 1)
         sigma = 1;
      if (sigma > 8)
         sigma = 8;
   };

   // smooth, if requested
   if( mNumSmoothIters ){
      Float_t *fPtr;
      Double_t *dPtr;

      // copy
      for( fPtr = mSmoothedEnergyArray, dPtr = mStripEnergyArrayTemp; fPtr != &mSmoothedEnergyArray[kEEmcNumStrips]; ++fPtr, ++dPtr )
         (*dPtr) = (*fPtr);

      // smooth
      TH1::SmoothArray( kEEmcNumStrips, mStripEnergyArrayTemp, mNumSmoothIters );

      // copy back
      for( fPtr = mSmoothedEnergyArray, dPtr = mStripEnergyArrayTemp; fPtr != &mSmoothedEnergyArray[kEEmcNumStrips]; ++fPtr, ++dPtr )
         (*fPtr) = (*dPtr);

      // std::copy( mStripEnergyArrayTemp, mStripEnergyArrayTemp+kEEmcNumStrips, mSmoothedEnergyArray );
   };

   Int_t nPeaks = peakFinderPtr->SearchHighRes( mSmoothedEnergyArray, mDeconvoluted, kEEmcNumStrips, sigma,
                                                mThreshold, mRemoveBkg, mNumDeconIters, mDoMarkov, mAverWindow );

#ifdef DEBUG
   LOG_INFO << getEventNum() << " sector " << mSector << " layer " << mLayer << " found " << nPeaks << " peaks." << endm;
#endif

   // assign strips to nearest peak
   // should do this more intelligently in the future

#ifdef DEBUG4
   if( nPeaks ){
      Float_t *peakX = peakFinderPtr->GetPositionX();
      Float_t *peakY = peakFinderPtr->GetPositionY();

      LOG_INFO << "Morhac results" << endm;
      for( Int_t i=0; i<nPeaks; ++i ){
         LOG_INFO << peakX[i] << ' ' << peakY[i] << endm;
      };
   };
#endif

   std::vector< Float_t > peakPos;
   if( nPeaks ){
      Float_t *peakPosRAW = peakFinderPtr->GetPositionX();
      peakPos.reserve( nPeaks );

      // estimate energy of peak strip and its adjacent neighbors
      for( Int_t i=0; i<nPeaks; ++i ){
         Int_t idx = peakPosRAW[i]+0.5;
         Float_t energy = mStripEnergyArray[ idx ];
         if( idx )
            energy += mStripEnergyArray[ idx-1 ];
         if( idx+1 < kEEmcNumStrips )
            energy += mStripEnergyArray[ idx+1 ];

         if( energy > mMinPeakEnergy )
            peakPos.push_back( peakPosRAW[i] );

#ifdef DEBUG3
         LOG_INFO << "Morhac peak " << i << " at " <<  peakPosRAW[i] << ' ' << energy << endm;
#endif
      };
      nPeaks = peakPos.size();
   };

   if( nPeaks ){
      // rename for the sort
      std::vector< Float_t >& sortedPeakPos = peakPos;
      std::sort( sortedPeakPos.begin(), sortedPeakPos.end() );

      std::vector< Float_t > midPoints;
      midPoints.reserve( nPeaks - 1 );

      clusters.reserve( nPeaks );
      std::vector< Int_t > stripsPerClus;
      stripsPerClus.reserve( kEEmcNumStrips );

      for( Int_t i=0; i<nPeaks; ++i ){
         stripsPerClus.clear();

         clusters.push_back( StSimpleCluster_t( ++mLastClusterID ) );
         StSimpleCluster_t& clus = clusters.back();
         clus.setMeanX( sortedPeakPos[i] );

         Float_t pos1 = 0, pos2 = kEEmcNumStrips;
         if( i != 0 )
            pos1 = 0.5*(sortedPeakPos[i-1] + sortedPeakPos[i]) + 0.5;
         if( i != nPeaks-1 )
            pos2 = 0.5*(sortedPeakPos[i+1] + sortedPeakPos[i]) + 0.5;

         Float_t energy = 0;
         for( Int_t i=pos1; i<pos2; ++i )
            if( mStripEnergyArray[i] ){
               stripsPerClus.push_back( i );
               energy += mStripEnergyArray[i];
            };

         Int_t n = stripsPerClus.size();

#ifdef DEBUG2
         LOG_INFO << "Number of strips " << n << " vs " << mMinStripsPerCluster << " energy " << energy << " vs " << mMinClusterEnergy << endm;
#endif

         if( n >= mMinStripsPerCluster && energy > mMinClusterEnergy ){
            TArrayS& memArr = clus.getMemberArray();
            TArrayF& wArr = clus.getWeightArray();

            memArr.Set( n );
            wArr.Set( n );

            Float_t maxStripE = 0;
            Int_t seedIdx = -1;

            for( Int_t i = 0; i < n; ++i ){
               Int_t idx = stripsPerClus.back();
               stripsPerClus.pop_back();

               memArr[i] = idx;
               wArr[i] = 1;

               const Float_t& thisE = mStripEnergyArray[ idx ];
               if( thisE > maxStripE ){
                  maxStripE = thisE;
                  seedIdx = i;
               };
            };

            clus.setEnergy( energy );
            clus.setSeedIdx( seedIdx );

#ifdef DEBUG
            LOG_INFO << "Final results: event " << getEventNum() << " sector/layer " << mSector << '/'
                     << (mLayer ? 'v' : 'u') << ' ' << clus << endm;
#endif

         } else {
            clusters.pop_back();
         };
      };
   };

   return ierr;
};

ClassImp( StEEmcStripClusterFinderMorhac_t );

/*
 * $Id: StEEmcStripClusterFinderMorhac.cxx,v 1.7 2012/05/17 22:47:02 sgliske Exp $
 * $Log: StEEmcStripClusterFinderMorhac.cxx,v $
 * Revision 1.7  2012/05/17 22:47:02  sgliske
 * working on switching to EEmcTree containers
 *
 * Revision 1.6  2012/03/07 22:30:46  sgliske
 * general updates
 *
 * Revision 1.5  2011/12/13 21:32:27  sgliske
 * Bug fix: now ensure clusters have unique IDs across sectors and layers.
 * Otherwise, StMcHitMakerStrips has errors.
 * Few other small updates also included in this checkin.
 *
 * Revision 1.4  2011/12/09 18:01:26  sgliske
 * update
 *
 * Revision 1.3  2011/12/08 15:43:02  sgliske
 * update
 *
 * Revision 1.2  2011/12/07 22:33:27  sgliske
 * update
 *
 *
 */
@


1.7
log
@working on switching to EEmcTree containers
@
text
@d242 1
a242 1
 * $Id: StEEmcStripClusterFinderMorhac.cxx,v 1.6 2012/03/07 22:30:46 sgliske Exp $
d244 3
@


1.6
log
@general updates
@
text
@d17 1
d50 1
a50 1
Int_t StEEmcStripClusterFinderMorhac_t::find( const StEEmcStripVec_t& hitStrips, StSimpleClusterVec_t& clusters ){
d65 1
a65 1
   if( hitStrips.size() < static_cast< UInt_t >( mMinStripsPerCluster ) )
d73 5
a77 4
   for( StEEmcStripVec_t::const_iterator iter = hitStrips.begin(); iter != hitStrips.end(); ++iter ){
      if( !iter->fail()  ){
         mStripEnergyArray[ iter->index() ] =  iter->energy();
         mSmoothedEnergyArray[ iter->index() ] =  iter->energy();
d242 1
a242 1
 * $Id: StEEmcStripClusterFinderMorhac.cxx,v 1.5 2011/12/13 21:32:27 sgliske Exp $
d244 3
@


1.5
log
@Bug fix: now ensure clusters have unique IDs across sectors and layers.
Otherwise, StMcHitMakerStrips has errors.
Few other small updates also included in this checkin.
@
text
@d11 1
d29 1
d68 2
a69 2
   for( Float_t *p = mStripEnergyArray; p != &mStripEnergyArray[kEEmcNumStrips]; ++p )
      (*p) = 0;
d75 1
d93 20
a112 1
   Int_t nPeaks = peakFinderPtr->SearchHighRes( mStripEnergyArray, mDeconvoluted, kEEmcNumStrips, sigma,
d240 1
a240 1
 * $Id: StEEmcStripClusterFinderMorhac.cxx,v 1.4 2011/12/09 18:01:26 sgliske Exp $
d242 5
@


1.4
log
@update
@
text
@d151 1
a151 1
         clusters.push_back( StSimpleCluster_t( i ) );
d218 1
a218 1
 * $Id: StEEmcStripClusterFinderMorhac.cxx,v 1.3 2011/12/08 15:43:02 sgliske Exp $
d220 3
@


1.3
log
@update
@
text
@a15 1
#include "GmmEm1D/GmmEm1D.h"
a19 1
//#define DEBUG4
d24 1
d30 1
d69 1
a69 2
   // copy into GmmEm input structure
   GmmEmDataVec_t gmmEmData, gmmEmSeedPtrs;
d74 1
a74 1
#ifdef DEBUG2
d83 1
a83 1
      sigma = kEEmcNumStrips/peakFinderPtr->GetNPeaks();
d94 1
a94 1
   cout << getEventNum() << " sector " << mSector << " layer " << mLayer << " found " << nPeaks << " peaks." << endm;
d100 11
a110 30
   Float_t *peakPos = peakFinderPtr->GetPositionX();
   std::vector< Float_t > sortedPeakPos( peakPos, peakPos+nPeaks );
   std::sort( sortedPeakPos.begin(), sortedPeakPos.end() );

   std::vector< Float_t > midPoints;
   midPoints.reserve( nPeaks - 1 );

   clusters.reserve( nPeaks );
   std::vector< Int_t > stripsPerClus;
   stripsPerClus.reserve( kEEmcNumStrips );

   for( Int_t i=0; i<nPeaks; ++i ){
      stripsPerClus.clear();

      clusters.push_back( StSimpleCluster_t( i ) );
      StSimpleCluster_t& clus = clusters.back();
      clus.setMeanX( sortedPeakPos[i] );

      Float_t pos1 = 0, pos2 = kEEmcNumStrips;
      if( i != 0 )
         pos1 = 0.5*(sortedPeakPos[i-1] + sortedPeakPos[i]) + 0.5;
      if( i != nPeaks-1 )
         pos2 = 0.5*(sortedPeakPos[i+1] + sortedPeakPos[i]) + 0.5;

      Float_t energy = 0;
      for( Int_t i=pos1; i<pos2; ++i )
         if( mStripEnergyArray[i] ){
            stripsPerClus.push_back( i );
            energy += mStripEnergyArray[i];
         };
d112 13
a124 1
      Int_t n = stripsPerClus.size();
d126 2
a127 3
      if( n >= mMinStripsPerCluster && energy > mMinClusterEnergy ){
         TArrayS& memArr = clus.getMemberArray();
         TArrayF& wArr = clus.getWeightArray();
d129 6
a134 2
         memArr.Set( n );
         wArr.Set( n );
d136 31
a166 2
         Float_t maxStripE = 0;
         Int_t seedIdx = -1;
d168 1
a168 3
         for( Int_t i = 0; i < n; ++i ){
            Int_t idx = stripsPerClus.back();
            stripsPerClus.pop_back();
d170 3
a172 2
            memArr[i] = idx;
            wArr[i] = 1;
d174 22
a195 4
            const Float_t& thisE = mStripEnergyArray[ idx ];
            if( thisE > maxStripE ){
               maxStripE = thisE;
               seedIdx = idx;
d197 11
a208 5

         clus.setEnergy( energy );
         clus.setSeedIdx( seedIdx );
      } else {
         clusters.pop_back();
d218 1
a218 1
 * $Id: StEEmcStripClusterFinderMorhac.cxx,v 1.2 2011/12/07 22:33:27 sgliske Exp $
d220 3
@


1.2
log
@update
@
text
@d23 9
a31 1
StEEmcStripClusterFinderMorhac_t::StEEmcStripClusterFinderMorhac_t( Int_t maxGmmIters ) : peakFinderPtr(0), mMinStripsPerCluster(5),
d33 2
d42 1
a42 2
   if( peakFinderPtr )
      delete peakFinderPtr;
d46 4
a49 2
Int_t StEEmcStripClusterFinderMorhac_t::Init(){
   peakFinderPtr = new TSpectrum( mMaxNumPoints, mResolution );
a60 9
   return kStOk;
};


/// find some clusters
Int_t StEEmcStripClusterFinderMorhac_t::find( const StEEmcStripVec_t& hitStrips, StSimpleClusterVec_t& clusters ){
   clusters.clear();
   Int_t ierr = kStOk;

d81 9
d91 1
a91 1
   Int_t nPeaks = peakFinderPtr->SearchHighRes( mStripEnergyArray, mDeconvoluted, kEEmcNumStrips, mWidth,
d171 5
a175 2
 * $Id:  $
 * $Log:  $
a177 1
>
@


1.1
log
@update
@
text
@d164 1
@

