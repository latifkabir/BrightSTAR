head	1.6;
access;
symbols
	response:1.5;
locks; strict;
comment	@// @;


1.6
date	2012.10.09.03.57.19;	author sgliske;	state dead;
branches;
next	1.5;

1.5
date	2011.12.06.22.36.35;	author sgliske;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.30.23.03.14;	author sgliske;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.28.16.52.23;	author sgliske;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.28.15.33.39;	author sgliske;	state Exp;
branches;
next	1.1;

1.1
date	2011.11.23.19.06.47;	author sgliske;	state Exp;
branches;
next	;


desc
@@


1.6
log
@removed unused makers
@
text
@/*!
 *
 * \class StEEmcAnlSplitHitIQR_t
 * \author Stephen Gliske <sgliske@@anl.gov>
 *
 * See description in the header file
 *
 */

//#define DEBUG

#include <map>
#include <set>
#include <cmath>
#include <algorithm>
#include "assert.h"

#include "StRoot/St_base/StMessMgr.h"
#include "StRoot/St_base/Stypes.h"
#include "StRoot/StEEmcPool/StEEmcGeoId/StEEmcGeoId.h"
#include "StRoot/StEEmcPool/StEEmcPointMap/StEEmcPointMap.h"
#include "AnlEMPoint.h"
#include "StEEmcAnlHit.h"
#include "StEEmcAnlSplitHitIQR.h"



/// Construtor, deconstructor
StEEmcAnlSplitHitIQR_t::StEEmcAnlSplitHitIQR_t( Int_t maxGmmIters ) :
   mMaxNumTrials(10),
   mA(15.5), mB(-5.0), mC(-0.40), mD(0.0083),
   mDefaultSigma(0.15), mIQRsigmaRatio(0.6),
   mMinStripE(0.002)
{
   mGmmEm.setMaxIters( maxGmmIters );
};

StEEmcAnlSplitHitIQR_t::~StEEmcAnlSplitHitIQR_t(){ /* */ };

/// Initialize
Int_t StEEmcAnlSplitHitIQR_t::Init(){
   Int_t ierr = kStOk;

   // set random seed
   rand.SetSeed();

   // check parameter values
   if( mMaxNumTrials < 1 ){
      LOG_WARN << "mMaxNumTrials < 1.  Resetting to 10" << endm;
      mMaxNumTrials = 10;
   };

   return ierr;
};

/// Find all the hits
Int_t StEEmcAnlSplitHitIQR_t::splitHit( const StEEmcAnlHit_t& hit, Bool_t& doSplit, Bool_t& doInvalidate, AnlEMPoint_t& point1, AnlEMPoint_t& point2 ){
   Int_t ierr = kStOk;
   doSplit = 0;
   doInvalidate = 0;

   // clear arrays
   for( Int_t i=0; i<kMaxNumLayers; ++i )
      for( Float_t *p = mStripEnergyArray[i]; p != &mStripEnergyArray[i][kEEmcNumStrips]; ++p )
         (*p) = 0;

   // containers
   std::map< Int_t, Int_t > sectorPlaneToIdxMap;
   std::vector< Int_t > sectorPlaneVec;

   // some iterators
   StEEmcAnlHitList_t::iterator hitIter;
   StEEmcAnlElementSet_t::const_iterator stripSetIter;
   std::map< Int_t, Int_t >::iterator sectorPlaneToIdxMapIter;

   // loop over all strips in the hit and copy data to mStripEnergyArray
   const StEEmcAnlElementSet_t stripSet = hit.getStripSet();
   for( stripSetIter = stripSet.begin(); stripSetIter != stripSet.end(); ++stripSetIter ){
      Short_t sector, strip;
      Bool_t layerIsV;

      StEEmcGeoId_t::decodeSmd( stripSetIter->getGeoId(), sector, layerIsV, strip );
      Int_t sectorPlane = sector*2 + layerIsV;

      sectorPlaneToIdxMapIter = sectorPlaneToIdxMap.find( sectorPlane );
      if( sectorPlaneToIdxMapIter == sectorPlaneToIdxMap.end() ){
         sectorPlaneVec.push_back( sectorPlane );
         sectorPlaneToIdxMap[ sectorPlane ] = sectorPlaneVec.size()-1;
      };

      Int_t idx = sectorPlaneToIdxMap[ sectorPlane ];

      ierr = kStErr;
      if( idx < kMaxNumLayers ){
         ierr = kStOk;

         Float_t e = stripSetIter->getEnergy();

         // Sanity check
         if( e > 10 ){
            LOG_WARN << "Sanity check failure: SMD Strip with > 10 GeV energy deposited. Strip will be ignored." << endm;
            e = 0;
         };

         // if below threshod, set to zero
         if( e < mMinStripE )
            e = 0; 

         mStripEnergyArray[ idx ][ strip ] = e;
      };
   };

   // clear the IQR
   for( Float_t *p = mIQR; p != &mIQR[kMaxNumLayers]; ++p )
      (*p) = 0;

   // number of layers
   Int_t nLayers = sectorPlaneVec.size();
#ifdef DEBUG
   LOG_INFO << "nLayers (a) = " << nLayers << endm;
   for( UInt_t i=0; i<sectorPlaneVec.size(); ++i ){
      LOG_INFO << "sector, layer " << sectorPlaneVec[i]/2 << ' ' << (sectorPlaneVec[i]%2 ? 'v' : 'u') << endm;
   };
#endif

   if( nLayers > kMaxNumLayers ){
      LOG_ERROR << "Hit involves " << nLayers << " layers, but max is set to " << kMaxNumLayers << endl;
      ierr = kStErr;
   };

   // invalidated the hit if it contains less than two layers
   if( nLayers < 2 ){
      // flag to invalidate hit
      doInvalidate = 1;
   } else if (!ierr ){
      // determine the IQR per each layer

      // will resum non-zero layers
      Int_t nLayersOld = nLayers;
      nLayers = 0;
      for( Int_t layerIdx = 0; layerIdx < nLayersOld; ++layerIdx ){
         Float_t *stripEnergyArray = mStripEnergyArray[ layerIdx ];

         // compute the cummulative distribution and the energy weighted mean
         Float_t& totE = mTotE[ layerIdx ];
         Float_t& meanIdx = mEwMean[ layerIdx ];
         meanIdx = 0;
         totE = 0;
         Int_t idx = 0;
         for( Float_t *ptr = stripEnergyArray, *cdfPtr = mCDF; ptr != &stripEnergyArray[kEEmcNumStrips]; ++ptr, ++cdfPtr, ++idx ){
            meanIdx += (*ptr) * idx;
            totE += (*ptr );
            (*cdfPtr) = totE;
         };

         // make sure there is energy in this layer
         mIQR[ layerIdx ] = 0;
         mMedian[ layerIdx ] = 0;

         if( totE ){
            ++nLayers;
            mIQR[ layerIdx ] = findPosition( 0.75*totE ) - findPosition( 0.25*totE );
            mMedian[ layerIdx ] = findPosition( 0.5*totE );
            meanIdx /= totE;
         };

#ifdef DEBUG
         LOG_INFO << "layer " << layerIdx << " totE = " << totE << " IQR = " << mIQR[ layerIdx ] << " E_weighted_mean " << meanIdx << " median " << findPosition( 0.5*totE ) << endm;
#endif
      };
   };
   
   if( nLayers < 2 ){
      // flag to invalidate hit
      doInvalidate = 1;
   } else if ( !ierr ){

      // determine eta and ET for the hit
      mTempVector.SetX( hit.getX() );
      mTempVector.SetY( hit.getY() );
      mTempVector.SetZ( EEmcGeomSimple::Instance().getZSMD() );
      Float_t eta = mTempVector.Eta();
      Float_t ET = hit.getE() / TMath::CosH( eta );

      Int_t count = 0;
      Float_t IQR = 0;
      Int_t layerIdx = 0;
      Int_t sector = 0;
      Bool_t layerIsV = 0;
      do {
         // split the layer with the max difference
         Float_t *iqrPtr = std::max_element( mIQR, &mIQR[kMaxNumLayers] );

         // get the index for this layer
         layerIdx = std::distance( mIQR, iqrPtr );
         sector = sectorPlaneVec[ layerIdx ]/2;
         layerIsV = sectorPlaneVec[ layerIdx ]%2;
         IQR = (*iqrPtr );

         // make sure the other u or v strip for this same sector is also in the hit
         Int_t otherLayerSectorPlane = sector*2 + !layerIsV;

         sectorPlaneToIdxMapIter = sectorPlaneToIdxMap.find( otherLayerSectorPlane );
         count = 2;
         if( sectorPlaneToIdxMapIter == sectorPlaneToIdxMap.end() ){
            count = 1;

            // ignore this one, and try again
            (*iqrPtr ) = 0;
         };

#ifdef DEBUG
         //LOG_INFO << "Considering splitting sector " << sector << " layer " << (layerIsV ? 'v' : 'u' ) << " IQR = " << IQR << " count = " << count << endm;
#endif
      } while ( IQR && count == 1 );

      Float_t IQRthres = 0;
      if( IQR ){
         IQRthres = mA + mB * eta + mC * ET + mD * ET*ET;
      };

      if( IQR && IQR > IQRthres ){
         // split the layer

#ifdef DEBUG
      LOG_INFO << "Splitting sector " << sector << " layer " << (layerIsV ? 'v' : 'u' ) << " IQR = " << IQR << " count = " << count << endm;
#endif

         // determine the layer and get a pointer to the array
         Float_t *stripEnergyArray = mStripEnergyArray[ layerIdx ];

         // determine upper and lower search areas;

         // copy into GmmEm input structure
         GmmEmDataVec_t gmmEmData;

         Int_t startIdx = -1;
         Int_t stopIdx = -1;
         Int_t idx = 0;

         for( Float_t *stripIter = stripEnergyArray; stripIter != &stripEnergyArray[kEEmcNumStrips]; ++stripIter, ++idx ){
            if( *stripIter ){
               stopIdx = idx;
               if( startIdx == -1 )
                  startIdx = idx;
               gmmEmData.push_back( GmmEmDataElement_t( idx, *stripIter ) );
            };
         };

         // increment stopIdx so it is the one past the end, not the last valid one
         ++stopIdx;

         Int_t idxDiff = (stopIdx - startIdx);

         // to store the clusters
         GmmEmGausParamVec_t gmmClusters(2);

         // multiply once now, rather than ever loop
         Float_t defaultSigmaSq = mDefaultSigma*mDefaultSigma;
         Float_t maxSigmaSq = IQR * mIQRsigmaRatio;
         maxSigmaSq *= maxSigmaSq;

         // try multiple starting places, until find a solution with all sigmas less than the overall sigma
         Bool_t goodClustersFound = 0;
         for( Int_t tryNum = 0; tryNum < mMaxNumTrials && !goodClustersFound; ++tryNum ){
            if( gmmClusters.size() != 2 )
               gmmClusters.resize(2);

            gmmClusters[0].A = 1;
            gmmClusters[0].mean = idxDiff*rand.Rndm() + startIdx;
            gmmClusters[0].sigmaSq = defaultSigmaSq;

            gmmClusters[1].A = 1;
            gmmClusters[1].mean = idxDiff*rand.Rndm() + startIdx;
            gmmClusters[1].sigmaSq = defaultSigmaSq;

            Int_t gmmErrCode = mGmmEm.solve( gmmEmData, gmmClusters );
            if( gmmErrCode ){
               LOG_WARN << "GMM EM Algo had an error: '" << mGmmEm.getMessage() << "'" << endm;
               ierr = kStErr;
            } else if( gmmClusters[0].sigmaSq < maxSigmaSq && gmmClusters[0].sigmaSq < maxSigmaSq && gmmClusters[0].A > 0 && gmmClusters[1].A > 0 ) {
               goodClustersFound = 1;
            };
         };

         if( !goodClustersFound ){
            //LOG_WARN << "GMM EM could not find `good' clusters after " << mMaxNumTrials << " trials.  Will not split." << endm;
            doSplit = 0;
         } else {
            doSplit = 1;
            point1.W() = gmmClusters[0].A;
            point2.W() = gmmClusters[1].A;

            Double_t splitPos1 = gmmClusters[0].mean;
            Double_t splitPos2 = gmmClusters[1].mean;

#ifdef DEBUG
            LOG_INFO << "GMM Results: "
                     << gmmClusters[0].A << ' ' << gmmClusters[0].mean << ", "
                     << gmmClusters[1].A << ' ' << gmmClusters[1].mean << endm;
#endif

            // find the layerIdx for the other layer
            Int_t otherSectorPlane = sector*2 + !layerIsV;

            sectorPlaneToIdxMapIter =  sectorPlaneToIdxMap.find( otherSectorPlane );
            assert( sectorPlaneToIdxMapIter != sectorPlaneToIdxMap.end() ); // already checked that it is in there
            Int_t otherIdx = sectorPlaneToIdxMapIter->second;

            // use the 2nd quartile for the position in the other layer
            Float_t otherActual = mMedian[otherIdx];
            Float_t otherExpected = mEwMean[otherIdx];
            Float_t notSplitPosMean = 0.5*( otherActual + otherExpected );
            Float_t notSplitPos1 = 0, notSplitPos2 = 0;

            // give a small 'kick' off to the sides for the layer that is not split
            Float_t shiftDist = ( otherActual - otherExpected );
            notSplitPos1 = notSplitPosMean + shiftDist;
            notSplitPos2 = notSplitPosMean - shiftDist;
            if( gmmClusters[1].A > gmmClusters[0].A ){
               notSplitPos1 = notSplitPosMean - shiftDist;
               notSplitPos2 = notSplitPosMean + shiftDist;
            };
            if( shiftDist != shiftDist || notSplitPosMean != notSplitPosMean ){
               LOG_ERROR << "Encountered not a number" << endl;
               // must be NaN
               cout << otherActual << ' ' << otherExpected << ' ' << endl;
               ierr = kStErr;
            };
#ifdef DEBUG
            LOG_INFO << "Shift is " << shiftDist << " about mean of " << notSplitPosMean << " tot E is " << mTotE[otherIdx] << endm;
            //LOG_INFO << otherActual << ' ' << otherExpected << ' ' << notSplitPosMean << endl;
#endif

            Double_t u1 = splitPos1;
            Double_t v1 = notSplitPos1;
            Double_t u2 = splitPos2;
            Double_t v2 = notSplitPos2;

            if( layerIsV ){
               u1 = notSplitPos1;
               v1 = splitPos1;
               u2 = notSplitPos2;
               v2 = splitPos2;
            };

            StEEmcPointMap_t::instance().convertStripUVtoXY( sector, u1, v1, point1.X(), point1.Y() );
            StEEmcPointMap_t::instance().convertStripUVtoXY( sector, u2, v2, point2.X(), point2.Y() );

            mSector = sector;
            if( layerIsV ){
               mU1hitUncert = mIQR[ otherIdx ]*0.6;
               mV1hitUncert = sqrt(gmmClusters[0].sigmaSq);
               mU2hitUncert = mU1hitUncert;
               mV2hitUncert = sqrt(gmmClusters[1].sigmaSq);
            } else {
               mU1hitUncert = sqrt(gmmClusters[0].sigmaSq);
               mV1hitUncert = mIQR[ otherIdx ]*0.6;        
               mU2hitUncert = sqrt(gmmClusters[1].sigmaSq);
               mV2hitUncert = mV1hitUncert;
            };

#ifdef DEBUG
            LOG_INFO << "Hit a: " << u1 << ' ' << v1 << " -> " << point1.X() << ' ' << point1.Y() << endm;
            LOG_INFO << "Hit b: " << u2 << ' ' << v2 << " -> " << point2.X() << ' ' << point2.Y() << endm;
#endif
            };
      };
   };

   return ierr;
};

// to find quartile positions
Float_t StEEmcAnlSplitHitIQR_t::findPosition( Float_t energy ){
   Float_t *iter1 = mCDF;
   Float_t *iter2 = mCDF;
   for( iter2 = mCDF; iter2 != &mCDF[kEEmcNumStrips-1] && (*iter2) < energy; ++iter2 )
      if( (*iter2) < energy )
         iter1 = iter2;

   // note: iter1 points to the last one before being over, and iter2 points to the first one after
   return (Int_t)(iter1 - mCDF) + (energy-(*iter1))/((*iter2)-(*iter1))*((Int_t)( iter2 - iter1 ));
};

Int_t StEEmcAnlSplitHitIQR_t::getUncert( Int_t& sector, Float_t& u1hitUncert, Float_t& v1hitUncert, Float_t& u2hitUncert, Float_t& v2hitUncert ){
   sector = mSector;
   u1hitUncert = mU1hitUncert;
   v1hitUncert = mV1hitUncert;
   u2hitUncert = mU2hitUncert;
   v2hitUncert = mV2hitUncert;

   return 0;
};



ClassImp( StEEmcAnlSplitHitIQR_t );

/*
 * $Id: StEEmcAnlSplitHitIQR.cxx,v 1.5 2011/12/06 22:36:35 sgliske Exp $
 * $Log: StEEmcAnlSplitHitIQR.cxx,v $
 * Revision 1.5  2011/12/06 22:36:35  sgliske
 * update
 *
 * Revision 1.4  2011/11/30 23:03:14  sgliske
 * today
 *
 * Revision 1.3  2011/11/28 16:52:23  sgliske
 * today
 *
 * Revision 1.2  2011/11/28 15:33:39  sgliske
 * update
 *
 * Revision 1.1  2011/11/23 19:06:47  sgliske
 * creation
 *
 * 
 */

@


1.5
log
@update
@
text
@d401 1
a401 1
 * $Id: StEEmcAnlSplitHitIQR.cxx,v 1.4 2011/11/30 23:03:14 sgliske Exp $
d403 3
@


1.4
log
@today
@
text
@d10 1
a10 1
#define DEBUG
d32 2
a33 1
   mDefaultSigma(0.15), mIQRsigmaRatio(0.6)
d98 2
d105 4
d157 3
d163 1
d168 1
a168 1
         LOG_INFO << "layer " << layerIdx << " totE = " << totE << " IQR = " << mIQR[ layerIdx ] << " E_weighted_mean " << meanIdx << endm;
d213 1
a213 1
         LOG_INFO << "Considering splitting sector " << sector << " layer " << (layerIsV ? 'v' : 'u' ) << " IQR = " << IQR << " count = " << count << endm;
d287 1
a287 1
            LOG_WARN << "GMM EM could not find `good' clusters after " << mMaxNumTrials << " trials.  Will not split." << endm;
d311 1
a311 1
            Float_t otherActual = findPosition( 0.5*mTotE[otherIdx] );
d324 6
d332 1
d350 13
d386 10
d401 1
a401 1
 * $Id: StEEmcAnlSplitHitIQR.cxx,v 1.3 2011/11/28 16:52:23 sgliske Exp $
d403 3
@


1.3
log
@today
@
text
@d139 2
d142 3
a144 1
         for( Float_t *ptr = stripEnergyArray, *cdfPtr = mCDF; ptr != &stripEnergyArray[kEEmcNumStrips]; ++ptr, ++cdfPtr ){
d153 1
d157 1
a157 1
         LOG_INFO << "layer " << layerIdx << " totE = " << totE << " IQR = " << mIQR[ layerIdx ] << endm;
d300 4
a303 6
            Float_t notSplitIQR = mIQR[otherIdx];
            Float_t notSplitPosMean = findPosition( 0.75*mTotE[otherIdx] );

            // make sure the kick is in the right direction
            if( gmmClusters[1].A > gmmClusters[0].A )
               notSplitIQR = -notSplitIQR;
d306 7
a312 3
            Float_t notSplitPos1 = notSplitPosMean + notSplitIQR;
            Float_t notSplitPos2 = notSplitPosMean - notSplitIQR;

d314 1
a314 1
            LOG_INFO << "Shift is " << notSplitIQR << " about mean of " << notSplitPosMean << endm;
d333 2
a334 2
            LOG_INFO << "Hit 1: " << u1 << ' ' << v1 << " -> " << point1.X() << ' ' << point1.Y() << endm;
            LOG_INFO << "Hit 2: " << u2 << ' ' << v2 << " -> " << point2.X() << ' ' << point2.Y() << endm;
d360 1
a360 1
 * $Id: StEEmcAnlSplitHitIQR.cxx,v 1.2 2011/11/28 15:33:39 sgliske Exp $
d362 3
@


1.2
log
@update
@
text
@d10 1
a10 1
//#define DEBUG
d31 2
a32 1
   mA(15.5), mB(-5.0), mC(-0.40), mD(0.0083)
a68 1
   IQRData_t quartileData;
a73 1
   IQRData_t::iterator quartileDataIter;
d113 1
a113 1
   LOG_INFO << "nLayers (1) = " << nLayers << endm;
d115 1
a115 1
      LOG_INFO << sectorPlaneVec[i]/2 << ' ' << (sectorPlaneVec[i]%2 ? 'v' : 'u') << endm;
d121 1
a121 1
      ierr = kErr;
d138 2
a139 1
         Float_t totE = 0;
d163 5
a167 5
      mTempVector.SetX( hit->getX() );
      mTempVector.SetY( hit->getY() );
      mTempVector.SetZ( EEmcGeomSimple.instance().getZSMD() );
      Float_t eta = mTempVector.eta();
      Float_t ET = hit->getEnergy() / TMath::CosH( eta );
d195 4
d203 1
a203 1
         IQRthres = a + b * eta + c * ET + d * ET*ET;
d210 1
a210 1
      LOG_INFO << "Splitting " << sector << " layer " << (layerIsV ? 'v' : 'u' ) << " sumSqDif = " << sumSqDif << " count = " << count << endm;
d244 1
a244 1
         Float_t maxSigmaSq = IQR * mAllowedSigmaFrac;
d296 1
a296 1
            Float_t notSplitPosMean = findPosition( 0.75*totE );
d353 1
a353 1
 * $Id: StEEmcAnlSplitHitIQR.cxx,v 1.1 2011/11/23 19:06:47 sgliske Exp $
d355 3
@


1.1
log
@creation
@
text
@d240 1
a240 1
         Float_t maxSigmaSq = quartileDataIter->mUncert * mAllowedSigmaFrac;
d291 6
a296 4
            Float_t otherActual = quartileData[otherIdx].mQinnerData[1].mActual;
            Float_t otherExpected = quartileData[otherIdx].mQinnerData[1].mExpected;
            Float_t notSplitPosMean = 0.5*( otherActual + otherExpected );
            Float_t notSplitPos1 = 0, notSplitPos2 = 0;
d299 3
a301 7
            Float_t biggerDist = ( otherActual - otherExpected );
            notSplitPos1 = notSplitPosMean + biggerDist;
            notSplitPos2 = notSplitPosMean - biggerDist;
            if( gmmClusters[1].A > gmmClusters[0].A ){
               notSplitPos1 = notSplitPosMean - biggerDist;
               notSplitPos2 = notSplitPosMean + biggerDist;
            };
d303 1
a303 1
            LOG_INFO << "Shift is " << biggerDist << " about mean of " << notSplitPosMean << endm;
d349 5
a353 2
 * $Id: $
 * $Log: $
@

