head	1.8;
access;
symbols
	response:1.5;
locks; strict;
comment	@// @;


1.8
date	2012.11.26.19.40.35;	author sgliske;	state dead;
branches;
next	1.7;

1.7
date	2012.05.31.22.13.14;	author sgliske;	state Exp;
branches;
next	1.6;

1.6
date	2012.05.17.22.47.02;	author sgliske;	state Exp;
branches;
next	1.5;

1.5
date	2012.01.02.17.14.42;	author sgliske;	state Exp;
branches;
next	1.4;

1.4
date	2011.12.28.15.06.10;	author sgliske;	state Exp;
branches;
next	1.3;

1.3
date	2011.12.28.14.54.22;	author sgliske;	state Exp;
branches;
next	1.2;

1.2
date	2011.12.22.16.46.36;	author sgliske;	state Exp;
branches;
next	1.1;

1.1
date	2011.12.19.18.23.55;	author sgliske;	state Exp;
branches;
next	;


desc
@@


1.8
log
@moved to official StEEmcPool
@
text
@/*!
 * \class StEEmcStripClusterFinderTSP_t
 * \author Stephen Gliske <sgliske@@anl.gov>
 *
 * See header for description.
 *
*/

#include <TH1.h>
#include <assert.h>
#include <algorithm>

#include "StRoot/St_base/StMessMgr.h"
#include "StRoot/St_base/Stypes.h"

#include "StEEmcStripClusterFinderTSP.h"
#include "StRoot/StEEmcPool/EEmcTreeContainers/EEmcEnergy.h"

//#define DEBUG_CHILD
//#define DEBUG
//#define DEBUG2
//#define DEBUG_INPUT

StEEmcStripClusterFinderTSP_t::StEEmcStripClusterFinderTSP_t() :
   mNumSmoothIters( 10 ),
   mMinStripsPerCluster( 5 ),
   mMaxDist( 5 ),
   mSearchMargin( 3 ),
   mSeedAbsThres( 0.0005 ),
   mSeedRelThres( 0.15 ),
   mAbsPeakValleyThres( 0.0015 ),
   mAnomalySupFactor( 0.1 )
{
   // initialize a few parent variables
   mLayer = U_LAYER;
   mSector = 0;
   mIsReady = 1;
};

StEEmcStripClusterFinderTSP_t::~StEEmcStripClusterFinderTSP_t(){
   // nothing to do
};


/// find some clusters
Int_t StEEmcStripClusterFinderTSP_t::find( const ESmdLayer_t& stripArray, StSimpleClusterVec_t& clusters ){
   clusters.clear();
   Int_t ierr = kStOk;

   // skip if not enough strips hit
   if( (UInt_t)(stripArray.nStrips) < mMinStripsPerCluster )
      return ierr;

   // clear array
   for( Double_t *p1 = mStripEnergyArray, *p2 = mSmoothedEnergyArrayA, *p3 = mSmoothedEnergyArrayB; p1 != &mStripEnergyArray[kEEmcNumStrips]; ++p1, ++p2, ++p3 )
      (*p1) = (*p2) = (*p3) = 0;

   // copy
   mSmallestIdx = kEEmcNumStrips;
   mLargestIdx = -1;

   Int_t stripIdx = 0;
   for( const EEmcElement_t *strip = stripArray.strip; strip != &stripArray.strip[288]; ++strip, ++stripIdx ){
      if( !strip->fail && strip->energy ){
         if( mSmallestIdx > stripIdx )
            mSmallestIdx = stripIdx;
         if( mLargestIdx < stripIdx )
             mLargestIdx = stripIdx;

         mStripEnergyArray[     stripIdx ] = strip->energy;
         mSmoothedEnergyArrayA[ stripIdx ] = strip->energy;
      };
   };

   if( mSmallestIdx < mLargestIdx ){
      // i.e. there are some strips that do not fail and have non-zero energy

      // smooth step A
      TH1::SmoothArray( kEEmcNumStrips, mSmoothedEnergyArrayA, mNumSmoothIters );

      // only need to look on the part of array where there is nonzero energy
      assert( mSearchMargin > 0 );
      Int_t iStart = mSmallestIdx - mSearchMargin;  // just a little margin to be safe
      Int_t iEnd = mLargestIdx + mSearchMargin;
      if( iStart < 1 )
         iStart = 1;
      if( iEnd > kEEmcNumStrips-1 )
         iEnd = kEEmcNumStrips-1;

      // smooth step B: remove anomalies and copy to energy array B
      for( Double_t *p0 = &mSmoothedEnergyArrayA[ iStart-1 ], *p1 = &mSmoothedEnergyArrayA[ iStart ], *p2 = &mSmoothedEnergyArrayA[ iStart+1 ], *pB = &mSmoothedEnergyArrayB[ iStart ];
           p1 != &mSmoothedEnergyArrayA[iEnd]; ++p0, ++p1, ++p2, ++pB ){

         Double_t sum = ((*p0) + (*p2))*0.5;
         Double_t upper = sum*(1 + mAnomalySupFactor );
         Double_t lower = sum*(1 - mAnomalySupFactor );
         (*pB) = ( (*p1) > upper ? upper : ( (*p1) < lower ? lower : (*p1) ) );
      };

#ifdef DEBUG_INPUT
      for( Int_t idx = mSmallestIdx; idx <= mLargestIdx; ++idx ){
         cout << "bbb " << mSector << ' ' << (mLayer ? 'v' : 'u' ) << ' ' << idx << ' ' << mStripEnergyArray[idx] << ' ' << mSmoothedEnergyArrayB[idx] << endl;
      };
#endif

      // find largest strip energy and set peek threshold
      Double_t maxEnergy = *std::max_element( mSmoothedEnergyArrayB, mSmoothedEnergyArrayB+kEEmcNumStrips );
      Double_t thres = std::max( mSeedAbsThres, mSeedRelThres*maxEnergy );

#ifdef DEBUG2
      LOG_INFO << "Sector " << mSector << '/' << mLayer << " Max energy strip is " << maxEnergy << ", thres is " << thres << endm;
#endif

      // find all the peeks above threshold and save them as seeds


      // vector of seeds
      IntVec_t seedVec;
   
      // peak and valley energies
      std::list< Double_t > peakE, valleyE;
      valleyE.push_back( 0 );
      Double_t smallestValley = 0;

      for( Double_t *p1 = &mSmoothedEnergyArrayB[iStart], *p0 = p1-1, *p2 = p1+1; p1 != &mSmoothedEnergyArrayB[iEnd]; ++p0, ++p1, ++p2 ){
         if( *p1 > thres && *p1 > *p0 && *p1 > *p2 ){
            // register the last valley
            valleyE.push_back( smallestValley );

            if( !seedVec.empty() ){
               // see if the peak before should still be a seed or not
               if( peakE.back() - valleyE.back() < mAbsPeakValleyThres ){
                  peakE.pop_back();
                  valleyE.pop_back();
                  seedVec.pop_back();
               };
            };

            // see if this peak should be a seed
            if( *p1 - valleyE.back() >= mAbsPeakValleyThres ){
               peakE.push_back( *p1 );
               seedVec.push_back( std::distance( mSmoothedEnergyArrayB, p1 ) );
            };

            // set smallest valley to a value larger than any possible
            // valley height
            smallestValley = *p1;
         };

         if( *p1 < smallestValley && ((*p1 < *p0 && *p1 < *p2) || ( *p1 == 0 && *p0 != 0 )) )
            smallestValley = *p1;
      };

#ifdef DEBUG
      LOG_INFO << "Sector " << mSector << '/' << mLayer << " Found " << seedVec.size() << " seeds" << endm;
#endif
#ifdef DEBUG2
      if( !seedVec.empty() ){
         LOG_INFO << "\t\tSeeds are ";
         for( IntVec_t::iterator iter = seedVec.begin(); iter != seedVec.end(); ++iter ){
            LOG_INFO << *iter << ' ';
         };
         LOG_INFO << endm;
      };
#endif

      if( !seedVec.empty() ){

         // for each seed, find the positions where energy deposition starts to increase
         IntVec_t leftStrip, rightStrip;
         IntVec_t::iterator iter;

         for( iter = seedVec.begin(); iter != seedVec.end(); ++iter ){
            // left side

            Double_t *p0, *p1, *p2;

            // left side
            for( p1 = &mSmoothedEnergyArrayB[*iter], p0 = p1-1; p1 != &mSmoothedEnergyArrayB[iStart] && (*p1) >= (*p0) && (*p1); --p1, --p0 );
            leftStrip.push_back( std::distance( mSmoothedEnergyArrayB, p1 ) );

            // right side
            for( p1 = &mSmoothedEnergyArrayB[*iter], p2 = p1+1; p1 != &mSmoothedEnergyArrayB[iEnd] && (*p1) >= (*p2) && (*p1); ++p1, ++p2 );
            rightStrip.push_back( std::distance( mSmoothedEnergyArrayB, p1 ) );

#ifdef DEBUG2
            LOG_INFO << "Cluster with seed " << *iter << " may span " << leftStrip.back() << " to " << rightStrip.back() << endm;
#endif
         };

         IntVec_t stripsPerClus;
         stripsPerClus.reserve( 50 );

         Int_t idx = 0;
         Int_t lastIdx = seedVec.size() - 1;
         for( iter = seedVec.begin(); iter != seedVec.end(); ++iter, ++idx ){
            stripsPerClus.clear();

            // find left position
            UInt_t left = leftStrip[idx];
            if( *iter - left < mMaxDist )
               left = std::max( (Int_t)(*iter - mMaxDist), (Int_t)( idx > 0 ? rightStrip[ idx-1 ] : 0 ) );  // comparison must be done with Ints, not UInts, or will fail

            // find right position
            UInt_t right = rightStrip[idx];
            if( right - *iter < mMaxDist )
               right = std::min( *iter + mMaxDist, (UInt_t)( idx < lastIdx ? leftStrip[ idx+1 ] : kEEmcNumStrips-1 ) );
            // set right to be the one just past the last to include
            ++right;

#ifdef DEBUG2
            LOG_INFO << "Cluster with seed " << *iter << " spans " << left << " to " << right << endm;
#endif

            Int_t seedIdx = *iter;
            Double_t energy = 0;
            Double_t energySq = 0;
            Double_t weightedMean = 0;
            Double_t weightedVar = 0;
            Int_t idx = left;
            for( Double_t *p = &mStripEnergyArray[left]; p != &mStripEnergyArray[right]; ++p, ++idx ){
               if( *p ){
                  //cout << "TSP -- clus " << *iter << " strip " << idx << " E " << *p << ' ' << energy << endl;

                  stripsPerClus.push_back( idx );
                  energy += *p;
                  energySq += (*p)*(*p);
                  weightedMean += idx*(*p);
                  weightedVar += idx*(*p)*(*p);
               };
            };
            if( energy && stripsPerClus.size() >= mMinStripsPerCluster ){
               weightedMean /= energy;
               weightedVar /= energy;
               weightedVar -= weightedMean*weightedMean;
               weightedVar *= 1/( 1 - energySq/energy/energy);

               // add cluster
               clusters.push_back( StSimpleCluster_t( ++mLastClusterID ) );
               StSimpleCluster_t& clus = clusters.back();

               Int_t n = stripsPerClus.size();

               TArrayS& memArr = clus.getMemberArray();
               TArrayF& wArr = clus.getWeightArray();

               memArr.Set( n );
               wArr.Set( n );

               Int_t internalSeedIdx = 0;
               for( Int_t i = 0; i < n; ++i ){
                  Int_t idx = stripsPerClus.back();
                  stripsPerClus.pop_back();
                  memArr[i] = idx;
                  wArr[i] = 1;

                  if( idx == seedIdx )
                     internalSeedIdx = i;
               };

               clus.setMeanX( weightedMean );
               clus.setMeanY( weightedVar );
               clus.setEnergy( mSmoothedEnergyArrayB[ seedIdx ] );
               clus.setSeedIdx( internalSeedIdx );
            }; 
         }; // iterating over seeds
      }; // have seeds
   }; // non-zero number of valid strips
#ifdef DEBUG
   for( UInt_t i=0; i<clusters.size(); ++i ){
      LOG_INFO << "Final results: event " << getEventNum() << " sector/layer " << mSector << '/'
               << (mLayer ? 'v' : 'u') << ' ' << clusters[i] << endm;
   };
#endif
#ifdef DEBUG_CHILD
   for( UInt_t i=0; i<clusters.size(); ++i ){
      LOG_INFO << "TSP final results: event " << getEventNum() << " sector/layer " << mSector << '/'
               << (mLayer ? 'v' : 'u') << ' ' << clusters[i] << " sigma " << clusters[i].getMeanY() << endm;
   };
#endif

   return ierr;
};

ClassImp( StEEmcStripClusterFinderTSP_t );

/*
 * $Id: StEEmcStripClusterFinderTSP.cxx,v 1.7 2012/05/31 22:13:14 sgliske Exp $
 * $Log: StEEmcStripClusterFinderTSP.cxx,v $
 * Revision 1.7  2012/05/31 22:13:14  sgliske
 * working on MC
 *
 * Revision 1.6  2012/05/17 22:47:02  sgliske
 * working on switching to EEmcTree containers
 *
 * Revision 1.5  2012/01/02 17:14:42  sgliske
 * update
 *
 * Revision 1.4  2011/12/28 15:06:10  sgliske
 * update
 *
 * Revision 1.3  2011/12/28 14:54:22  sgliske
 * update
 *
 * Revision 1.2  2011/12/22 16:46:36  sgliske
 * general update
 *
 * Revision 1.1  2011/12/19 18:23:55  sgliske
 * creation
 *
 *
 */
@


1.7
log
@working on MC
@
text
@d288 1
a288 1
 * $Id: StEEmcStripClusterFinderTSP.cxx,v 1.6 2012/05/17 22:47:02 sgliske Exp $
d290 3
@


1.6
log
@working on switching to EEmcTree containers
@
text
@d65 1
a65 1
         if( mSmallestIdx == -1 )
d67 2
a68 1
         mLargestIdx = stripIdx;
d75 2
a76 2
   // smooth step A
   TH1::SmoothArray( kEEmcNumStrips, mSmoothedEnergyArrayA, mNumSmoothIters );
d78 2
a79 17
   // only need to look on the part of array where there is nonzero energy
   Int_t iStart = mSmallestIdx - mSearchMargin;  // just a little margin to be safe
   Int_t iEnd = mLargestIdx + mSearchMargin;
   if( iStart < 1 )
      iStart = 1;
   if( iEnd > kEEmcNumStrips-1 )
      iEnd = kEEmcNumStrips-1;

   // smooth step B: remove anomalies
   for( Double_t *p0 = &mSmoothedEnergyArrayA[ iStart-1 ], *p1 = &mSmoothedEnergyArrayA[ iStart ], *p2 = &mSmoothedEnergyArrayA[ iStart+1 ], *pB = &mSmoothedEnergyArrayB[ iStart ];
        p1 != &mSmoothedEnergyArrayA[iEnd]; ++p0, ++p1, ++p2, ++pB ){

      Double_t sum = ((*p0) + (*p2))*0.5;
      Double_t upper = sum*(1 + mAnomalySupFactor );
      Double_t lower = sum*(1 - mAnomalySupFactor );
      (*pB) = ( (*p1) > upper ? upper : ( (*p1) < lower ? lower : (*p1) ) );
   };
d81 18
d101 3
a103 3
   for( Int_t idx = mSmallestIdx; idx <= mLargestIdx; ++idx ){
      cout << "bbb " << mSector << ' ' << (mLayer ? 'v' : 'u' ) << ' ' << idx << ' ' << mStripEnergyArray[idx] << ' ' << mSmoothedEnergyArrayB[idx] << endl;
   };
d106 3
a108 3
   // find largest strip energy and set peek threshold
   Double_t maxEnergy = *std::max_element( mSmoothedEnergyArrayB, mSmoothedEnergyArrayB+kEEmcNumStrips );
   Double_t thres = std::max( mSeedAbsThres, mSeedRelThres*maxEnergy );
d111 1
a111 1
   LOG_INFO << "Sector " << mSector << '/' << mLayer << " Max energy strip is " << maxEnergy << ", thres is " << thres << endm;
d114 1
a114 1
   // find all the peeks above threshold and save them as seeds
d117 2
a118 2
   // vector of seeds
   IntVec_t seedVec;
d120 23
a142 16
   // peak and valley energies
   std::list< Double_t > peakE, valleyE;
   valleyE.push_back( 0 );
   Double_t smallestValley = 0;

   for( Double_t *p1 = &mSmoothedEnergyArrayB[iStart], *p0 = p1-1, *p2 = p1+1; p1 != &mSmoothedEnergyArrayB[iEnd]; ++p0, ++p1, ++p2 ){
      if( *p1 > thres && *p1 > *p0 && *p1 > *p2 ){
         // register the last valley
         valleyE.push_back( smallestValley );

         if( !seedVec.empty() ){
            // see if the peak before should still be a seed or not
            if( peakE.back() - valleyE.back() < mAbsPeakValleyThres ){
               peakE.pop_back();
               valleyE.pop_back();
               seedVec.pop_back();
a143 1
         };
d145 3
a147 4
         // see if this peak should be a seed
         if( *p1 - valleyE.back() >= mAbsPeakValleyThres ){
            peakE.push_back( *p1 );
            seedVec.push_back( std::distance( mSmoothedEnergyArrayB, p1 ) );
d150 2
a151 3
         // set smallest valley to a value larger than any possible
         // valley height
         smallestValley = *p1;
a153 4
      if( *p1 < smallestValley && ((*p1 < *p0 && *p1 < *p2) || ( *p1 == 0 && *p0 != 0 )) )
         smallestValley = *p1;
   };

d155 1
a155 1
   LOG_INFO << "Sector " << mSector << '/' << mLayer << " Found " << seedVec.size() << " seeds" << endm;
d158 6
a163 4
   if( !seedVec.empty() ){
      LOG_INFO << "\t\tSeeds are ";
      for( IntVec_t::iterator iter = seedVec.begin(); iter != seedVec.end(); ++iter ){
         LOG_INFO << *iter << ' ';
a164 2
      LOG_INFO << endm;
   };
d167 1
a167 1
   if( !seedVec.empty() ){
d169 3
a171 3
      // for each seed, find the positions where energy deposition starts to increase
      IntVec_t leftStrip, rightStrip;
      IntVec_t::iterator iter;
d173 2
a174 2
      for( iter = seedVec.begin(); iter != seedVec.end(); ++iter ){
         // left side
d176 1
a176 1
         Double_t *p0, *p1, *p2;
d178 3
a180 3
         // left side
         for( p1 = &mSmoothedEnergyArrayB[*iter], p0 = p1-1; p1 != &mSmoothedEnergyArrayB[iStart] && (*p1) >= (*p0) && (*p1); --p1, --p0 );
         leftStrip.push_back( std::distance( mSmoothedEnergyArrayB, p1 ) );
d182 3
a184 3
         // right side
         for( p1 = &mSmoothedEnergyArrayB[*iter], p2 = p1+1; p1 != &mSmoothedEnergyArrayB[iEnd] && (*p1) >= (*p2) && (*p1); ++p1, ++p2 );
         rightStrip.push_back( std::distance( mSmoothedEnergyArrayB, p1 ) );
d187 1
a187 1
         LOG_INFO << "Cluster with seed " << *iter << " may span " << leftStrip.back() << " to " << rightStrip.back() << endm;
d189 1
a189 1
      };
d191 2
a192 2
      IntVec_t stripsPerClus;
      stripsPerClus.reserve( 50 );
d194 16
a209 16
      Int_t idx = 0;
      Int_t lastIdx = seedVec.size() - 1;
      for( iter = seedVec.begin(); iter != seedVec.end(); ++iter, ++idx ){
         stripsPerClus.clear();

         // find left position
         UInt_t left = leftStrip[idx];
         if( *iter - left < mMaxDist )
            left = std::max( (Int_t)(*iter - mMaxDist), (Int_t)( idx > 0 ? rightStrip[ idx-1 ] : 0 ) );  // comparison must be done with Ints, not UInts, or will fail

         // find right position
         UInt_t right = rightStrip[idx];
         if( right - *iter < mMaxDist )
            right = std::min( *iter + mMaxDist, (UInt_t)( idx < lastIdx ? leftStrip[ idx+1 ] : kEEmcNumStrips-1 ) );
         // set right to be the one just past the last to include
         ++right;
d212 1
a212 1
         LOG_INFO << "Cluster with seed " << *iter << " spans " << left << " to " << right << endm;
d215 16
a230 15
         Int_t seedIdx = *iter;
         Double_t energy = 0;
         Double_t energySq = 0;
         Double_t weightedMean = 0;
         Double_t weightedVar = 0;
         Int_t idx = left;
         for( Double_t *p = &mStripEnergyArray[left]; p != &mStripEnergyArray[right]; ++p, ++idx ){
            if( *p ){
               //cout << "TSP -- clus " << *iter << " strip " << idx << " E " << *p << ' ' << energy << endl;

               stripsPerClus.push_back( idx );
               energy += *p;
               energySq += (*p)*(*p);
               weightedMean += idx*(*p);
               weightedVar += idx*(*p)*(*p);
d232 37
a268 38
         };
         if( energy && stripsPerClus.size() >= mMinStripsPerCluster ){
            weightedMean /= energy;
            weightedVar /= energy;
            weightedVar -= weightedMean*weightedMean;
            weightedVar *= 1/( 1 - energySq/energy/energy);

            // add cluster
            clusters.push_back( StSimpleCluster_t( ++mLastClusterID ) );
            StSimpleCluster_t& clus = clusters.back();

            Int_t n = stripsPerClus.size();

            TArrayS& memArr = clus.getMemberArray();
            TArrayF& wArr = clus.getWeightArray();

            memArr.Set( n );
            wArr.Set( n );

            Int_t internalSeedIdx = 0;
            for( Int_t i = 0; i < n; ++i ){
               Int_t idx = stripsPerClus.back();
               stripsPerClus.pop_back();
               memArr[i] = idx;
               wArr[i] = 1;

               if( idx == seedIdx )
                  internalSeedIdx = i;
            };

            clus.setMeanX( weightedMean );
            clus.setMeanY( weightedVar );
            clus.setEnergy( mSmoothedEnergyArrayB[ seedIdx ] );
            clus.setSeedIdx( internalSeedIdx );
         }; 
      }; // iterating over seeds
   }; // have seeds

d288 1
a288 1
 * $Id: StEEmcStripClusterFinderTSP.cxx,v 1.5 2012/01/02 17:14:42 sgliske Exp $
d290 3
@


1.5
log
@update
@
text
@d17 1
d46 1
a46 1
Int_t StEEmcStripClusterFinderTSP_t::find( const StEEmcStripVec_t& hitStrips, StSimpleClusterVec_t& clusters ){
d51 1
a51 1
   if( hitStrips.size() < mMinStripsPerCluster )
d61 10
a70 10
   for( StEEmcStripVec_t::const_iterator iter = hitStrips.begin(); iter != hitStrips.end(); ++iter ){
      if( !iter->fail()  ){
         Int_t idx = iter->index();
         mStripEnergyArray[ idx ] =  iter->energy();
         mSmoothedEnergyArrayA[ idx ] =  iter->energy();

         if( idx > mLargestIdx )
            mLargestIdx = idx;
         if( idx < mSmallestIdx )
            mSmallestIdx = idx;
d284 1
a284 1
 * $Id: StEEmcStripClusterFinderTSP.cxx,v 1.4 2011/12/28 15:06:10 sgliske Exp $
d286 3
@


1.4
log
@update
@
text
@d85 1
a85 1
   for( Double_t *p0 = mSmoothedEnergyArrayA[ iStart-1 ], *p1 = mSmoothedEnergyArrayA[ iStart ], *p2 = mSmoothedEnergyArrayA[ iStart+1 ], *pB = mSmoothedEnergyArrayB[ iStart ];
d197 1
a197 1
            left = std::max( *iter - mMaxDist, (UInt_t)( idx > 0 ? rightStrip[ idx-1 ] : 0 ) );
d283 1
a283 1
 * $Id: StEEmcStripClusterFinderTSP.cxx,v 1.3 2011/12/28 14:54:22 sgliske Exp $
d285 3
@


1.3
log
@update
@
text
@d30 2
a31 1
   mAbsPeakValleyThres( 0.0015 )
d54 2
a55 2
   for( Double_t *p1 = mSmoothedEnergyArray, *p2 = mStripEnergyArray; p1 != &mSmoothedEnergyArray[kEEmcNumStrips]; ++p1, ++p2 )
      (*p1) = (*p2) = 0;
d64 1
a64 1
         mSmoothedEnergyArray[ idx ] =  iter->energy();
d73 21
a93 2
   // smooth
   TH1::SmoothArray( kEEmcNumStrips, mSmoothedEnergyArray, mNumSmoothIters );
d97 1
a97 1
      cout << "bbb " << mSector << ' ' << (mLayer ? 'v' : 'u' ) << ' ' << idx << ' ' << mStripEnergyArray[idx] << ' ' << mSmoothedEnergyArray[idx] << endl;
d102 1
a102 1
   Double_t maxEnergy = *std::max_element( mSmoothedEnergyArray, mSmoothedEnergyArray+kEEmcNumStrips );
a110 7
   // only need to search on part of array where there is data
   Int_t iStart = mSmallestIdx - mSearchMargin;  // just a little margin to be safe
   Int_t iEnd = mLargestIdx + mSearchMargin;
   if( iStart < 1 )
      iStart = 1;
   if( iEnd > kEEmcNumStrips-1 )
      iEnd = kEEmcNumStrips-1;
d120 1
a120 1
   for( Double_t *p1 = &mSmoothedEnergyArray[iStart], *p0 = p1-1, *p2 = p1+1; p1 != &mSmoothedEnergyArray[iEnd]; ++p0, ++p1, ++p2 ){
d137 1
a137 1
            seedVec.push_back( std::distance( mSmoothedEnergyArray, p1 ) );
d174 2
a175 2
         for( p1 = &mSmoothedEnergyArray[*iter], p0 = p1-1; p1 != &mSmoothedEnergyArray[iStart] && (*p1) >= (*p0) && (*p1); --p1, --p0 );
         leftStrip.push_back( std::distance( mSmoothedEnergyArray, p1 ) );
d178 2
a179 2
         for( p1 = &mSmoothedEnergyArray[*iter], p2 = p1+1; p1 != &mSmoothedEnergyArray[iEnd] && (*p1) >= (*p2) && (*p1); ++p1, ++p2 );
         rightStrip.push_back( std::distance( mSmoothedEnergyArray, p1 ) );
d258 1
a258 1
            clus.setEnergy( mSmoothedEnergyArray[ seedIdx ] );
d283 1
a283 1
 * $Id: StEEmcStripClusterFinderTSP.cxx,v 1.2 2011/12/22 16:46:36 sgliske Exp $
d285 3
@


1.2
log
@general update
@
text
@d18 1
d57 2
a58 1
   Int_t smallestIdx = kEEmcNumStrips, largestIdx = -1;
d65 4
a68 4
         if( idx > largestIdx )
            largestIdx = idx;
         if( idx < smallestIdx )
            smallestIdx = idx;
d76 1
a76 1
   for( Int_t idx = smallestIdx; idx <= largestIdx; ++idx ){
d92 2
a93 2
   Int_t iStart = smallestIdx - mSearchMargin;  // just a little margin to be safe
   Int_t iEnd = largestIdx + mSearchMargin;
d199 1
d201 1
d205 2
d209 1
d211 1
d214 1
a214 1
         if( energy ){
d216 22
d239 2
a240 27
            if( stripsPerClus.size() >= mMinStripsPerCluster ){
               // add cluster
               clusters.push_back( StSimpleCluster_t( ++mLastClusterID ) );
               StSimpleCluster_t& clus = clusters.back();

               Int_t n = stripsPerClus.size();

               TArrayS& memArr = clus.getMemberArray();
               TArrayF& wArr = clus.getWeightArray();

               memArr.Set( n );
               wArr.Set( n );

               Int_t internalSeedIdx = 0;
               for( Int_t i = 0; i < n; ++i ){
                  Int_t idx = stripsPerClus.back();
                  stripsPerClus.pop_back();
                  memArr[i] = idx;
                  wArr[i] = 1;

                  if( idx == seedIdx )
                     internalSeedIdx = i;
               };

               clus.setMeanX( weightedMean );
               clus.setEnergy( mSmoothedEnergyArray[ seedIdx ] );
               clus.setSeedIdx( internalSeedIdx );
d242 6
a247 1
         }; // strip has 'energy'
d257 6
d270 1
a270 1
 * $Id: StEEmcStripClusterFinderTSP.cxx,v 1.1 2011/12/19 18:23:55 sgliske Exp $
d272 3
@


1.1
log
@creation
@
text
@d18 3
a20 3
#define DEBUG
#define DEBUG2
#define DEBUG_INPUT
d25 1
a25 1
   mMaxDist( 10 ),
d27 3
a29 2
   mSeedAbsThres( 0.001 ),
   mSeedRelThres( 0.15 )
a66 4

#ifdef DEBUG_INPUT
         cout << "ccc " << mSector << ' ' << (mLayer ? 'v' : 'u' ) << ' ' << iter->index() << ' ' << iter->energy() << endl;
#endif
d73 5
a77 2
   // vector of seeds
   IntVec_t seedVec;
d97 36
a132 3
   for( Double_t *p1 = &mSmoothedEnergyArray[iStart], *p0 = p1-1, *p2 = p1+1; p1 != &mSmoothedEnergyArray[iEnd]; ++p0, ++p1, ++p2 )
      if( *p1 > thres && *p1 > *p0 && *p1 >= *p2 )
         seedVec.push_back( std::distance( mSmoothedEnergyArray, p1 ) );
d139 1
a139 1
      LOG_INFO << "\tSeeds are ";
d165 4
d191 4
d206 2
a207 22
         assert( energy ); // this must be true or something really weird happened
         weightedMean /= energy;

         if( stripsPerClus.size() >= mMinStripsPerCluster ){
            // add cluster
            clusters.push_back( StSimpleCluster_t( ++mLastClusterID ) );
            StSimpleCluster_t& clus = clusters.back();

            Int_t n = stripsPerClus.size();

            TArrayS& memArr = clus.getMemberArray();
            TArrayF& wArr = clus.getWeightArray();

            memArr.Set( n );
            wArr.Set( n );

            Int_t internalSeedIdx = 0;
            for( Int_t i = 0; i < n; ++i ){
               Int_t idx = stripsPerClus.back();
               stripsPerClus.pop_back();
               memArr[i] = idx;
               wArr[i] = 1;
d209 27
a235 2
               if( idx == seedIdx )
                  internalSeedIdx = i;
d237 1
a237 5

            clus.setMeanX( weightedMean );
            clus.setEnergy( energy );
            clus.setSeedIdx( internalSeedIdx );
         };
d254 5
a258 2
 * $Id: $
 * $Log: $
@

